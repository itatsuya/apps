/*
 * File: app/view/panel/MetalColorPanelViewController.js
 *
 * This file was generated by Sencha Architect version 4.2.4.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 6.6.x Classic library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 6.6.x Classic. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RolandKioskPrint.view.panel.MetalColorPanelViewController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.panel.metalcolorpanel',

    listen: {
        controller: {
            'panel.backgroundpanel': {
                backgroundColorChanged: 'onBackgroundColorChanged'
            }
        }
    },

    getAllColorableObjects: function() {
        var canvas = RolandKioskPrint.AppData.getCanvas();
        var objects = [];

        var me = this;

        canvas.getObjects().forEach(function(o) {
            if (o.id != 'margin' && o.id != 'mask' && o.id != 'background') {
                me.getObjectsInner(o, objects, me.isColorableObject);
            }
        });
        return objects;
    },

    canApplyColor: function() {
        // Check if we can apply color with the current object selection state.
        if (this.isSelectionLocked()) {
            return false;
        }

        var objects = this.getSelectedColorableObjects(),
            canApply = (objects.length > 0);

        return canApply;
    },

    isSelectionLocked: function() {
        var canvas = RolandKioskPrint.AppData.getCanvas();
        var activeObject = canvas.getActiveObject();

        return (activeObject && activeObject.isLocked) ? true : false;
    },

    getSelectedColorableObjects: function() {
        var canvas = RolandKioskPrint.AppData.getCanvas();
        var selectedObjects = [];

        var me = this;
        canvas.getActiveObjects().forEach(function(o) {
            me.getObjectsInner(o, selectedObjects, me.isColorableObject);
        });

        return selectedObjects;
    },

    getObjectsInner: function(objectOrGroup, objects, callback) {
        var objectType = objectOrGroup.get('type');

        if (objectType == 'group' &&
            (!objectOrGroup.isPathGroup || objectOrGroup.sourceType == RolandKioskPrint.app.constants.OBJECT_SOURCE_SVG)) {
            var me = this;
            objectOrGroup.forEachObject(function(o) {
                me.getObjectsInner(o, objects, callback);
            });
        } else if (objectType == 'clippingGroup') {
            var element = objectOrGroup.getElement();
            if (callback(element)) {
                objects.push(element);
            }
        } else if (callback(objectOrGroup)) {
            objects.push(objectOrGroup);
        }
    },

    isColorableObject: function(object) {
        // Special objects are not colorable.
        if (object.isCutPath || object.editAreaType || object.get('id') == 'background') {
            return false;
        }

        // Image outlines.
        if (object.get('type') == 'path' && object.isOutlinePath) {
            return false;
        }

        // Imprint areas are not colorable.
        if (RolandKioskPrint.AppData.isImprintArea(object)) {
            return false;
        }

        // Neither are images.
        if (object.get('type') == 'image' || object.get('type') == 'clippingGroup') {
            return false;
        }

        // Nor is multi-color clipart.
        if (object.isPathGroup && !object.uniColor) {
            return false;
        }

        // Objects from SVG get to this point. Check if shading fill.
        if (object.fill && object.fill.toLive) {
            return false;
        }

        return true;
    },

    getColorAttribute: function(attrName, objects) {
        // Get the attribute value.
        // For empty selection, returns "empty".
        // If the selection has a single value for this attribute, returns
        // that value. Otherwise returns "mixed".
        var attrValue = 'empty';

        if (!objects) {
            objects = this.getSelectedColorableObjects();
        }

        if (objects.length > 0) {
            attrValue = objects[0].get(attrName);
        }

        for (var i = 1; i < objects.length; i++) {
            if (objects[i].get(attrName) != attrValue) {
                attrValue = 'mixed';
                break;
            }
        }
        return attrValue;
    },

    applyColorAttribute: function(attrName, attrValue, objects) {
        if (!objects) {
            objects = this.getSelectedColorableObjects();
        }

        for (var i = 0, length = objects.length; i < length; i++) {
            var obj = objects[i];
            obj.set(attrName, attrValue);

            if (obj.editAreaId) {
                obj[attrName + 'Orig'] = attrValue;
            }
        }
    },

    updatePanel: function() {
        var objects = this.getSelectedColorableObjects();
        var attrName = 'fillSharpness';
        var attrValue = this.getColorAttribute(attrName, objects);

        var chkFillSharpness = this.getView().down('#chkFillSharpness');
        var sharpnessSlider = this.getView().down('#sharpnessSlider');

        this.suppressEvents = true;

        // Update the controls.
        if (attrValue == 'mixed') {
            chkFillSharpness.setValue(false);
        } else {
            if (attrValue == RolandKioskPrint.app.constants.METAL_FILL_SHARPNESS_0) {
                chkFillSharpness.setValue(false); // Disables the sharpness slider as well
            } else {
                chkFillSharpness.setValue(true);
                var percentValue = this.getPercentByFillSharpness(attrValue);
                sharpnessSlider.setValue(percentValue);
            }
        }

        var attrName = 'stroke';
        var attrValue = this.getColorAttribute(attrName, objects);

        var chkDrawOutline = this.getView().down('#chkDrawOutline');
        chkDrawOutline.setValue(attrValue == RolandKioskPrint.app.constants.METAL_OUTLINE_COLOR_DEFAULT);

        this.suppressEvents = false;
    },

    getBackgroundColor: function() {
        var productModelData = RolandKioskPrint.AppData.productModelData;
        var backgroundColor = productModelData.backgroundColor;
        if (!backgroundColor) {
            backgroundColor = productModelData.materialColor;
        }

        return backgroundColor;
    },

    onBackgroundColorChanged: function(data) {
        // Check if we should respond.
        if (data.clientView != this.getView().clientView) {
            // Event fired by Client view and we are non-Client, or vice versa.
            return;
        }

        // Need not do anything if not metal print.
        var productModelData = RolandKioskPrint.AppData.productModelData;
        if (!productModelData.isMetalPrint()) {
            return;
        }

        var newColor = data.color;
        var canvasPanel = RolandKioskPrint.AppData.getCanvasPanel();
        var canvasPanelController = canvasPanel.getController();

        var objects = this.getAllColorableObjects();
        objects.forEach(function(o) {
            var sharpness = o.get('fillSharpness');
            var fillColor = canvasPanelController.applySharpnessToColor(newColor, sharpness);
            o.set('fill', fillColor);
        });
    },

    applyFillSharpness: function(sharpness, objects) {
        var canvasPanel = RolandKioskPrint.AppData.getCanvasPanel();
        var canvasPanelController = canvasPanel.getController();

        this.applyColorAttribute('fillSharpness', sharpness, objects);

        // Change the fill color as per the sharpness applied.
        var backgroundColor = this.getBackgroundColor();
        var fillColor = canvasPanelController.applySharpnessToColor(backgroundColor, sharpness);

        this.applyColorAttribute('fill', fillColor, objects);

        var canvas = RolandKioskPrint.AppData.getCanvas();
        canvas.renderAll();

        var activeObject = canvas.getActiveObject();
        if (activeObject) {
            canvas.fire('object:modified', {target: activeObject});
        }
    },

    getFillSharpnessByPercent: function(percentValue) {
        var sharpness = RolandKioskPrint.app.constants.METAL_FILL_SHARPNESS_DEFAULT;
        switch(percentValue)
        {
            case 70:
                sharpness = RolandKioskPrint.app.constants.METAL_FILL_SHARPNESS_70;
                break;
            case 85:
                sharpness = RolandKioskPrint.app.constants.METAL_FILL_SHARPNESS_85;
                break;
            case 100:
                sharpness = RolandKioskPrint.app.constants.METAL_FILL_SHARPNESS_100;
                break;
        }
        return sharpness;
    },

    getPercentByFillSharpness: function(sharpness) {
        var percentValue = 100;
        switch(sharpness)
        {
            case RolandKioskPrint.app.constants.METAL_FILL_SHARPNESS_70:
                percentValue = 70;
                break;
            case RolandKioskPrint.app.constants.METAL_FILL_SHARPNESS_85:
                percentValue = 85;
                break;
            case RolandKioskPrint.app.constants.METAL_FILL_SHARPNESS_100:
                percentValue = 100;
                break;
        }
        return percentValue;
    },

    onFillSharpnessCheckboxChange: function(field, newValue, oldValue, eOpts) {
        if (this.suppressEvents) {
            return;
        }

        var sharpness = RolandKioskPrint.app.constants.METAL_FILL_SHARPNESS_0;
        if (newValue) {
            var sharpnessSlider = this.getView().down('#sharpnessSlider');
            sharpness = this.getFillSharpnessByPercent(sharpnessSlider.getValue());
        }

        var objects = this.getSelectedColorableObjects();
        this.applyFillSharpness(sharpness, objects);
    },

    onSharpnessSliderChange: function(slider, newValue, thumb, type, eOpts) {
        if (this.suppressEvents) {
            return;
        }

        // Map the percent vaue to sharpness. For a continous slider, this is as simple as
        // multiplying percent value by 255. But with discrete levels, we use the predefined
        // constants instead.
        var sharpness = this.getFillSharpnessByPercent(newValue);
        this.applyFillSharpness(sharpness);
    },

    onDrawOutlineCheckboxChange: function(field, newValue, oldValue, eOpts) {
        if (this.suppressEvents) {
            return;
        }

        // Apply outline.
        var objects = this.getSelectedColorableObjects();
        var canvasController = RolandKioskPrint.AppData.getCanvasPanel().getController();
        if (newValue) {
            objects.forEach(function(o) {
                if (o.isPathGroup) {
                    canvasController.setDeviceStrokeWidth(o, RolandKioskPrint.app.constants.METAL_OUTLINE_STROKE_WIDTH);
                } else {
                    o.set('strokeWidth', RolandKioskPrint.app.constants.DEFAULT_STROKE_WIDTH);
                }

                o.set({
                    'stroke': RolandKioskPrint.app.constants.METAL_OUTLINE_COLOR_DEFAULT,
                    'isOutlinePath': true,
                    'isOutlinePathOrig': true
                });
            });
        } else {
            objects.forEach(function(o) {
                o.set({
                    'stroke': '',
                    'isOutlinePath': false,
                    'isOutlinePathOrig': false
                });
            });
        }

        var canvas = RolandKioskPrint.AppData.getCanvas();
        canvas.renderAll();

        var activeObject = canvas.getActiveObject();
        if (activeObject) {
            canvas.fire('object:modified', {target: activeObject});
        }
    },

    onPanelBeforeShow: function(component, eOpts) {
        // Update the panel.
        this.updatePanel();

        var canvas = RolandKioskPrint.AppData.getCanvas();
        var me = this;

        if (!this.onCanvasSelectionChange) {
            this.onCanvasSelectionChange = {
                'selection:created': function() {
                    me.updatePanel();
                },
                'selection:updated': function() {
                    me.updatePanel();
                },
                'selection:cleared': function() {
                    me.updatePanel();
                }
            };
        }

        canvas.on(this.onCanvasSelectionChange);
    },

    onPanelHide: function(component, eOpts) {
        // Unregister for canvas notifications.
        if (this.onCanvasSelectionChange) {
            var canvas = RolandKioskPrint.AppData.getCanvas();
            canvas.off(this.onCanvasSelectionChange);
        }
    }

});
