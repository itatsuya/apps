/*
 * File: app/view/panel/CutPanelViewController.js
 *
 * This file was generated by Sencha Architect version 4.2.4.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 6.6.x Classic library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 6.6.x Classic. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RolandKioskPrint.view.panel.CutPanelViewController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.panel.cutpanel',

    getCutTargetAreas: function(isProductDesigner) {
        var targetAreas = [];
        var canvas = RolandKioskPrint.AppData.getCanvas();

        // Check if an edit area is explicity targeted by selection.
        var selectedObjects = canvas.getActiveObjects();

        targetAreas = selectedObjects.filter(function(object) {
            var editAreaType = object.editAreaType;
            return (
                editAreaType == RolandKioskPrint.app.constants.EDIT_AREA_CUT
            );
        });

        if (targetAreas.length !== 0) {
            var canvasPanel = RolandKioskPrint.AppData.getCanvasPanel();
            canvasPanel.getController().sortObjects(targetAreas); // Arrange left top first.
            return targetAreas;
        }

        if (isProductDesigner) {
            // For product designer, we otherwise return a list of all cut areas.
            targetAreas = canvas.cutAreaList;
        }

        return targetAreas;
    },

    hasCutTextSelection: function() {
        var canvas = RolandKioskPrint.AppData.getCanvas(),
            activeObjects = canvas.getActiveObjects();

        return activeObjects.some(function(o) {
           return (o.get('type') == 'text' || o.get('type') == 'curved-text') && o.isCutPath;
        });
    },

    getNewRectBounds: function() {
        var canvasPanel = RolandKioskPrint.AppData.getCanvasPanel();
        var data = canvasPanel.getController().getProductMargins();

        var productWidth = data.widthMM - (data.leftMarginMM + data.rightMarginMM);
        var productHeight = data.heightMM - (data.topMarginMM + data.bottomMarginMM);

        var factor = RolandKioskPrint.app.constants.CUT_LINE_SIZE_FACTOR;
        var areaWidth = factor * productWidth;
        var areaHeight = factor * productHeight;
        var dim = (areaWidth < areaHeight) ? areaWidth : areaHeight; // make it a square

        var bounds = {
            left: data.leftMarginMM + (productWidth - dim) / 2,
            top: data.topMarginMM + (productHeight - dim)  / 2 ,
            width: dim,
            height: dim
        };

        return bounds;
    },

    setCutData: function(cutData) {
        this.getViewModel().setData(cutData); // Set the view model data
    },

    getCutData: function() {
        return this.getViewModel().getData();
    },

    isReplaceableObject: function(object) {
        if (!object.editAreaId || object.isLocked) {
            return false;
        }

        var type = object.get('type');
        var isCutLine = type != 'text' && type != 'curved-text' && object.isCutPath;
        return object.isPathGroup || isCutLine;
    },

    createCutLine: function(shapeType) {
        var canvasPanel = RolandKioskPrint.AppData.getCanvasPanel();
        var editArea,
            isProductDesigner = RolandKioskPrint.AppData.isProductDesigner();

        var targetAreas = this.getCutTargetAreas(isProductDesigner);
        if (targetAreas.length !== 0) {
            // For product model designer, this picks the selected edit area.
            // For product designer, this would pick up the selected or first available area.
            editArea = targetAreas[0];
        }

        if (!canvasPanel.getController().canAddObject()) {
            // Check if we have reached the maximum limit on number of objects.
            return;
        }

        // Exit clip mode if active.
        canvasPanel.getController().endClipping();

        var canvas = RolandKioskPrint.AppData.getCanvas(),
            activeObject = canvas.getActiveObject(),
            bounds;

        if (editArea) {
            bounds = canvasPanel.getController().getBoundingRect(editArea);
        } else if (activeObject) {
            bounds = activeObject.getBoundingRect(true);
        }

        if (bounds && shapeType != RolandKioskPrint.app.constants.SHAPE_TYPE_RECTANGLE) {
            bounds.height = bounds.width;
        }

        if (!bounds) {
            bounds = this.getNewRectBounds();
        }

        var isProductDesigner =
            (RolandKioskPrint.AppData.appMode == RolandKioskPrint.app.constants.APP_MODE_PRODUCT_DESIGNER);

        var sourceType = (
            isProductDesigner ? RolandKioskPrint.app.constants.OBJECT_SOURCE_PD
            : RolandKioskPrint.app.constants.OBJECT_SOURCE_PMD
        );

        var cutLineObject = canvasPanel.getController().getShapeObject(shapeType);
        cutLineObject.set({
            'fill': '',
            'stroke': this.getCutStrokeColor(),
            'strokeWidth': 0,
            'deviceStroke': true,
            'deviceStrokeWidth': RolandKioskPrint.app.constants.CUT_LINE_STROKE_WIDTH,
            'perPixelTargetFind': true,
            'targetFindTolerance': RolandKioskPrint.app.constants.CUT_LINE_HIT_TOLERANCE,
            'isCutPath': true, // Custom property
            'sourceType': sourceType,
            'objectCaching': false,
            'printType': RolandKioskPrint.app.constants.PRINT_TYPE_CUT
        });

        // Scale and position the object appropriately.
        var objBounds = cutLineObject.getBoundingRect(true),
            scaleX = bounds.width / objBounds.width,
            scaleY = bounds.height / objBounds.height;

        var scale = 1.0,
            dx = 0.0,
            dy = 0.0;

        if (editArea) {
            // Fit the cut line object to the edit area.
            if (scaleX < scaleY) {
                scale = scaleX;
                dy = bounds.height - scale * cutLineObject.height;
            } else {
                scale = scaleY;
                dx = bounds.width - scale * cutLineObject.width;
            }
        } else {
            scale = scaleX;
            dy = bounds.height - scale * cutLineObject.height;
            if (activeObject && activeObject != editArea) {
                dy = 0;
            }
        }

        // Scale the cut line object.
        if (scale != 1.0) {
            cutLineObject.set({
                'scaleX': scale,
                'scaleY': scale
            });
        }

        // Position the cut line object.
        cutLineObject.set({
            'left': bounds.left + dx / 2,
            'top': bounds.top + dy / 2
        });

        var activeObjects = canvas.getActiveObjects(),
            objectToReplace;

        if (isProductDesigner && activeObjects.length == 1 && this.isReplaceableObject(activeObjects[0])) {
            objectToReplace = activeObjects[0];
        }

        if (objectToReplace) {
            canvasPanel.getController().replaceObject(objectToReplace, cutLineObject);
        } else if (editArea) {
            canvasPanel.getController().addObjectToEditArea(cutLineObject, editArea);
        } else {
            canvas.add(cutLineObject);
        }

        cutLineObject.setCoords();

        canvas.setActiveObject(cutLineObject);

        canvas.calcOffset();
        canvas.renderAll();
    },

    getCutStrokeColor: function() {
        var strokeColor = RolandKioskPrint.app.constants.CUT_PATH_STROKE_COLOR,
            appData =  RolandKioskPrint.AppData;

        if (appData.isActivePrintTypeCut()) {
            strokeColor = RolandKioskPrint.app.getCutViewingColor(appData.productModelData.cutMaterialColor);
        }

        return strokeColor;
    },

    onTextTabShow: function(component, eOpts) {
        var textSubPanel = this.getView().down('#textSubPanel');
        textSubPanel.getController().parentShown();
    },

    onShapeViewItemClick: function(dataview, record, item, index, e, eOpts) {
        this.createCutLine(record.data.shapeType);
    },

    onPanelBeforeShow: function(component, eOpts) {
        var textSubPanel = this.getView().down('#textSubPanel');
        textSubPanel.getController().parentBeforeShown();
    },

    onPanelHide: function(component, eOpts) {
        var textSubPanel = this.getView().down('#textSubPanel');
        textSubPanel.getController().parentHidden();
    },

    onPanelShow: function(component, eOpts) {
        var textSubPanel = this.getView().down('#textSubPanel');
        textSubPanel.getController().parentShown();

        // Update the cut color for available cut lines.
        Ext.util.CSS.updateRule('.cut-line-type-icon', 'color', this.getCutStrokeColor());

        // Can the selected object be replaced?
        var canvas =  RolandKioskPrint.AppData.getCanvas();
        var activeObjects = canvas.getActiveObjects();
        if (activeObjects.length == 1 && this.isReplaceableObject(activeObjects[0])) {
            return;
        }

        var appData = RolandKioskPrint.AppData;
        if (appData.isProductDesigner() && appData.isActivePrintTypeCut()) {
            var tabPanel = this.getView().down('#pnlTab'),
                isActiveTabText = tabPanel.getActiveTab().itemId == 'pnlText';

            var selectEditArea = true;
            if (isActiveTabText && this.hasCutTextSelection()) {
                selectEditArea = false;
            }

            if (selectEditArea) {
                var targetAreas = this.getCutTargetAreas(true);
                if (targetAreas.length !== 0) {
                    var canvas = RolandKioskPrint.AppData.getCanvas();
                    // For product designer, this would pick up the selected or first available area.
                    if (targetAreas[0] != canvas.getActiveObject()) {
                        canvas.setActiveObject(targetAreas[0]);
                        canvas.renderAll();
                    }
                }
            }
        }
    },

    onPanelAfterRender: function(component, eOpts) {
        var textSubPanel = this.getView().down('#textSubPanel');
        textSubPanel.getViewModel().setData({
            'isCutPath': true
        });
    }

});
