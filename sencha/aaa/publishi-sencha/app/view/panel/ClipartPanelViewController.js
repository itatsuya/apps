/*
 * File: app/view/panel/ClipartPanelViewController.js
 *
 * This file was generated by Sencha Architect version 4.2.4.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 6.6.x Classic library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 6.6.x Classic. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RolandKioskPrint.view.panel.ClipartPanelViewController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.panel.clipartpanel',

    listen: {
        controller: {
            'panel.backgroundpanel': {
                backgroundColorChanged: 'onBackgroundColorChanged'
            }
        }
    },

    refreshCliparts: function(categoryName) {
        // Update the clipart view with the corresponding set of clipart items.
        var activePrintType = RolandKioskPrint.AppData.getActivePrintType(),
            clipartCategories


        if (activePrintType == RolandKioskPrint.app.constants.PRINT_TYPE_CUT) {
            clipartCategories = this.getViewModel().get('cutCategories')

        } else {
            clipartCategories = this.getViewModel().get('printCategories')

        }

        if (!clipartCategories) {
            return

        }

        // See if we need to only show unicolor clipart.
        var uniColor = (activePrintType == RolandKioskPrint.app.constants.PRINT_TYPE_FOIL ||
                        activePrintType == RolandKioskPrint.app.constants.PRINT_TYPE_CUT)


        var clipartItems = []

        for (var i = 0
 i < clipartCategories.length; i++) {
            var clipartCategory = clipartCategories[i]


            if (clipartCategory.categoryName == categoryName) {
                for (var j = 0
 j < clipartCategory.clipartItems.length; j++) {
                    var clipartItem = clipartCategory.clipartItems[j]


                    // Include the item if we are not filtering unicolor items, or,
                    // if we are picking only unicolor items and the item is unicolor.
                    if (!uniColor || clipartItem.uniColor) {
                        clipartItems.push({
                            fileType: clipartItem.fileType,
                            filePath: clipartItem.filePath,
                            defaultSizeCanvas: clipartCategories[i].defaultSizeCanvas,
                            defaultSizeEditArea: clipartCategories[i].defaultSizeEditArea

                        })

                    }
                }
                break

            }
        }

        var clipartView = this.getView().down('#clipartView'),
            store = clipartView.getStore()


        store.setData(clipartItems)


        clipartView.refresh()

    },

    getPrintCategories: function() {
        if (this.printCategories) {
            return this.printCategories

        }

        var clipartCategories = this.getViewModel().get('printCategories'),
            printCategories = []


        for (var i = 0
 i < clipartCategories.length; i++) {
            printCategories.push({
                categoryName: clipartCategories[i].categoryName
            })

        }

        this.printCategories = printCategories


        return this.printCategories

    },

    getUniColorPrintCategories: function() {
        if (this.uniColorPrintCategories) {
            return this.uniColorPrintCategories

        }

        var clipartCategories = this.getViewModel().get('printCategories')


        this.uniColorPrintCategories = this.filterUniColorCategories(clipartCategories)


        return this.uniColorPrintCategories

    },

    getCutCategories: function() {
        if (this.cutCategories) {
            return this.cutCategories

        }

        var clipartCategories = this.getViewModel().get('cutCategories')


        this.cutCategories = this.filterUniColorCategories(clipartCategories)


        return this.cutCategories

    },

    filterUniColorCategories: function(clipartCategories) {
        var uniColorCategories = []


        for (var i = 0
 i < clipartCategories.length; i++) {
            // Include if the category has atleast one uni-color clipart item.
            var clipartItems = clipartCategories[i].clipartItems,
                hasUniColorItems = false


            for (var j = 0
 j < clipartItems.length; j++) {
                if (clipartItems[j].uniColor) {
                    hasUniColorItems = true

                    break

                }
            }

            if (hasUniColorItems) {
                uniColorCategories.push({
                    categoryName: clipartCategories[i].categoryName
                })

            }
        }

        return uniColorCategories

    },

    getClipartTargetAreas: function(isProductDesigner) {
        var targetAreas = []

        var canvas = RolandKioskPrint.AppData.getCanvas()


        // Check if an edit area is explicity targeted by selection.
        var selectedObjects = canvas.getActiveObjects()


        targetAreas = selectedObjects.filter(function(object) {
            var editAreaType = object.editAreaType

            return (
                editAreaType == RolandKioskPrint.app.constants.EDIT_AREA_IMAGE ||
                editAreaType == RolandKioskPrint.app.constants.EDIT_AREA_FREE ||
                editAreaType == RolandKioskPrint.app.constants.EDIT_AREA_FOIL ||
                editAreaType == RolandKioskPrint.app.constants.EDIT_AREA_METAL||
                editAreaType == RolandKioskPrint.app.constants.EDIT_AREA_CUT
            )

        })


        if (targetAreas.length !== 0) {
            var canvasPanel = RolandKioskPrint.AppData.getCanvasPanel()

            canvasPanel.getController().sortObjects(targetAreas)
 // Arrange left top first.
            return targetAreas

        }

        if (isProductDesigner) {
            // For product designer, we otherwise return a list of all image and free areas.
            targetAreas = canvas.imageAreaList.concat(
                canvas.freeAreaList,
                canvas.foilAreaList,
                canvas.metalAreaList,
                canvas.cutAreaList
            )

        }

        return targetAreas

    },

    initialize: function() {
        // Populate the clipart categories.
        this.populateClipartCategories()

    },

    changeClipartColor: function(object, newColor) {
        var canvasPanel = RolandKioskPrint.AppData.getCanvasPanel()

        var canvasController = canvasPanel.getController()

        var getImageFilter = canvasController.getImageFilter

        var me = this


        canvasController.enumerateObjects(object, function(o) {
            var sharpenedColor

            if (o.fill) {
                if (o.fillSharpness === undefined) {
                    o.fillSharpness = canvasController.getColorSharpness(o.fill)

                }
                sharpenedColor = me.applySharpnessToColor(o.fill, newColor, o.fillSharpness, canvasController)

                o.set('fill', sharpenedColor)

            }
            if (o.stroke) {
                if (o.strokeSharpness === undefined) {
                    o.strokeSharpness = canvasController.getColorSharpness(o.stroke)

                }
                sharpenedColor = me.applySharpnessToColor(o.stroke, newColor, o.strokeSharpness, canvasController)

                o.set('stroke', sharpenedColor)

            }
            if (o.type == 'image') {
                var tintFilter = getImageFilter(o, 'Tint')

                if (!tintFilter) {
                    o.filters.push(new fabric.Image.filters.Tint({
                        convertToGrayscale: true,
                        color: newColor
                    }))

                } else {
                    tintFilter.color = newColor

                }

                o.applyFilters()

            }
            return true

        }, false, true)

    },

    populateClipartCategories: function() {
        var activePrintType = RolandKioskPrint.AppData.getActivePrintType(),
            data = this.getViewModel().getData(),
            categoriesList


        if (activePrintType == RolandKioskPrint.app.constants.PRINT_TYPE_CUT) {
            if (!data.cutCategories) {
                return
 // Cut clipart not yet retreived
            }

            categoriesList = this.getCutCategories()

        } else {
            if (!data.printCategories) {
                return
 // Print clipart not yet retreived
            }

            if (activePrintType == RolandKioskPrint.app.constants.PRINT_TYPE_FOIL) {
                categoriesList = this.getUniColorPrintCategories()

            } else {
                categoriesList = this.getPrintCategories()

            }
        }

        var cboCategories = this.getView().down('#cboCategories'),
            store = cboCategories.getStore()


        store.setData(categoriesList)


        // Set the default category.
        if (categoriesList.length > 0) {
            var categoryName = categoriesList[0].categoryName

            cboCategories.setValue(categoryName)


            this.refreshCliparts(categoryName)

        }
    },

    onBackgroundColorChanged: function(data) {
        // Check if we should respond.
        if (data.clientView != this.getView().clientView) {
            // Event fired by Client view and we are non-Client, or vice versa.
            return

        }

        // Need not do anything if not metal print.
        var productModelData = RolandKioskPrint.AppData.productModelData

        if (!productModelData.isMetalPrint()) {
            return

        }

        var newColor = data.color

        var appData = RolandKioskPrint.AppData

        var canvasController = appData.getCanvasPanel().getController()

        var canvas = appData.getCanvas()


        // Gather all clipart objects of multi-color type.
        // Unicolor ones are handled in the metal color panel.
        var objects = []

        canvas.getObjects().forEach(function(object) {
            canvasController.enumerateObjects(object, function(o) {
                if (o.get('printType') == RolandKioskPrint.app.constants.PRINT_TYPE_METAL &&
                    o.isPathGroup && !o.uniColor) {
                    objects.push(o)

                }
                return true

            })

        })


        if (!newColor) { // None color
            var productModel = RolandKioskPrint.AppData.productModelData

            newColor = productModel.materialColor

        }

        for (var i = 0, length = objects.length
 i < length; i++) {
           this.changeClipartColor(objects[i], newColor)

        }
        canvas.renderAll()

    },

    applySharpnessToColor: function(source, color, sharpness, canvasController) {
        var result

        if (source.toLive) {
            // Shading color.
            // We deep copy the gradient here as gradient.toObject (as on our undo stack) keeps
            // the same copy of the color stops. Any changes made to the color stops here, otherwise
            // impact the object on our undo stack.
            source = this.copyGradient(source)

            var colorStops = source.colorStops

            for (var i = 0
 i < colorStops.length; i++) {
                colorStops[i].color = canvasController.applySharpnessToColor(color, sharpness[i].color)

            }
            result = source

        } else {
            result = canvasController.applySharpnessToColor(color, sharpness)

        }
        return result

    },

    isReplaceableObject: function(object) {
        if (!object.editAreaId || object.isLocked) {
            return false

        }

        var type = object.get('type'),
            isImage = (type == 'image' || type == 'clippingGroup') && object.id != 'background',
            isCutLine = type != 'text' && type != 'curved-text' && object.isCutPath


        return object.isPathGroup || isImage || isCutLine

    },

    copyGradient: function(gradient) {
        var options = gradient.toObject()


        // Deep copy the color stops.
        options.colorStops = []


        gradient.colorStops.forEach(function(colorStop) {
            options.colorStops.push({
                offset: colorStop.offset,
                color: colorStop.color,
                opacity: colorStop.opacity
            })

        })


        return new fabric.Gradient(options)

    },

    addClipartToCanvas: function(clipartData, objectToReplace, editArea) {
        var appData = RolandKioskPrint.AppData,
            canvas = appData.getCanvas(),
            canvasPanel = appData.getCanvasPanel(),
            canvasPanelController = canvasPanel.getController(),
            isProductDesigner = appData.isProductDesigner(),
            me = this


        var deferred = new Ext.Deferred()


        fabric.loadSVGFromURL(clipartData.filePath, function(objects, options) {
            if (!objects || objects.length === 0) {
                deferred.reject()

                return

            }

            var group = fabric.util.groupSVGElements(objects, options)

            var isSameColor = group.isSameColor()


            group.set({
                'printType': RolandKioskPrint.AppData.getActivePrintType(),
                'uniColor': isSameColor
            })


            var productModel = appData.productModelData,
                backgroundColor = productModel.backgroundColor

            if (!backgroundColor) {
                backgroundColor = productModel.materialColor

            }

            if (isSameColor) {
                // When cloning a group with all paths having the same fill
                // and stroke color, fabric.js ends up applying none color to the
                // paths. Same issue is also seen during undo. We work around this
                // issue here, by setting the paths fill and stroke color on the path
                // group. This way, the paths color stays as is.
                var paths = group.getObjects()


                var firstPathFill = paths[0].get('fill') || ''

                var firstPathStroke = paths[0].get('stroke') || ''


                if (appData.isActivePrintTypeFoil()) {
                    var foilColor = RolandKioskPrint.AppData.getCurrentFoilColor()

                    firstPathFill = foilColor.value

                    firstPathStroke = firstPathStroke === '' ? firstPathStroke : foilColor.value

                } else if (appData.isActivePrintTypeMetal()) {
                    var fillSharpness = RolandKioskPrint.app.constants.METAL_FILL_SHARPNESS_DEFAULT

                    var metalColor = canvasPanelController.applySharpnessToColor(backgroundColor, fillSharpness)

                    firstPathFill = metalColor


                    // Apply outline if enabled by default.
                    firstPathStroke = ''

                    if (productModel.enableOutline) {
                        firstPathStroke = RolandKioskPrint.app.constants.METAL_OUTLINE_COLOR_DEFAULT

                        canvasPanelController.setDeviceStrokeWidth(group, RolandKioskPrint.app.constants.METAL_OUTLINE_STROKE_WIDTH)

                        group.set('isOutlinePath', true)

                    }

                    group.set('fillSharpness', fillSharpness)

                } else if (appData.isActivePrintTypeCut()) {
                    firstPathFill = ''

                    firstPathStroke = RolandKioskPrint.app.getCutViewingColor(productModel.cutMaterialColor)


                    group.set({
                        'isCutPath': true,
                        'objectCaching': false
                    })


                    canvasPanelController.enumerateObjects(group, function(o) {
                        var center = o.getCenterPoint()

                        o.set({
                            'strokeWidth': 0,
                            'deviceStroke': true,
                            'deviceStrokeWidth': RolandKioskPrint.app.constants.CUT_LINE_STROKE_WIDTH,
                            'perPixelTargetFind': true,
                            'targetFindTolerance': RolandKioskPrint.app.constants.CUT_LINE_HIT_TOLERANCE,
                            'isCutPath': true, // Custom property
                            'objectCaching': false
                        })

                        o.setPositionByOrigin(center, 'center', 'center')

                        return true

                    }, false, true)

                }

                if (typeof firstPathFill == 'string' &&
                    typeof firstPathStroke == 'string') {
                    group.set({
                        'fill': firstPathFill,
                        'stroke': firstPathStroke
                    })

                }
            } else if (appData.isActivePrintTypeMetal()) {
                me.changeClipartColor(group, backgroundColor)

            }

            var defaultSize = clipartData.defaultSizeCanvas

            var bounds = canvasPanelController.getProductBounds()


            // If an edit area is selected, add the clipart object to that area.
            if (editArea) {
                bounds = canvasPanelController.getBoundingRect(editArea)

                defaultSize = clipartData.defaultSizeEditArea

            }

            var imprintArea

            if (!editArea && RolandKioskPrint.AppData.isActivePrintTypeFoilOrMetal()) {
                // Set the clipart to foil imprint area.
                imprintArea = canvasPanelController.getImprintArea(appData.getActivePrintType())

                if (imprintArea) {
                    bounds = canvasPanelController.getBoundingRect(imprintArea)

                }
            }

            var position = {
                x: bounds.left,
                y: bounds.top
            }


            var scale = 1.0,
                scaleX = 1.0,
                scaleY = 1.0


            // Compute the object size preserving the aspect ratio.
            // Clipart size is "30% of canvas" or "30% of edit area".
            if (defaultSize == 1) {
                scaleX = (bounds.width / group.width) * 0.3

                scaleY = (bounds.height / group.height) * 0.3

                if (scaleX < scaleY)
                    scale = scaleX

                else
                    scale = scaleY


                position.y += (bounds.height - scale * group.height) / 2

                position.x += (bounds.width - scale * group.width) / 2

            }
            // Clipart size is "50% of canvas" or "50% of edit area".
            else if (defaultSize == 2) {
                scaleX = (bounds.width / group.width) * 0.5

                scaleY = (bounds.height / group.height) * 0.5

                if (scaleX < scaleY)
                    scale = scaleX

                else
                    scale = scaleY


                position.y += (bounds.height - scale * group.height) / 2

                position.x += (bounds.width - scale * group.width) / 2

            }
            // Clipart size is "Original Size".
            else if (defaultSize == 3) {
                var svgDoc = me.getSVGDocument(clipartData.filePath)


                // Read in the width, height, and viewbox to establish the
                // svg coordinate space.
                var viewBox


                var svgElem = svgDoc.documentElement

                if (svgElem.hasAttribute('viewBox')) {
                    var viewBoxAttr = svgElem.getAttribute('viewBox')

                    viewBox = viewBoxAttr.split(' ').map(function(v) {
                        return Number(v)

                    })

                } else {
                    return false
 // viewBox is required
                }

                var svgWidth, svgHeight

                var widthUnits = 'px'

                var heightUnits = 'px'


                var expr  = /(\d*\.?\d*)(.*)/


                if (svgElem.hasAttribute('width')) {
                    var widthAttr = svgElem.getAttribute('width')

                    var widthAttrSplit = widthAttr.match(expr)


                    // match(expr) yields ['11.1px', '11.1', 'px'] for '11.1px'
                    svgWidth = Number(widthAttrSplit[1])

                    widthUnits = widthAttrSplit[2]


                    if (widthUnits === 'pc')
                        widthUnits = 'pc96'

                    if (widthUnits === '')
                        widthUnits = 'px96'

                } else {
                    svgWidth = viewBox[2]

                }

                if (svgElem.hasAttribute('height')) {
                    var heightAttr = svgElem.getAttribute('height')

                    var heightAttrSplit = heightAttr.match(expr)


                    svgHeight = Number(heightAttrSplit[1])

                    heightUnits = heightAttrSplit[2]


                    if (heightUnits === 'pc')
                        heightUnits = 'pc96'

                    if (heightUnits === '')
                        heightUnits = 'px96'

                } else {
                    svgHeight = viewBox[3]

                }
                var groupWidth = RolandKioskPrint.app.convertUnitsValueToMM(svgWidth, widthUnits)

                var groupHeight = RolandKioskPrint.app.convertUnitsValueToMM(svgHeight, heightUnits)


                scaleX = groupWidth / group.width

                scaleY = groupHeight / group.height


                if (scaleX < scaleY)
                    scale = scaleX

                else
                    scale = scaleY


                position.y += (bounds.height - scale * group.height) / 2

                position.x += (bounds.width - scale * group.width) / 2

            }
            // Clipart size is "Fit".
            else {
                scaleX = bounds.width / group.width

                scaleY = bounds.height / group.height

                if (scaleX < scaleY) {
                    scale = scaleX

                    position.y += (bounds.height - scale * group.height) / 2

                } else {
                    scale = scaleY

                    position.x += (bounds.width - scale * group.width) / 2

                }
            }

            group.scale(scale, scale)


            var sourceType = (
                isProductDesigner ? RolandKioskPrint.app.constants.OBJECT_SOURCE_PD
                : RolandKioskPrint.app.constants.OBJECT_SOURCE_PMD
            )


            group.set({
                left: position.x,
                top: position.y,
                sourceType: sourceType
            })


            if (objectToReplace) {
                canvasPanelController.replaceObject(objectToReplace, group)

            } else if (editArea) {
                canvasPanelController.addObjectToEditArea(group, editArea)

            } else {
                canvas.add(group)

            }
            canvas.setActiveObject(group)

            canvas.renderAll()

            deferred.resolve()

        })


        return deferred.promise

    },

    getSVGDocument: function(svgPath) {
        var svgStr

        Ext.Ajax.request({
            url: svgPath,
            async: false,
            success: function (response, options) {
                svgStr = response.responseText

            }
        })


        var svgDoc


        if (!svgStr || typeof svgStr !== 'string') {
            return false

        }

        // Parse the svg data, treating as generic xml.
        try {
            var parser = new DOMParser()

            svgDoc = parser.parseFromString(svgStr, "text/xml")

        } catch(e) {
            svgDoc = undefined

        }

        // Error handling for any parsing errors.
        if (!svgDoc || !svgDoc.documentElement ||
            svgDoc.getElementsByTagName('parsererror').length) {
            return false

        }

        return svgDoc

    },

    onCboCategoriesChange: function(field, newValue, oldValue, eOpts) {
        this.refreshCliparts(newValue)

    },

    onClipartViewItemClick: function(dataview, record, item, index, e, eOpts) {
        var canvas = RolandKioskPrint.AppData.getCanvas()


        // In product designer, clipart can be added only to image or free edit areas.
        var isProductDesigner = RolandKioskPrint.AppData.isProductDesigner()


        var editArea

        var targetAreas = this.getClipartTargetAreas(isProductDesigner)

        if (targetAreas.length !== 0) {
            // For product model designer, this picks the selected edit area.
            // For product designer, this would pick up the selected or first available area.
            editArea = targetAreas[0]

        }

        if (isProductDesigner && !editArea && canvas.textAreaList.length !== 0) {
            // If product designer, and we only have text areas, we can't place clipart.
            return

        }

        var canvasPanel = RolandKioskPrint.AppData.getCanvasPanel(),
            canvasPanelController = canvasPanel.getController()


        var activeObjects = canvas.getActiveObjects(),
            objectToReplace


        if (isProductDesigner && activeObjects.length == 1 && this.isReplaceableObject(activeObjects[0])) {
            objectToReplace = activeObjects[0]

        }

        if (!objectToReplace && !canvasPanelController.canAddObject()) {
            // Check if we have reached the maximum limit on number of objects.
            return

        }

        // Exit clip mode if active.
        canvasPanelController.endClipping()


        var me = this


        var view = canvasPanelController.getView()

        view.getEl().mask(RolandKioskPrint.app.getString('message.designer.addingClipart'))


        setTimeout(function() {
            var promise = me.addClipartToCanvas(record.data, objectToReplace, editArea)

            promise.then(function() {
                view.getEl().unmask()

            }, function() {
                Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                RolandKioskPrint.app.getString('message.designer.addingClipartFailed'))

                view.getEl().unmask()

            })

        }, 10)

    },

    onPanelBeforeRender: function(component, eOpts) {
        // Get the list of clipart, both for print and for cut, and populate the controls.
        // Right now, we are using a flat model in ClipartCategory, the 'hasMany' association
        // does not compile on Architect 4.0. We populate the flat model stores ourselves from
        // the incoming JSON data.

        Ext.Ajax.request({
            scope: this,
            url: '/cotodesign/resources/clipart',
            success: function(response, opts) {
                var categoriesData = Ext.decode(response.responseText)

                if (!categoriesData) {
                    return

                }

                // Stash in the view model.
                this.getViewModel().set({
                    'printCategories': categoriesData.clipartCategories
                })


                this.populateClipartCategories()

            },
            failure: function() {
            }
        })


        Ext.Ajax.request({
            scope: this,
            url: '/cotodesign/resources/clipart-cut',
            success: function(response, opts) {
                var categoriesData = Ext.decode(response.responseText)

                if (!categoriesData) {
                    return

                }

                // Stash in the view model.
                this.getViewModel().set({
                    'cutCategories': categoriesData.clipartCategories
                })


                this.populateClipartCategories()

            },
            failure: function() {
            }
        })

    },

    onPanelShow: function(component, eOpts) {
        // In product designer, if the product model contains edit areas, clipart can
        // be added only to image or free edit areas. Select the target edit area, if
        // none is already targeted.
        var isProductDesigner =
        (RolandKioskPrint.AppData.appMode == RolandKioskPrint.app.constants.APP_MODE_PRODUCT_DESIGNER)

        if (!isProductDesigner) {
            return

        }

        // Can the selected object be replaced?
        var canvas =  RolandKioskPrint.AppData.getCanvas()

        var activeObjects = canvas.getActiveObjects()

        if (activeObjects.length == 1 && this.isReplaceableObject(activeObjects[0])) {
            return

        }

        var targetAreas = this.getClipartTargetAreas(true)

        if (targetAreas.length !== 0) {
            var canvas = RolandKioskPrint.AppData.getCanvas()

            // For product designer, this would pick up the selected or first available area.
            if (targetAreas[0] != canvas.getActiveObject()) {
                canvas.setActiveObject(targetAreas[0])

                canvas.renderAll()

            }
        }
    }

})

