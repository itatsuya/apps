/*
 * File: app/view/panel/BackgroundPanelViewController.js
 *
 * This file was generated by Sencha Architect version 4.2.4.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 6.6.x Classic library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 6.6.x Classic. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RolandKioskPrint.view.panel.BackgroundPanelViewController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.panel.backgroundpanel',

    listen: {
        controller: {
            'panel.undoredopanel': {
                undoRedoChanged: 'onUndoRedoChange'
            },
            designer: {
                designerClosed: 'onDesignerClosed'
            }
        }
    },

    updatePanel: function() {
        // Deselect color view selection.
        var colorView = this.getView().down('#colorView');
        colorView.getSelectionModel().deselectAll();

        // Find the fill color applied to the background color object.
        var colorObject = this.getBackgroundObject('rect');
        if (colorObject) {
            var colorValue = colorObject.get('fill');

            if (colorValue === '') {
                colorValue = 'None';
            }

            var record = colorView.getStore().findRecord('colorValue', colorValue);
            if (record) {
                colorView.select(record, false, true);
            }
        }

        // Update the show grid checkbox state based on whether background
        // grid is currently shown or not.
        this.suppressEvents = true;
        var chkUserShowGrid = this.getView().down('#chkUserShowGrid');
        var lblBackgroundGrid = this.getView().down('#lblBackgroundGrid');
        var backgroundGrid = this.getBackgroundObject('grid');

        if (backgroundGrid) {
            chkUserShowGrid.setValue(true);
            lblBackgroundGrid.show();
        } else {
            chkUserShowGrid.setValue(false);
            lblBackgroundGrid.hide();
        }

        this.suppressEvents = false;
    },

    refreshImageList: function() {
        var imgView = this.getView().down('#imgView');
        var url;

        if (RolandKioskPrint.AppData.isProductModelDesigner()) {
            url = RolandKioskPrint.app.constants.PRODUCT_MODEL_BG_IMAGE_LIST_URL;
        } else {
            url = RolandKioskPrint.app.constants.END_USER_BG_IMAGE_LIST_URL;
        }

        imgView.mask(RolandKioskPrint.app.getString('message.designer.refreshingBGImageList'));

        Ext.Ajax.request({
            url: url,
            scope: this,
            success: function(response, opts){
                imgView.unmask();
                var imageList = Ext.decode(response.responseText);

                if (imageList.images && imageList.images.length > 0) {
                    imgView.store.setData(imageList.images);
                } else {
                    imgView.store.setData([{
                        fileName: '',
                        filePath: '',
                        thumbPath: ''
                    }]); // Set dummy data
                }
                imgView.refresh();
            },
            failure: function(response, opts) {
                imgView.unmask();
                Ext.toast(RolandKioskPrint.app.getString('message.designer.backgroundImageRefreshFailed'));
            }
        });
    },

    updateBackgroundObjects: function(panelShown) {
        var appData = RolandKioskPrint.AppData;
        var canvas = appData.getCanvas();

        var objects = canvas.getObjects();
        var activeObjects = canvas.getActiveObjects();
        var sourceType =
            appData.isProductDesigner() ? RolandKioskPrint.app.constants.OBJECT_SOURCE_PD
                                        : RolandKioskPrint.app.constants.OBJECT_SOURCE_PMD;
        var objectSelection = false;

        function enableObject(object, enable) {
            // Set the object not selectable if the panel is hidden.
            object.set({
                evented: enable,
                selectable: enable
            });

            // Check if object is selected.
            if (!enable && activeObjects.length !== 0) {
                var index = activeObjects.indexOf(object);
                if (index != -1) {
                    activeObjects.splice(index, 1);
                    objectSelection = true;
                }
            }
        }

        var isProductModelDesigner = appData.isProductModelDesigner();

        for (var i = 0, length = objects.length; i < length; i++) {
            var object = objects[i],
                type = object.get('type');

            if (object.get('sourceType') == sourceType) {
                if (object.get('id') == 'background' &&
                    (type == 'image' || type == 'group' || type == 'clippingGroup')) {
                    enableObject(object, panelShown);
                } else if (isProductModelDesigner &&
                           (type == 'foil-imprint-area' || type == 'metal-imprint-area')){
                    enableObject(object, !panelShown);
                }
            }
        }

        if (objectSelection) {
            // Remove from selection.
            canvas.discardActiveObject();

            if (activeObjects.length == 1) {
                canvas.setActiveObject(activeObjects[0]);
            } else if (activeObjects.length > 1) {
                var selectionGroup = new fabric.ActiveSelection(activeObjects, {
                    canvas: canvas
                });
                canvas.setActiveObject(selectionGroup);
            }
        }

        // Update the undo redo stacks.
        var undoRedoPanel = appData.getUndoRedoPanel();
        undoRedoPanel.getController().enumerateObjects({
                id: 'background',
                type: ['image', 'clippingGroup', 'group'],
                sourceType: sourceType
            }, function(object) {
                object.evented = panelShown;
                object.selectable = panelShown;
            });

        // Update the imprint area.
        if (isProductModelDesigner &&
            appData.isActivePrintTypeFoilOrMetal()) {
            undoRedoPanel.getController().enumerateObjects({
                type: ['foil-imprint-area', 'metal-imprint-area']
            }, function(object) {
                object.evented = !panelShown;
                object.selectable = !panelShown;
            });
        }

        canvas.renderAll();
    },

    refreshImageView: function() {
        var imgView = this.getView().down('#imgView');
        imgView.refresh();
    },

    onUndoRedoChange: function() {
        if (this.getView().isVisible()) {
            this.updatePanel();
        }

        // Update the product model level background color value.
        var colorValue = '';
        var colorObject = this.getBackgroundObject('rect');
        if (colorObject) {
            colorValue = colorObject.get('fill');
        }

        var productModel = RolandKioskPrint.AppData.productModelData;
        productModel.backgroundColor = colorValue;
    },

    setBackgroundData: function(backgroundData) {
        this.getViewModel().setData(backgroundData); // Set the view model data

        // Register for custom canvas ready notification, if
        // we haven't already. We do not un-register these.
        if (!this.onCanvasStateChange) {
            var canvas = RolandKioskPrint.AppData.getCanvas();
            var me = this;

            this.onCanvasStateChange = {
                'canvas:x-ready': function() {
                    var needToRedraw = false;

                    // Get the background color object.
                    // The product model dimensions may have changed since the time the object was created.
                    // Resize if required.
                    var colorObject = me.getBackgroundObject('rect');
                    if (colorObject) {
                        needToRedraw = me.resizeBackgroundToModel(colorObject);
                    }

                    var gridObject = me.getBackgroundObject('grid');
                    if (gridObject) {
                        needToRedraw = me.resizeBackgroundToModel(gridObject);
                    }

                    // For metal print, we may need to:
                    // 1. Create the material color background the first time through, or
                    // 2. The background color may have changed because of a change in marking
                    // material, and we may need to recolor.
                    var productModelData = RolandKioskPrint.AppData.productModelData;
                    if (productModelData.isMetalPrint()) {
                        // First time through, create the background color.
                        if (!colorObject) {
                            // Set the material color as background color.
                            me.setBackgroundColor(productModelData.materialColor, true);
                            needToRedraw = true;
                        } else {
                            // If the material has changed since the last time, check if background
                            // color was overridden by the user. If not, we change the background color here.
                            var backgroundColor = colorObject.get('fill');
                            if (productModelData.oldMaterial != productModelData.material &&
                                productModelData.oldMaterialColor == backgroundColor) {
                                me.setBackgroundColor(productModelData.materialColor, true);
                                needToRedraw = true;
                            } else {
                                // Set the background color in the product model.
                                productModelData.backgroundColor = backgroundColor;
                            }
                        }
                    }

                    if (needToRedraw) {
                        canvas.renderAll();
                    }
                }
            };
            canvas.on(this.onCanvasStateChange);
        }
    },

    getBackgroundData: function() {
        return this.getViewModel().getData();
    },

    getBackgroundObject: function(type) {
        var canvas = RolandKioskPrint.AppData.getCanvas();
        var objects = canvas.getObjects();

        for (var i = 0, length = objects.length; i < length; ++i) {
            var object = objects[i];

            if (object.get('id') == 'background' &&
                object.get('type') == type) {
                return object;
            }
        }
    },

    setBackgroundColor: function(colorValue, suppressNotify, shouldRender) {
        var canvas = RolandKioskPrint.AppData.getCanvas();

        var colorObject = this.getBackgroundObject('rect');
        if (colorValue == 'None') {
            colorValue = '';
        }

        // Suppress undo redo handling, as several operations may be involved, for example
        // those in the event listeners. We notify once everything is done.
        var undoRedoPanel = RolandKioskPrint.AppData.getUndoRedoPanel();
        undoRedoPanel.getController().mute();

        if (!colorObject) {
            var canvasPanel = RolandKioskPrint.AppData.getCanvasPanel();
            var canvasController = canvasPanel.getController();
            var productSize = canvasController.getProductSizeData();
            colorObject = new fabric.Rect({
                id: 'background',
                left: 0,
                top: 0,
                width: productSize.widthMM,
                height: productSize.heightMM,
                fill: colorValue,
                stroke: false,
                strokeWidth: 0,
                skipDrawing: true,
                selectable: false,
                sourceType: RolandKioskPrint.app.constants.OBJECT_SOURCE_PMD,
                evented: false
            });
            canvas.insertAt(colorObject, canvasController.getBGColorObjectIndex());
        } else {
            colorObject.set('fill', colorValue);
        }

        // Set the background color in the product model.
        var productModelData = RolandKioskPrint.AppData.productModelData;
        productModelData.backgroundColor = colorValue;

        // Notify background change.
        this.fireEvent('backgroundColorChanged', {
            color: colorValue,
            clientView: this.getView().clientView
        });

        // Restore undo redo handling.
        undoRedoPanel.getController().unmute();

        // Notify for undo/redo.
        if (!suppressNotify) {
            canvas.fire('object:modified', {target : colorObject});
        }

        if (shouldRender) {
            canvas.renderAll();
        }
    },

    onDesignerClosed: function() {
        RolandKioskPrint.app.setBackgroundFirstUseShown(false, true);
    },

    resizeBackgroundToModel: function(backgroundObject) {
        var canvasPanel = RolandKioskPrint.AppData.getCanvasPanel(),
            canvasController = canvasPanel.getController(),
            productSize = canvasController.getProductSizeData();

        if (backgroundObject.width != productSize.widthMM || backgroundObject.height != productSize.heightMM) {
            backgroundObject.set({
                width: productSize.widthMM,
                height: productSize.heightMM
            });

            return true;
        }
        return false;
    },

    onChkUserShowGridChange: function(field, newValue, oldValue, eOpts) {
        if (this.suppressEvents) {
            return;
        }

        var canvas = RolandKioskPrint.AppData.getCanvas();
        var backgroundGrid = this.getBackgroundObject('grid');

        if (newValue && !backgroundGrid) {
            var canvasController = RolandKioskPrint.AppData.getCanvasPanel().getController();

            var productSize = canvasController.getProductSizeData();
            backgroundGrid = new fabric.Grid({
                id: 'background',
                left: 0,
                top: 0,
                width: productSize.widthMM,
                height: productSize.heightMM,
                selectable: false,
                evented: false,
                skipDrawing: true,
                sourceType: RolandKioskPrint.app.constants.OBJECT_SOURCE_PMD
            });

            // Add above the background color, but beneath any background images.
            var index;
            var colorObject = this.getBackgroundObject('rect');

            if (colorObject) {
                index = canvas.getObjects().indexOf(colorObject) + 1;
            } else {
                index = canvasController.getBGColorObjectIndex();
            }

            canvas.insertAt(backgroundGrid, index);
            canvas.renderAll();
        } else if (!newValue) {
            if (backgroundGrid) {
                canvas.remove(backgroundGrid);
            }
        }

        var lblBackgroundGrid = this.getView().down('#lblBackgroundGrid');
        lblBackgroundGrid.setVisible(newValue);
    },

    onChkUserShowGridDisable: function(component, eOpts) {
        if (component.checked) {
            component.setValue(false);
        }
    },

    onUploadButtonClick: function(button, e, eOpts) {
        var imageUploadData = {
            'imgPanelView': this.getView(),
            'screenType': 'uploadMethodSelection',
            'backgroundImage': true
        };

        var widget;
        if (RolandKioskPrint.AppData.isProductModelDesigner()) {
            widget = Ext.widget('productmodeldesignerimageupload');
        } else {
            widget = Ext.widget({
                xtype: 'productdesignerimageupload',
                clientView: true
            });
        }

        widget.getViewModel().setData(imageUploadData);

        if (!window.isAgreedBackgroudImageUploadDisclaimer) {
            RolandKioskPrint.app.showImageUploadDisclaimer().then(function(dontShowAgain) {
                window.isAgreedBackgroudImageUploadDisclaimer = dontShowAgain;
                RolandKioskPrint.app.showModalView(widget);
            });
        } else {
            RolandKioskPrint.app.showModalView(widget);
        }
    },

    onRefreshButtonClick: function(button, e, eOpts) {
        this.refreshImageList();
    },

    onImgViewItemClick: function(dataview, record, item, index, e, eOpts) {
        var canvas = RolandKioskPrint.AppData.getCanvas();
        var canvasPanel = RolandKioskPrint.AppData.getCanvasPanel();
        var canvasController = canvasPanel.getController();
        var productSize = canvasController.getProductSizeData();

        var imagePath = RolandKioskPrint.AppData.getURLWithNonce(record.data.thumbPath);
        var me = this;

        fabric.Image.fromURL(imagePath, function(img) {
            var scaleX = productSize.widthMM / img.width;
            var scaleY = productSize.heightMM / img.height;
            var left = 0, top = 0;

            if (scaleX > scaleY) {
                scale = scaleX;
                top = (productSize.heightMM - (img.height * scale)) / 2;
            } else {
                scale = scaleY;
                left = (productSize.widthMM - (img.width * scale)) / 2;
            }

            var isProductDesigner = RolandKioskPrint.AppData.isProductDesigner();
            var sourceType = (isProductDesigner) ? RolandKioskPrint.app.constants.OBJECT_SOURCE_PD
            : RolandKioskPrint.app.constants.OBJECT_SOURCE_PMD;
            img.set({
                id: 'background',
                left: left,
                top: top,
                skipDrawing: true,
                sourceType: sourceType
            }).scale(scale);

            canvas.insertAt(img, canvasController.getNextBGObjectIndex());
            canvas.setActiveObject(img);

            canvas.renderAll();
        });
    },

    onColorViewContainerClick: function(dataview, e, eOpts) {
        return false;
    },

    onColorViewItemClick: function(dataview, record, item, index, e, eOpts) {
        this.setBackgroundColor(record.data.colorValue, false, true);
    },

    onBackToDefaultButtonClick: function(button, e, eOpts) {
        var productModelData = RolandKioskPrint.AppData.productModelData;

        // Restore background to material color.
        if (productModelData.isMetalPrint()) {
            this.setBackgroundColor(productModelData.materialColor, false, true);
        }
    },

    onPanelAfterRender: function(component, eOpts) {
        this.refreshImageList();

        // For hiding color tab.
        var uiSettings = RolandKioskPrint.AppData.getUiSettingsData();
        if (uiSettings.hideBackgroundColorPalette) {
            this.getView().down('#colorTab').hide();
        }
    },

    onPanelShow: function(component, eOpts) {
        this.updatePanel();

        // Show/hide the restore color button.
        var btnBackToDefault = this.getView().down('#btnBackToDefault');
        var productModelData = RolandKioskPrint.AppData.productModelData;
        btnBackToDefault.setVisible(productModelData.isMetalPrint());

        this.updateBackgroundObjects(true);

        this.refreshImageList();

        // Show the first use dialog, if not already shown.
        var backgroundFirstUseShown = RolandKioskPrint.app.getBackgroundFirstUseShown();
        if (!backgroundFirstUseShown) {
            Ext.Msg.show({
                title: RolandKioskPrint.app.getString('message.generic.information'),
                msg: RolandKioskPrint.app.getString('message.designer.backgroundInfo'),
                buttonText: {
                    ok: RolandKioskPrint.app.getString('label.button.close')
                },
                icon: Ext.MessageBox.INFO
            });
            RolandKioskPrint.app.setBackgroundFirstUseShown(true);
        }
    },

    onPanelHide: function(component, eOpts) {
        this.updateBackgroundObjects(false);
    }

});
