/*
 * File: app/view/panel/UndoRedoPanelViewController.js
 *
 * This file was generated by Sencha Architect version 4.2.4.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 6.6.x Classic library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 6.6.x Classic. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RolandKioskPrint.view.panel.UndoRedoPanelViewController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.panel.undoredopanel',

    saveCurrentState: function() {
        if (!this.undoStack) {
            this.initializeUndoStack();
        }
        var appData = RolandKioskPrint.AppData,
            canvas = appData.getCanvas(),
            canvasPanel = appData.getCanvasPanel(),
            productModel = appData.productModelData;

        // Get JSON representation for all foreground objects and store.
        var fgObjects = [];

        var origIncludeDefaults = canvas.includeDefaultValues;
        canvas.includeDefaultValues = true;

        var propertiesToInclude = [
            'id',
            'selectable',
            'evented',
            'isCutPath',
            'specialColor',
            'textureType',
            'noColor',
            'editAreaType',
            'editAreaId',
            'perPixelTargetFind',
            'targetFindTolerance',
            'objectCaching',
            'sourceType',
            'savedTextValue',
            'skipDrawing',
            'isLocked',
            'origWidth',
            'origHeight',
            'isLowRes',
            'printType',
            'uniColor',
            'fillSharpness',
            'strokeSharpness',
            'isOutlinePath',
            'startScaleX',
            'startScaleY'
        ];

        // Add the extra properties to support editable templates.
        if (appData.isProductDesigner()) {
            propertiesToInclude.push(
                'effectiveWidth',
                'effectiveHeight',
                'effectiveCenterPoint'
            );

            if (appData.isActivePrintTypeColor()) {
                propertiesToInclude.push(
                    'fillOrig',
                    'strokeOrig'
                );
            } else if (appData.isActivePrintTypeMetal()) {
                propertiesToInclude.push(
                    'fillSharpnessOrig',
                    'isOutlinePathOrig'
                );
            }
        }

        var objects = canvas.getObjects();
        for (var i = canvas.lowestFgObjectIndex, length = objects.length; i < length; i++) {
            var object = objects[i];

            // We need to set clipTo to null since it does not round-trip
            // well through JSON - the mechanism used by undo/redo.
            object.clipTo = null;

            // If the object is part of the current selection group, it needs to
            // be transformed appropriately, i.e. it should be serialized as it would
            // appear if the selection group were to be destroyed.
            var originalProperties = canvas._realizeGroupTransformOnObject(object);

            var json = object.toObject(propertiesToInclude);
            fgObjects.push(json);

            // Undo the damage we did by changing object properties.
            canvas._unwindGroupTransformOnObject(object, originalProperties);

            if (object.editAreaId) {
                canvasPanel.getController().setClipToEditArea(object);
            }
        }
        canvas.includeDefaultValues = origIncludeDefaults;

        var state = {
            objects: fgObjects
        };

        if (productModel.isFoilPrint()) {
            var foilColor = RolandKioskPrint.AppData.getCurrentFoilColor();
            state.foilColorName = foilColor.name;
            state.foilColorValue = foilColor.value;
        }

        var colorData = RolandKioskPrint.AppData.getVarnishSettings();
        state.varnishSettings = colorData.varnishSettings;

        // Add the new state just after the current step.
        if (this.currentStep < this.undoStack.length - 1) {
            this.undoStack.splice(this.currentStep + 1);
        }

        this.undoStack.push(state);
        this.currentStep++;

        if (this.undoStack.length > RolandKioskPrint.app.constants.MAX_UNDO_STEP_COUNT + 1) {
            this.undoStack.shift(); // Pop out the starting step
            this.currentStep--;
        }

        this.updatePanel();
    },

    parentShown: function() {
        // Update the panel.
        this.updatePanel();
    },

    updatePanel: function() {
        var canUndo = false,
            canRedo = false;

        var cropMode = RolandKioskPrint.AppData.getCropMode();

        if (!cropMode) {
            if (this.undoStack && this.undoStack.length > 0) {
                canUndo = (this.currentStep > 0);
                canRedo = (this.currentStep < this.undoStack.length - 1);
            }
        }

        // Doing away with view-model bindings.
        // These were not functioning correctly with ExtJS 6.6
        // Now enabling/disabling buttons directly.

        this.getView().down('#btnUndo').setDisabled(!canUndo);
        this.getView().down('#btnRedo').setDisabled(!canRedo);
    },

    loadCurrentState: function() {
        var deferred = new Ext.Deferred();
        if (this.currentStep >= 0 && this.currentStep < this.undoStack.length) {
            // Disable undo/redo until we finish the handling.
            this.getViewModel().setData({
                'canUndo': false,
                'canRedo': false
            });

            var canvas = RolandKioskPrint.AppData.getCanvas();
            var canvasPanel = RolandKioskPrint.AppData.getCanvasPanel();
            var productModel = RolandKioskPrint.AppData.productModelData;
            var canvasPanelController = canvasPanel.getController();
            canvas.renderOnAddRemove = false;
            canvas.loadingUndoRedoState = true;

            // Suppress object change event handling during this time.
            this.mute();

            // Do away with the selection, as the current set of objects are going away.
            // New set of objects come in.
            canvas.discardActiveObject();

            // Remove all foreground objects.
            canvas.removeStartingAt(canvas.lowestFgObjectIndex);

            // Load objects from current state.
            var state = this.undoStack[this.currentStep];
            var me = this;
            var transformViewPort = false;

            var isProductDesigner =
                (RolandKioskPrint.AppData.appMode == RolandKioskPrint.app.constants.APP_MODE_PRODUCT_DESIGNER);

            if (isProductDesigner) {
                canvas.imageAreaList = [];
                canvas.textAreaList = [];
                canvas.freeAreaList = [];
                canvas.foilAreaList = [];
                canvas.metalAreaList = [];
                canvas.cutAreaList = [];
            }

            // Why do we serialize the state first?
            // In its Group.fromObject, fabric has this code to delete the group objects.
            // This results in objects being deleted from our undo stack state. We stringize
            // the state, so that fabric gets a copy of the state to work with.
            canvas.loadFromJSON(
                Ext.util.JSON.encode(state),
                true,
                function() { // callback
                    // Sort the edit areas left top first.
                    if (isProductDesigner) {
                        canvasPanelController.sortObjects(canvas.imageAreaList);
                        canvasPanelController.sortObjects(canvas.textAreaList);
                        canvasPanelController.sortObjects(canvas.freeAreaList);
                        canvasPanelController.sortObjects(canvas.foilAreaList);
                        canvasPanelController.sortObjects(canvas.metalAreaList);
                        canvasPanelController.sortObjects(canvas.cutAreaList);
                    }

                    // Done loading state. Notify changes.
                    if (productModel.isFoilPrint()) {
                        RolandKioskPrint.AppData.setCurrentFoilColor({
                            'name': state.foilColorName,
                            'value': state.foilColorValue
                        });

                        me.fireEvent('foilColorChanged');
                    }

                    RolandKioskPrint.AppData.setVarnishSettings(state.varnishSettings);
                    me.fireEvent('undoRedoChanged');

                    canvas.loadingUndoRedoState = false;

                    canvas.renderOnAddRemove = true;
                    canvas.renderAll();

                    me.updatePanel();
                    me.unmute();

                    if (transformViewPort) {
                        canvasPanelController.transformCanvasViewport();
                    }

                    deferred.resolve();
                },
                function(o, object, index) { // reviver
                    if (object.editAreaType && (isProductDesigner ||
                                               object.sourceType == RolandKioskPrint.app.constants.OBJECT_SOURCE_SVG)) {
                        // Set properties not serialized to json.
                        object.set({
                            'lockMovementX': true,
                            'lockMovementY': true,
                            'lockScalingX': true,
                            'lockScalingY': true,
                            'lockRotation': true,
                            'hasControls': false,
                            'hasRotatingPoint': false,
                            'borderScaleFactor': 3 // 3px selection border
                        });
                        if (isProductDesigner) {
                            switch (object.editAreaType) {
                                case RolandKioskPrint.app.constants.EDIT_AREA_IMAGE:
                                    canvas.imageAreaList.push(object);
                                    break;
                                case RolandKioskPrint.app.constants.EDIT_AREA_TEXT:
                                    canvas.textAreaList.push(object);
                                    break;
                                case RolandKioskPrint.app.constants.EDIT_AREA_FOIL:
                                    canvas.foilAreaList.push(object);
                                    break;
                                case RolandKioskPrint.app.constants.EDIT_AREA_METAL:
                                    canvas.metalAreaList.push(object);
                                    break;
                                case RolandKioskPrint.app.constants.EDIT_AREA_CUT:
                                    canvas.cutAreaList.push(object);
                                    break;
                                default:
                                    canvas.freeAreaList.push(object);
                                    break;
                            }
                        }
                    } else {
                        if (RolandKioskPrint.AppData.isImprintArea(object)) {
                            object.on('mouseup', canvasPanelController.transformCanvasViewport.bind(canvasPanelController));
                            transformViewPort = true;
                        }
                    }

                    if (object.editAreaId) {
                        canvasPanel.getController().setClipToEditArea(object);
                    }

                    if (object.isLocked) {
                        canvasPanel.getController().setLockedProperties(object);
                    }
                }
            );
        } else {
            this.updatePanel();
            deferred.resolve();
        }
        return deferred.promise;
    },

    onObjectAdded: function(object) {
        if (this.suppressObjectChangeHandling) {
            return;
        }

        //console.log('object:added');
        this.saveCurrentState();
    },

    onObjectModified: function(object) {
        if (this.suppressObjectChangeHandling) {
            return;
        }

        //console.log('object:modified');
        this.saveCurrentState();
    },

    enumerateObjects: function(filter, callback) {
        var stack = this.undoStack;

        // For all states.
        stack.forEach(function(state) {
            // For all objects in state.
            for(var i = 0, length = state.objects.length; i < length; i++) {
                var object = state.objects[i];

                var match = true;
                for (var prop in filter) {
                    if (Array.isArray(filter[prop])) {
                        if (filter[prop].indexOf(object[prop]) == -1) {
                            match = false;
                            break;
                        }
                    } else {
                        if (filter[prop] !== object[prop]) {
                            match = false;
                            break;
                        }
                    }
                }

                if (match) {
                    callback(object);
                }
            }
        });
    },

    onObjectRemoved: function(object) {
        if (this.suppressObjectChangeHandling) {
            return;
        }

        //console.log('object:removed');
        this.saveCurrentState();
    },

    initializeUndoStack: function() {
        this.undoStack = [];
        this.currentStep = -1;
    },

    isStackDirty: function() {
        return (this.undoStack && this.undoStack.length > 1);
    },

    onCanvasReady: function() {
        // Canvas is ready, we now register for object change notifications.
        var canvas = RolandKioskPrint.AppData.getCanvas();
        var me = this;

        if (!this.onObjectChange) {
            this.onObjectChange = {
                'object:added': function(e) {
                    me.onObjectAdded(e.target);
                },
                'object:modified': function(e) {
                    me.onObjectModified(e.target);
                },
                'object:removed': function(e) {
                    me.onObjectRemoved(e.target);
                }
            };
        }
        canvas.on(this.onObjectChange);

        this.saveCurrentState(); // Save the current state
    },

    onCanvasFinish: function() {
        // Unregister for object change notifications.
        if (this.onObjectChange) {
            var canvas = RolandKioskPrint.AppData.getCanvas();
            canvas.off(this.onObjectChange);
        }

        this.initializeUndoStack();
    },

    parentBeforeShow: function() {
        // Register for custom canvas ready and finish notifications, if
        // we haven't already. We do not un-register these.
        if (!this.onCanvasStateChange) {
            var canvas = RolandKioskPrint.AppData.getCanvas();
            var me = this;

            this.onCanvasStateChange = {
                'canvas:x-ready': function() {
                    me.onCanvasReady();
                },
                'canvas:x-finish': function() {
                    me.onCanvasFinish();
                }
            };
            canvas.on(this.onCanvasStateChange);
        }
    },

    mute: function() {
        this.suppressObjectChangeHandling = true;
    },

    unmute: function() {
        this.suppressObjectChangeHandling = false;
    },

    onUndoButtonClick: function(button, e, eOpts) {
        if (this.currentStep === undefined || this.currentStep === 0) {
            return; // Can't undo
        }

        this.currentStep--;
        var view = RolandKioskPrint.AppData.getDesignerView();
        view.getEl().mask(RolandKioskPrint.app.getString('message.designer.undoing'));

        var me = this;
        setTimeout(function(){
            me.loadCurrentState().then(function() {
                view.getEl().unmask();
            });
        }, 10);
    },

    onRedoButtonClick: function(button, e, eOpts) {
        if (this.currentStep === undefined || this.currentStep == this.undoStack.length - 1) {
            return; // Can't redo
        }

        this.currentStep++;
        var view = RolandKioskPrint.AppData.getDesignerView();
        view.getEl().mask(RolandKioskPrint.app.getString('message.designer.redoing'));

        var me = this;
        setTimeout(function(){
            me.loadCurrentState().then(function() {
                view.getEl().unmask();
            });
        }, 10);
    }

});
