/*
 * File: app/view/panel/ImageOutlinePanelViewController.js
 *
 * This file was generated by Sencha Architect version 4.2.4.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 6.6.x Classic library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 6.6.x Classic. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RolandKioskPrint.view.panel.ImageOutlinePanelViewController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.panel.imageoutlinepanel',

    setCanvasAttributes: function(canvas) {
        // Set fabric custom attributes here.
        canvas.preserveObjectStacking = true; // Ensures that objects remain in current stack position when selected
        canvas.controlsAboveOverlay = true;	// Ensures that the object selection handles draw outside margins as well

        // Set the background color for image letter boxing.
        canvas.backgroundColor = '#F0F0F0';

        // Customize object controls.
        var isDeviceTabOrPhone = (Ext.os.deviceType == 'Tablet' || Ext.os.deviceType == 'Phone');
        fabric.Object.prototype.set({
            borderColor: '#3399FF',
            cornerColor: '#3399FF',
            cornerStyle: 'circle',
            cornerSize: isDeviceTabOrPhone ? 11 : 8,
            cornerHitTolerance: Ext.supports.TouchEvents ? 3 : 1,
            transparentCorners: false
        });
    },

    setImageAdjustData: function(imageData) {
        // Show the extract button with appropriate skinning.
        var view = this.getView(),
            btnExtractAgain = view.down('#btnExtractAgain'),
            btnExtractAgainClient = view.down('#btnExtractAgainClient');

        var isProductDesigner = RolandKioskPrint.AppData.isProductDesigner();
        btnExtractAgain.setVisible(!isProductDesigner);
        btnExtractAgainClient.setVisible(isProductDesigner);

        this.getViewModel().setData(imageData);
        var parentController = imageData.parentView.getController();
        this.disableRevertChanges = parentController.disableRevertChanges.bind(parentController);
        this.disableRevertChanges(true);

        // Load the image.
        var promise = this.loadImage(imageData);
        var me = this;

        var brightnessSlider = view.down('#brightnessSlider');
        var contrastSlider = view.down('#contrastSlider');
        var gammaSlider = view.down('#gammaSlider');
        var chkInverse = view.down('#chkInverse');
        var imageIntensitySlider = view.down('#imageIntensitySlider');

        brightnessSlider.on('changecomplete', this.onControlChanged.bind(this));
        contrastSlider.on('changecomplete', this.onControlChanged.bind(this));
        gammaSlider.on('changecomplete', this.onControlChanged.bind(this));

        promise.then(function(imageObject) {
            var canvas = me.canvas;
            me.suppressEvents = true;

            brightnessSlider.setValue(imageData.brightness);
            contrastSlider.setValue(imageData.contrast);
            gammaSlider.setValue(me.gammai2d(imageData.gamma));
            chkInverse.setValue(imageData.invert);
            imageIntensitySlider.setValue(imageData.threshold);

            // Create the appropriate image filters.
            var imageAdjust = new fabric.Image.filters.ImageAdjust({
                brightness: imageData.brightness,
                contrast: imageData.contrast,
                gamma: imageData.gamma,
                background: 0
            });
            imageObject.imageAdjustFilter = imageAdjust;
            imageObject.filters.push(imageAdjust);

            imageObject.invertFilter = new fabric.Image.filters.Invert({
                invert: imageData.invert
            });

            imageObject.filters.push(imageObject.invertFilter);

            imageObject.blackWhiteFilter = new fabric.Image.filters.BlackWhite({
                threshold: imageData.threshold
            });

            imageObject.tintFilter = new fabric.Image.filters.Tint({
                color: RolandKioskPrint.app.constants.IMAGE_OUTLINE_PREVIEW_COLOR
            });

            me.suppressEvents = false;

            imageObject.applyFilters();
            canvas.renderAll();
        });
    },

    applyFilter: function(filterData) {
        var canvas = this.canvas;
        var imageObject = this.getObjectById('image');

        if (filterData.threshold !== undefined) {
            imageObject.blackWhiteFilter.threshold = filterData.threshold;
        }

        var imageAdjustFilter = imageObject.imageAdjustFilter;

        if (filterData.brightness !== undefined) {
            imageAdjustFilter.brightness = filterData.brightness;
        }

        if (filterData.contrast !== undefined) {
            imageAdjustFilter.contrast = filterData.contrast;
        }

        if (filterData.gamma !== undefined) {
            imageAdjustFilter.gamma = this.gammad2i(filterData.gamma);
        }

        if (filterData.invert !== undefined) {
            imageObject.invertFilter.invert = filterData.invert;
        }

        imageObject.applyFilters();
        canvas.renderAll();
    },

    loadImage: function(imageData) {
        var deferred = new Ext.Deferred();
        var filePath = imageData.parentFilePath;

        // Add the image object to canvas, marking it non-selectable.
        var me = this;
        filePath = RolandKioskPrint.AppData.getURLWithNonce(filePath);
        fabric.Image.fromURL(filePath, function(img) {
            var canvas = me.canvas;

            // Center the image on canvas.
            var rx = canvas.width / img.width,
                ry = canvas.height / img.height;

            var rr = (rx < ry) ? rx : ry;

            var imageWidth = Math.ceil(rr * img.width);
            var imageHeight = Math.ceil(rr * img.height);
            var imageX = (canvas.width - imageWidth) / 2;
            var imageY = (canvas.height - imageHeight) / 2;

            canvas.setViewportTransform([rr, 0, 0, rr, imageX, imageY]);

            // The image object is hidden at first. Gets shown once the filters are applied.
            img.set({
                id: 'image',
                left: 0,
                top: 0,
                selectable: false,
                evented: false,
                visible: true
            });

            canvas.add(img);

            // Add the crop rect.
            if (imageData.left !== 0 ||
                imageData.top !== 0 ||
                imageData.width != 100 ||
                imageData.height != 100) {

                var cropLeft = Math.round(img.width * imageData.left / 100),
                    cropTop = Math.round(img.height * imageData.top / 100),
                    cropWidth = Math.round(img.width * imageData.width / 100),
                    cropHeight = Math.round(img.height * imageData.height / 100);

                var cropRect = new fabric.Rect({
                    id: 'crop',
                    left: cropLeft,
                    top: cropTop,
                    width: cropWidth,
                    height: cropHeight,
                    strokeDashArray: [5, 5],
                    fill: '',
                    stroke: RolandKioskPrint.app.constants.CROP_RECT_STROKE_COLOR,
                    strokeWidth: RolandKioskPrint.app.constants.CROP_RECT_STROKE_WIDTH,
                    selectable: false,
                    evented: false
                });
                canvas.add(cropRect);
            }

            // Default options for outline.
            // The outline is in high-resolution image coordinates, while the panel shows
            // low-res image. Compute the outling scaling factors.
            var scaleX = img.width / imageData.origWidth,
                scaleY = img.height / imageData.origHeight;

            me.outlineOptions = {
                scaleX: scaleX,
                scaleY: scaleY,
                fill: false,
                stroke: RolandKioskPrint.app.constants.IMAGE_OUTLINE_LINE_COLOR,
                selectable: false,
                evented: false,
                visible: true
            };

            deferred.resolve(img);
        });

        return deferred.promise;
    },

    extractOutline: function() {
        var viewModelData = this.getViewModel().getData(),
            view = this.getView(),
            imageIntensitySlider = view.down('#imageIntensitySlider'),
            brightnessSlider = view.down('#brightnessSlider'),
            contrastSlider = view.down('#contrastSlider'),
            gammaSlider = view.down('#gammaSlider'),
            chkInverse = view.down('#chkInverse');

        var imageData = {
            threshold: imageIntensitySlider.getValue(),
            brightness: brightnessSlider.getValue(),
            contrast: contrastSlider.getValue(),
            gamma: this.gammad2i(gammaSlider.getValue()),
            parentFilePath: viewModelData.parentFilePath.replace('/thumbs', ''),
            left: viewModelData.left,
            top: viewModelData.top,
            height: viewModelData.height,
            width: viewModelData.width,
            invert: chkInverse.getValue()
        };

        // Send outline request to server.
        var parentView = this.getViewModel().get('parentView');
        parentView.getEl().mask(RolandKioskPrint.app.getString('message.designer.creatingOutline'));

        Ext.Ajax.request({
            scope: this,
            method: 'POST',
            url: RolandKioskPrint.app.constants.IMAGE_OUTLINE_URL,
            jsonData: imageData,
            timeout: 240*1000,
            success: function(response, opts) {
                parentView.getEl().unmask();

                var outlineData = Ext.decode(response.responseText);
                if (!outlineData || !outlineData.success) {
                    Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                                  RolandKioskPrint.app.getString('message.designer.outlineCreationFailedImageTooBright'));
                    return;
                }

                this.addOutlineObject(outlineData.pathPointsData);
            },
            failure: function() {
                parentView.getEl().unmask();
                Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                              RolandKioskPrint.app.getString('message.designer.outlineCreationFailed'));
            }
        });
    },

    addOutlineObject: function(pathPointsData) {
        var pathPoints = [];

        // Create fabric.Path object for the outline.
        var pointsX = pathPointsData.pointsX,
            pointsY = pathPointsData.pointsY,
            commands = pathPointsData.commands;

        for (var i = 0, p = 0; i < commands.length; i++) {
            switch(commands[i]) {
                case 0:
                    pathPoints.push(['M', pointsX[p], pointsY[p]]);
                    p++;
                    break;
                case 1:
                    pathPoints.push(['L', pointsX[p], pointsY[p]]);
                    p++;
                    break;
                case 2:
                    pathPoints.push(['C',
                                     pointsX[p], pointsY[p],
                                     pointsX[p + 1], pointsY[p + 1],
                                     pointsX[p + 2], pointsY[p + 2]
                                    ]);
                    p += 3;
                    break;
                case 3:
                    pathPoints.push(['Z']);
                    break;
            }
        }

        var canvas = this.canvas;

        // Remove any existing outline.
        if (this.outline) {
           canvas.remove(this.outline);
        }

        // Add new outline.
        var outline = new fabric.Path(pathPoints, this.outlineOptions);
        outline.set('id', 'outline');

        // Adjust it to the image.
        var left = outline.get('left'),
            top = outline.get('top');

        left *= outline.get('scaleX');
        top *= outline.get('scaleY');

        var cropRect = this.getObjectById('crop');
        if (cropRect) {
            left += cropRect.left;
            top += cropRect.top;
        }

        outline.set({
            'left': left,
            'top': top
        });

        this.outline = outline;

        canvas.add(outline);
        canvas.renderAll();

        // Enable and switch ON the checkbox.
        var chkViewOutline = this.getView().down('#chkViewOutline');
        chkViewOutline.setValue(true);
    },

    getImageAdjustData: function() {
        var view = this.getView();
        var brightnessSlider = view.down('#brightnessSlider'),
            contrastSlider = view.down('#contrastSlider'),
            gammaSlider = view.down('#gammaSlider'),
            chkInverse = view.down('#chkInverse');

        return {
            outlinePath: this.outline ? this.outline.path : '',
            brightness: brightnessSlider.getValue(),
            contrast: contrastSlider.getValue(),
            gamma: this.gammad2i(gammaSlider.getValue()),
            invert: chkInverse.getValue()
        };
    },

    gammad2i: function(dGamma) {
        if (dGamma < 1) {
            return Math.floor(dGamma * 1000 - 1000);
        } else {
            return Math.floor(dGamma * 100 - 100);
        }
    },

    gammai2d: function(nGamma) {
        nGamma = nGamma < 0 ? Math.trunc(nGamma / 10) : nGamma;
        return (nGamma + 100) / 100.0;
    },

    getObjectById: function(id) {
        var canvas = this.canvas,
            objects = canvas.getObjects();

        for (var i = 0, length = objects.length; i < length; i++) {
            var object = objects[i];
            if (object.get('id') == id) {
                return object;
            }
        }
    },

    performCleanup: function() {
        // Perform any required server side cleanup.
        Ext.Ajax.request({
            scope: this,
            method: 'DELETE',
            url: RolandKioskPrint.app.constants.IMAGE_OUTLINE_URL,
            success: function(response, opts) {
                var responseData = Ext.decode(response.responseText);
                if (!responseData || !responseData.success) {
                    //Do nothing
                }
            },
            failure: function() {
                //Do nothing
            }
        });
    },

    revertChanges: function() {
        var imageData = this.getViewModel().getData();

        // Restore initial values.
        this.getView().down('#chkExtractOutline').setValue(false);
        this.updateControls({
            threshold: imageData.threshold,
            brightness: imageData.brightness,
            contrast: imageData.contrast,
            gamma: this.gammai2d(imageData.gamma),
            invert: imageData.invert
        });

        this.disableRevertChanges(true);
    },

    onControlChanged: function() {
        this.disableRevertChanges(false);
    },

    updateControls: function(imageData) {
        this.applyFilter(imageData);
        var view = this.getView(),
            imageIntensitySlider = view.down('#imageIntensitySlider'),
            brightnessSlider = view.down('#brightnessSlider'),
            contrastSlider = view.down('#contrastSlider'),
            gammaSlider = view.down('#gammaSlider'),
            chkInverse = view.down('#chkInverse');

        this.suppressEvents = true;

        brightnessSlider.setValue(imageData.brightness);
        contrastSlider.setValue(imageData.contrast);
        gammaSlider.setValue(imageData.gamma);
        chkInverse.setValue(imageData.invert);
        imageIntensitySlider.setValue(imageData.threshold);

        this.suppressEvents = false;
    },

    onCanvasPanelAfterRender: function(component, eOpts) {
        // Get hold of the html canvas element.
        var canvasContainer = this.getView().down('#canvasContainer');
        var containerElement = canvasContainer.getEl().dom;
        var canvasElement = containerElement.getElementsByTagName('canvas')[0];

        // Create the fabric.js canvas object.
        var canvas = new fabric.Canvas(canvasElement);
        this.setCanvasAttributes(canvas);

        // Set the canvas to same size as the container, leaving room for the border.
        canvas.setDimensions({
            width: canvasContainer.getWidth() - 2,
            height: canvasContainer.getHeight() - 2
        });

        canvas.calcOffset();

        // Stash the fabric canvas off the controller.
        this.canvas = canvas;
    },

    onViewImageCheckboxChange: function(field, newValue, oldValue, eOpts) {
        var image = this.getObjectById('image');
        if (image) {
            image.set('visible', newValue);
            this.canvas.renderAll();
        }
    },

    onViewOutlineCheckboxChange: function(field, newValue, oldValue, eOpts) {
        var outline = this.getObjectById('outline');
        if (outline) {
            outline.set('visible', newValue);
            this.canvas.renderAll();
        }
    },

    onBrightnessSliderChange: function(slider, newValue, thumb, type, eOpts) {
        if (this.suppressEvents) {
            return;
        }
        this.applyFilter({
            brightness: newValue
        });
    },

    onContrastSliderChange: function(slider, newValue, thumb, type, eOpts) {
        if (this.suppressEvents) {
            return;
        }
        this.applyFilter({
            contrast: newValue
        });
    },

    onGammaSliderChange: function(slider, newValue, thumb, type, eOpts) {
        if (this.suppressEvents) {
            return;
        }
        this.applyFilter({
            gamma: newValue
        });
    },

    onInverseCheckboxChange: function(field, newValue, oldValue, eOpts) {
        if (this.suppressEvents) {
            return;
        }
        this.applyFilter({
            invert: newValue
        });
        this.onControlChanged();
    },

    onExtractOutlineCheckboxChange: function(field, newValue, oldValue, eOpts) {
        var imageObject = this.getObjectById('image');
        if (newValue) {
            // Switching to outline mode.
            // Add the threshold and tint filters.
            imageObject.filters.push(imageObject.blackWhiteFilter);
            imageObject.filters.push(imageObject.tintFilter);
            imageObject.imageAdjustFilter.background = 255; // Blend against white when extracting outline
            imageObject.applyFilters();

            // Get the outline extracted.
            this.extractOutline();
        } else {
            // Back to image adjustment mode.
            // Remove the filters.
            imageObject.filters.pop();
            imageObject.filters.pop();
            imageObject.imageAdjustFilter.background = 0; // Blend against black otherwise
            imageObject.applyFilters();

            // Remove any existing outline.
            if (this.outline) {
                this.canvas.remove(this.outline);
                this.outline = null;
            }

            var chkViewOutline = this.getView().down('#chkViewOutline');
            chkViewOutline.setValue(false);

            var chkViewImage = this.getView().down('#chkViewImage');
            chkViewImage.setValue(true);
        }

        this.canvas.renderAll();
        this.onControlChanged();
    },

    onImageIntensitySliderChange: function(slider, newValue, thumb, type, eOpts) {
        if (this.suppressEvents) {
            return;
        }
        this.applyFilter({
            threshold: newValue
        });
    },

    onExtractAgainClientButtonClick: function(button, e, eOpts) {
        this.extractOutline();
    },

    onExtractAgainButtonClick: function(button, e, eOpts) {
        this.extractOutline();
    },

    onPanelAfterRender: function(component, eOpts) {
        this.suppressEvents = true;

        // Initialize the sliders min/max values.
        var brightnessSlider = this.getView().down('#brightnessSlider');
        brightnessSlider.setMinValue(RolandKioskPrint.app.constants.BRIGHTNESS_RANGE_MIN);
        brightnessSlider.setMaxValue(RolandKioskPrint.app.constants.BRIGHTNESS_RANGE_MAX);

        var contrastSlider = this.getView().down('#contrastSlider');
        contrastSlider.setMinValue(RolandKioskPrint.app.constants.CONTRAST_RANGE_MIN);
        contrastSlider.setMaxValue(RolandKioskPrint.app.constants.CONTRAST_RANGE_MAX);

        var gammaSlider = this.getView().down('#gammaSlider');
        var min = this.gammai2d(RolandKioskPrint.app.constants.GAMMA_RANGE_MIN);
        var max = this.gammai2d(RolandKioskPrint.app.constants.GAMMA_RANGE_MAX);

        gammaSlider.setMinValue(min);
        gammaSlider.setMaxValue(max);

        this.suppressEvents = false;
    }

});
