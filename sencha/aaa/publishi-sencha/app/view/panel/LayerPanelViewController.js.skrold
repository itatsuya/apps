/*
 * File: app/view/panel/LayerPanelViewController.js
 *
 * This file was generated by Sencha Architect version 4.2.4.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 6.6.x Classic library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 6.6.x Classic. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RolandKioskPrint.view.panel.LayerPanelViewController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.panel.layerpanel',

    arrange: function(action) {
        var canvas = RolandKioskPrint.AppData.getCanvas();

        var activeObject = canvas.getActiveObject();

        if (activeObject && !activeObject.isLocked) {
            switch (action) {
                case 0:
                    activeObject.bringToFront();
                    break;
                case 1:
                    activeObject.sendToBack();
                    break;
                case 2:
                    activeObject.bringForward();
                    break;
                case 3:
                    activeObject.sendBackwards();
                    break;
            }
            activeObject.setCoords();

            canvas.renderAll();
            canvas.calcOffset();

            canvas.fire('object:modified', {target: activeObject});
        }
    },

    parentShown: function() {
        // Update the panel.
        this.updatePanel();

        // Register for further selection change notifications.
        var canvas = RolandKioskPrint.AppData.getCanvas();
        var me = this;

        if (!this.onCanvasSelectionChange) {
            this.onCanvasSelectionChange = {
                'selection:created': function() {
                    me.updatePanel();
                },
                'selection:updated': function() {
                    me.updatePanel();
                },
                'selection:cleared': function() {
                    me.updatePanel();
                }
            };
        }
        canvas.on(this.onCanvasSelectionChange);
    },

    parentHidden: function() {
        // Unregister for canvas notifications.
        if (this.onCanvasSelectionChange) {
            var canvas = RolandKioskPrint.AppData.getCanvas();
            canvas.off(this.onCanvasSelectionChange);
        }
    },

    updatePanel: function() {
        var canArrange = false;

        var canvas = RolandKioskPrint.AppData.getCanvas();
        var activeObject = canvas.getActiveObject();

        var cropMode = RolandKioskPrint.AppData.getCropMode();
        if (!cropMode) {
            // Enable arrange if we have active selection.
            canArrange = (activeObject && !activeObject.isEffectivelyLocked &&
                          !activeObject.isLocked) ? true : false;
        }

        var isProductDesigner = RolandKioskPrint.AppData.isProductDesigner();

        // While the edit areas are selectable as targets in product designer,
        // we do not allow those to be moved across layers.
        if (isProductDesigner && canArrange) {
            if (activeObject && activeObject.editAreaType) {
                canArrange = false;
            } else if (activeObject && activeObject.get('type') == 'activeSelection') {
                var objects = activeObject.getObjects();
                for (var i = 0, length = objects.length; i < length; i++) {
                    if (objects[i].editAreaType) {
                        canArrange = false;
                        break;
                    }
                }

                // Ensure that all selected objects belong to the same edit area,
                // or are free objects.
                if (canArrange) {
                    var firstAreaId = objects[0].editAreaId;
                    for (var i = 1, length = objects.length; i < length; i++) {
                        if (objects[i].editAreaId != firstAreaId) {
                            canArrange = false;
                            break;
                        }
                    }
                }
            }
        }

        // While the foil imprint area can be selected in product model designer,
        // we do not allow it to be moved across layers.

        // Update : Background objects are added in cotodesign 2.0
        // In product model designer, background objects are layerable only
        // when selection contains only themselves.

        if (!isProductDesigner && canArrange) {
            if (activeObject && RolandKioskPrint.AppData.isImprintArea(activeObject)) {
                canArrange = false;
            } else if (activeObject && activeObject.get('type') == 'activeSelection') {
                var objects = activeObject.getObjects();
                var hasFoilImprintArea = false;
                var hasBGObjects = false;
                var onlyBGObjects = true;

                for (var i = 0, length = objects.length; i < length; i++) {
                    if (RolandKioskPrint.AppData.isImprintArea(objects[i])) {
                        hasFoilImprintArea = true;
                        break;
                    } else if (objects[i].id == 'background') {
                        hasBGObjects = true;
                    } else {
                        onlyBGObjects = false;
                    }
                }

                if (hasFoilImprintArea || (hasBGObjects && !onlyBGObjects)) {
                    canArrange = false;
                }
            }
        }

        // Doing away with view-model bindings.
        // These were not functioning correctly with ExtJS 6.6
        // Now enabling/disabling buttons directly.
        var view = this.getView();

        view.down('#btnBringToFront').setDisabled(!canArrange);
        view.down('#btnSendToBack').setDisabled(!canArrange);
        view.down('#btnBringForward').setDisabled(!canArrange);
        view.down('#btnSendBackward').setDisabled(!canArrange);
    },

    onBringToFrontButtonClick: function(button, e, eOpts) {
        this.arrange(0); // Bring to front
    },

    onSendToBackButtonClick: function(button, e, eOpts) {
        this.arrange(1); // Send to back
    },

    onBringForwardButtonClick: function(button, e, eOpts) {
        this.arrange(2); // Bring forward
    },

    onSendBackwardButtonClick: function(button, e, eOpts) {
        this.arrange(3); // Send backward
    }

});
