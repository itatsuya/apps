/*
 * File: app/view/panel/TextSubPanelViewController.js
 *
 * This file was generated by Sencha Architect version 4.2.4.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 6.6.x Classic library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 6.6.x Classic. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RolandKioskPrint.view.panel.TextSubPanelViewController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.panel.textsubpanel',

    getSelectedTextObjects: function() {
        var canvas = RolandKioskPrint.AppData.getCanvas();
        var textObjects;

        if (this.getViewModel().get('isCutPath')) {
            // Cut text objects.
            textObjects = canvas.getActiveObjects().filter(function(o) {
                return (o.get('type') == 'text' || o.get('type') == 'curved-text') && o.isCutPath;
            });
        } else {
            // Regular text objects.
            textObjects = canvas.getActiveObjects().filter(function(o) {
                return (o.get('type') == 'text' || o.get('type') == 'curved-text') && !o.isCutPath;
            });
        }

        return textObjects;
    },

    applyTextAttribute: function(attrName, attrValue, limitTextSize, suppressNotify) {
        var textObjects = this.getSelectedTextObjects();
        if (textObjects.length === 0) {
            return;
        }

        for (var i = 0; i < textObjects.length; i++) {
            textObjects[i].set(attrName, attrValue);
            textObjects[i].initDimensions();
            if (limitTextSize) {
                this.limitTextObjectSize(textObjects[i]);
            }
        }

        this.updateActiveGroup();

        if (!suppressNotify) {
            var canvas = RolandKioskPrint.AppData.getCanvas();
            canvas.fire('object:modified');
            canvas.renderAll();
        }
    },

    updatePanel: function() {
        var textObjects = this.getSelectedTextObjects();

        // Update the various sets of controls on the panel.
        this.updateTextArea(textObjects);

        this.updateCurvedTextControls(textObjects);

        this.updateFontDropdown(textObjects);

        this.updateFontStyleButtons(textObjects);

        this.updateAlignmentButtons(textObjects);
    },

    getTextAttribute: function(attrName, textObjects) {
        // Get the attribute value.
        // For empty selection, returns "empty".
        // If the selection has a single value for this attribute, returns
        // that value. Otherwise returns "mixed".
        var attrValue = 'empty';

        if (!textObjects) {
            textObjects = this.getSelectedTextObjects();
        }

        if (textObjects.length > 0) {
            attrValue = textObjects[0].get(attrName);
            if (attrName == 'fontFamily') {
                attrValue = this.removeFallbackFont(attrValue);
            }
        }

        for (var i = 1; i < textObjects.length; i++) {
            var objectValue = textObjects[i].get(attrName);
            if (attrName == 'fontFamily') {
                objectValue = this.removeFallbackFont(objectValue);
            }
            if (objectValue != attrValue) {
                attrValue = 'mixed';
                break;
            }
        }
        return attrValue;
    },

    getFontStyleAttributes: function() {
        var bold = false,
            italic = false,
            boldItalic = false,
            underline = false;

        var objects = this.getSelectedTextObjects();
        if (objects.length === 0) {
            var cboFonts = this.getView().down('#cboFonts');
            var fontFamily = cboFonts.getValue();

            if (fontFamily) {
                var styles = this.getFontStyles(fontFamily);
                bold = styles.bold;
                italic = styles.italic;
                boldItalic = styles.boldItalic;
                underline = true;
            }

            return {
                bold: bold,
                italic: italic,
                boldItalic: boldItalic,
                underline: underline
            };
        }

        bold = true;
        italic = true;
        boldItalic = true;

        for (var i = 0, length = objects.length; i < length; i++) {
            var fontFamily = this.removeFallbackFont(objects[i].get('fontFamily'));
            var styles = this.getFontStyles(fontFamily);

            bold = bold && styles.bold;
            italic = italic && styles.italic;
            boldItalic = boldItalic && styles.boldItalic;
        }

        return {
            bold: bold,
            italic: italic,
            boldItalic: boldItalic,
            underline: true
        };
    },

    isSelectionLocked: function() {
        var canvas = RolandKioskPrint.AppData.getCanvas();
        var activeObject = canvas.getActiveObject();

        return (activeObject && activeObject.isLocked) ? true : false;
    },

    getFontStyles: function(fontFamily) {
        // Gets the available styles for the given font family.
        var bold = false,
            italic = false,
            boldItalic = false;

        // Lookup up the font family in store.
        var record = this.fontsStore.findRecord('familyName', fontFamily);
        if (record) {
            var styles = record.data.enabledStyles;

            bold = styles.includes('bold');
            italic = styles.includes('italic');
            boldItalic = styles.includes('boldItalic');
        }

        return {
            bold: bold,
            italic: italic,
            boldItalic: boldItalic
        };
    },

    updateActiveGroup: function() {
        var canvas = RolandKioskPrint.AppData.getCanvas();

        var activeObject = canvas.getActiveObject();

        if (activeObject && activeObject.get('type') == 'activeSelection') {
            activeObject.addWithUpdate(); // Recalculate the group's dimensions and position
            activeObject.setCoords();
        }
    },

    getTextTargetAreas: function(isProductDesigner) {
        var targetAreas = [];
        var canvas = RolandKioskPrint.AppData.getCanvas();

        // Check if an edit area is explicity targeted by selection.
        var selectedObjects = canvas.getActiveObjects();

        targetAreas = selectedObjects.filter(function(object) {
            var editAreaType = object.editAreaType;
            return (
                editAreaType == RolandKioskPrint.app.constants.EDIT_AREA_TEXT ||
                editAreaType == RolandKioskPrint.app.constants.EDIT_AREA_FREE ||
                editAreaType == RolandKioskPrint.app.constants.EDIT_AREA_FOIL ||
                editAreaType == RolandKioskPrint.app.constants.EDIT_AREA_METAL
            );
        });

        if (targetAreas.length !== 0) {
            var canvasPanel = RolandKioskPrint.AppData.getCanvasPanel();
            canvasPanel.getController().sortObjects(targetAreas); // Arrange left top first.
            return targetAreas;
        }

        if (isProductDesigner) {
            // For product designer, we otherwise return a list of all text and free areas.
            targetAreas = canvas.textAreaList.concat(
                canvas.freeAreaList,
                canvas.foilAreaList,
                canvas.metalAreaList
            );
        }

        return targetAreas;
    },

    getCutTextTargetAreas: function(isProductDesigner) {
        var targetAreas = [];
        var canvas = RolandKioskPrint.AppData.getCanvas();

        // Check if an edit area is explicity targeted by selection.
        var selectedObjects = canvas.getActiveObjects();

        targetAreas = selectedObjects.filter(function(object) {
            var editAreaType = object.editAreaType;
            return (
                editAreaType == RolandKioskPrint.app.constants.EDIT_AREA_CUT
            );
        });

        if (targetAreas.length !== 0) {
            var canvasPanel = RolandKioskPrint.AppData.getCanvasPanel();
            canvasPanel.getController().sortObjects(targetAreas); // Arrange left top first.
            return targetAreas;
        }

        if (isProductDesigner) {
            // For product designer, we otherwise return a list of all cut areas.
            targetAreas = canvas.cutAreaList;
        }

        return targetAreas;
    },

    getPanelTextAttributes: function() {
        var attributes = {};

        var cboFonts = this.getView().down('#cboFonts');
        attributes.fontFamily = cboFonts.getValue();

        var btnFontStyleBold = this.getView().down('#btnFontStyleBold');
        attributes.fontWeight = btnFontStyleBold.pressed ? 'bold' : 'normal';

        var btnFontStyleItalic = this.getView().down('#btnFontStyleItalic');
        attributes.fontStyle = btnFontStyleItalic.pressed ? 'italic' : 'normal';

        var btnFontStyleUnderline = this.getView().down('#btnFontStyleUnderline');
        attributes.underline = btnFontStyleUnderline.pressed;

        var radiusSlider = this.getView().down('#radiusSlider');
        attributes.radius = radiusSlider.getValue();

        attributes.placement = this.getViewModel().get('placement') == 'outside' ? 'outside' : 'inside';

        var alignment = this.getViewModel().get('textAlignment');
        if (alignment != 'left' && alignment != 'center' && alignment != 'right') {
            alignment = 'center';
            this.lastUsedAlignment = 'center';
        }
        attributes.textAlignment = alignment;

        return attributes;
    },

    setDeselectHandler: function(textObject) {
        var me = this;

        textObject.on({
            'deselected': function() {
                me.syncText(this);
            }
        });
    },

    syncText: function(textObject) {
        var text = textObject.get('text');
        var savedTextValue = textObject.get('savedTextValue');

        if (text != savedTextValue) {
            textObject.set('savedTextValue', text);

            var canvas = RolandKioskPrint.AppData.getCanvas();
            canvas.fire('object:modified', {target: textObject});
        }
    },

    adjustTextObjectPosition: function(textObject, prevWidth, prevHeight) {
        var alignment = textObject.textAlign;
        var angle = textObject.angle * Math.PI / 180; // to radians
        var sin = fabric.util.sin(angle),
            cos = fabric.util.cos(angle);

        if (textObject.flipX) {
            if (alignment == 'left') {
                alignment = 'right';
            } else if (alignment == 'right') {
                alignment = 'left';
            }
        }

        // Delta width and height.
        var size = textObject._getTransformedDimensions();
        var dw = size.x - prevWidth;
        var dh = size.y - prevHeight;

        var dx = 0;
        var dy = 0;

        if (alignment == 'left') {
            dx = dh/2 * sin;
            dy = -dh/2 * cos;
        } else if (alignment == 'center') {
            dx = -dw/2 * cos + dh/2 * sin;
            dy = -dw/2 * sin - dh/2 * cos;
        } else if (alignment == 'right') {
            dx = -dw * cos + dh/2 * sin;
            dy = -dw * sin - dh/2 * cos;
        }

        textObject.left = textObject.left + dx;
        textObject.top = textObject.top + dy;

        textObject.setCoords();
    },

    alignTextObjects: function(textObjects) {
        var canvasPanel = RolandKioskPrint.AppData.getCanvasPanel();
        var canvasPanelController = canvasPanel.getController();

        var productBounds = canvasPanelController.getProductBounds();
        if (!textObjects) {
            textObjects = this.getSelectedTextObjects();
        }

        if (textObjects.length === 0){
            return;
        }

        textObjects.forEach(function(textObject) {
            var referenceBounds = productBounds;

            var editAreaId = textObject.editAreaId;
            if (editAreaId) {
                var editArea = canvasPanel.getController().getEditArea(editAreaId);
                referenceBounds = editArea.getBoundingRect(true);
            }
            var alignment = textObject.textAlign;
            textObject.setCoords();
            canvasPanelController.alignObjectWithinBounds(textObject, referenceBounds, alignment);
            textObject.setCoords();
        });

        this.updateActiveGroup();

        var canvas = RolandKioskPrint.AppData.getCanvas();
        canvas.fire('object:modified');
        canvas.renderAll();
    },

    getTextProperties: function(textObject) {
        var propertiesToInclude = [
            'sourceType',
            'savedTextValue',
            'specialColor',
            'textureType',
            'noColor',
            'editAreaId',
            'skipDrawing',
            'isCutPath',
            'objectCaching',
            'fillSharpness',
            'strokeSharpness',
            'isOutlinePath',
            'printType',
            'startScaleX',
            'startScaleY'
        ];

        // Set clipTo to null since it does not round-trip well through JSON.
        // We will set it later if needed.
        textObject.clipTo = null;

        var options = textObject.toObject(propertiesToInclude);

        // Remove the type and text properties.
        delete options.type;
        delete options.text;

        return options;
    },

    updateTextArea: function(textObjects) {
        this.suppressEvents = true;

        var txtArea = this.getView().down('#txtArea');
        if (textObjects.length == 1) {
            // Show the text if a single text object is selected.
            var object = textObjects[0];
            var text = object.get('text');
            var savedTextValue = object.get('savedTextValue');

            txtArea.setValue(text);

            if (!object.isListening('deselected')) {
                this.setDeselectHandler(object);
            }

            if (savedTextValue === undefined) {
                object.set('savedTextValue', text);
            }
        } else {
            // None or multiple text objects selected.
            txtArea.setValue('');
        }

        var isLocked = this.isSelectionLocked();
        txtArea.setDisabled(textObjects.length > 1 || isLocked);

        this.suppressEvents = false;
    },

    updateCurvedTextControls: function(textObjects) {
        var textType = this.getTextAttribute('type', textObjects);
        var curvedTextRadius = this.getTextAttribute('radius', textObjects);
        var placement = this.getTextAttribute('placement', textObjects);

        this.suppressEvents = true;

        var chkCurvedText = this.getView().down('#chkCurvedText');
        if (textType != 'empty') {
            chkCurvedText.setValue(textType == 'curved-text');
        }

        var isLocked = this.isSelectionLocked();
        chkCurvedText.setDisabled(textType == 'mixed' || isLocked);

        if (typeof curvedTextRadius == 'number') {
            this.getViewModel().setData({
                curvedTextRadius: curvedTextRadius
            });
        }

        this.getViewModel().setData({
            curvedTextRadiusDisabled: (curvedTextRadius == 'mixed') || isLocked,
            placement: (placement == 'empty') ? 'outside' : placement,
            placementDisabled: isLocked
        });

        this.suppressEvents = false;
    },

    updateFontDropdown: function(textObjects) {
        var fontFamily = this.getTextAttribute('fontFamily', textObjects);

        this.suppressEvents = true;

        var cboFonts = this.getView().down('#cboFonts');
        if (fontFamily != 'empty' && fontFamily != 'mixed') {
            cboFonts.setValue(fontFamily);
        } else {
            cboFonts.clearValue();
        }

        var isLocked = this.isSelectionLocked();
        cboFonts.setDisabled(isLocked);

        var lblFont = this.getView().down('#lblFont');
        lblFont.setDisabled(isLocked);

        this.suppressEvents = false;
    },

    updateFontStyleButtons: function(textObjects) {
        var fontWeight = this.getTextAttribute('fontWeight', textObjects);
        var fontStyle = this.getTextAttribute('fontStyle', textObjects);
        var underline = this.getTextAttribute('underline', textObjects);

        this.suppressEvents = true;

        var btnFontStyleBold = this.getView().down('#btnFontStyleBold');
        btnFontStyleBold.toggle(fontWeight == 'bold');

        var btnFontStyleItalic = this.getView().down('#btnFontStyleItalic');
        btnFontStyleItalic.toggle(fontStyle == 'italic');

        var btnFontStyleUnderline = this.getView().down('#btnFontStyleUnderline');
        btnFontStyleUnderline.toggle(underline === true);

        this.updateFontStyleButtonsState(textObjects);

        this.suppressEvents = false;
    },

    updateAlignmentButtons: function(textObjects) {
        var textAlignment = this.getTextAttribute('textAlign', textObjects);

        this.suppressEvents = true;

        var isLocked = this.isSelectionLocked();

        if (textObjects.length === 0) {
            textAlignment = this.lastUsedAlignment;
        }

        this.getViewModel().setData({
            textAlignment: textAlignment,
            textAlignmentDisabled: isLocked
        });

        this.suppressEvents = false;
    },

    updateFontStyleButtonsState: function(textObjects) {
        var fontStyleAttributes = this.getFontStyleAttributes(textObjects);
        var isLocked = this.isSelectionLocked();

        var boldDisabled = isLocked,
            italicDisabled = isLocked;

        if (!isLocked) {
            var btnFontStyleBold = this.getView().down('#btnFontStyleBold');
            var btnFontStyleItalic = this.getView().down('#btnFontStyleItalic');

            // Update the enabled/disabled state of the font style buttons, based on
            // what styles can be applied to the current selection.
            boldDisabled = (btnFontStyleItalic.pressed ? !fontStyleAttributes.boldItalic
                                                       : !fontStyleAttributes.bold);

            italicDisabled = (btnFontStyleBold.pressed ? !fontStyleAttributes.boldItalic
                                                       : !fontStyleAttributes.italic);
        }

        // Set view model data.
        this.getViewModel().setData({
            boldDisabled: boldDisabled,
            italicDisabled: italicDisabled,
            underlineDisabled: !fontStyleAttributes.underline || isLocked
        });
    },

    fixupFontStyles: function(object, fontStyles) {
        // For a given text object, change (by removing) the font style attributes,
        // so that they can co-exist with the given/applied font family.
        var fontWeight = (object.origFontWeight !== undefined) ? object.origFontWeight : object.fontWeight;
        var fontStyle = (object.origFontStyle !== undefined) ? object.origFontStyle : object.fontStyle;

        if (!fontStyles) {
            var fontFamily = this.removeFallbackFont(object.fontFamily);
            fontStyles = this.getFontStyles(fontFamily);
        }

        if (fontWeight == 'bold' && fontStyle == 'italic') {
            if (!fontStyles.boldItalic) {
                if (fontStyles.bold) {
                    fontStyle = 'normal';
                } else if (fontStyles.italic) {
                    fontWeight = 'normal';
                } else {
                    fontWeight = 'normal';
                    fontStyle = 'normal';
                }
            }
        } else if (fontWeight == 'bold' && !fontStyles.bold) {
            fontWeight = 'normal';
        } else if (fontStyle == 'italic' && !fontStyles.italic) {
            fontStyle = 'normal';
        }

        object.set('fontWeight', fontWeight);
        object.set('fontStyle', fontStyle);
    },

    parentShown: function() {
        var txtArea = this.getView().down('#txtArea');
        txtArea.focus();

        // No additional processing for cut.
        if (this.getViewModel().get('isCutPath')) {
            return;
        }

        // In product designer, if the product model contains edit areas, text can
        // be added only to text or free edit areas. Select the target edit area, if
        // none is already targeted.
        var isProductDesigner =
            (RolandKioskPrint.AppData.appMode == RolandKioskPrint.app.constants.APP_MODE_PRODUCT_DESIGNER);
        if (!isProductDesigner) {
            return;
        }

        var textObjects = this.getSelectedTextObjects();
        if (textObjects.length !== 0) {
            return;
        }

        var targetAreas = this.getTextTargetAreas(true);
        if (targetAreas.length !== 0) {
            var canvas = RolandKioskPrint.AppData.getCanvas();
            // For product designer, this would pick up the selected or first available area.
            if (targetAreas[0] != canvas.getActiveObject()) {
                canvas.setActiveObject(targetAreas[0]);
                canvas.renderAll();
            }
        }
    },

    parentHidden: function() {
        // Unregister for canvas notifications.
        if (this.onCanvasSelectionChange) {
            var canvas = RolandKioskPrint.AppData.getCanvas();
            canvas.off(this.onCanvasSelectionChange);
        }
    },

    parentBeforeShown: function() {
        // Update the panel.
        this.updatePanel();

        // Register for further selection change notifications.
        var canvas = RolandKioskPrint.AppData.getCanvas();
        var me = this;

        if (!this.onCanvasSelectionChange) {
            this.onCanvasSelectionChange = {
                'selection:created': function() {
                    me.updatePanel();
                },
                'selection:updated': function() {
                    me.updatePanel();
                },
                'selection:cleared': function() {
                    me.updatePanel();
                }
            };
        }
        canvas.on(this.onCanvasSelectionChange);
    },

    getDefaultFontFamily: function() {
        var sortedFonts = this.fontsStore.getData();
        if (sortedFonts.length > 0){
            return sortedFonts.getAt(0).data.familyName;
        }
        return '';
    },

    onCutTextChange: function(newValue) {
        var appData = RolandKioskPrint.AppData,
            canvas = appData.getCanvas(),
            canvasPanelController = appData.getCanvasPanel().getController();

        var textObjects = this.getSelectedTextObjects();
        if (textObjects.length === 0) {
            var isProductDesigner = appData.isProductDesigner();

            var editArea;
            var targetAreas = this.getCutTextTargetAreas(isProductDesigner);
            if (targetAreas.length !== 0) {
                // For product model designer, this picks the selected edit area.
                // For product designer, this would pick up the selected or first available area.
                editArea = targetAreas[0];
            }

            if (!canvasPanelController.canAddObject()) {
                // Check if we have reached the maximum limit on number of objects.
                return;
            }

            // Exit clip mode if active.
            canvasPanelController.endClipping();

            var attributes = this.getPanelTextAttributes();

            var isProductDesigner =
                (RolandKioskPrint.AppData.appMode == RolandKioskPrint.app.constants.APP_MODE_PRODUCT_DESIGNER);

            var sourceType = (
                isProductDesigner ? RolandKioskPrint.app.constants.OBJECT_SOURCE_PD
                : RolandKioskPrint.app.constants.OBJECT_SOURCE_PMD
            );

            var textObject;

            var undoRedoPanel = RolandKioskPrint.AppData.getUndoRedoPanel();
            undoRedoPanel.getController().mute();

            var fontFamily = attributes.fontFamily;
            if (!fontFamily) {
                fontFamily = this.getDefaultFontFamily();
            }

            // Add the fallback font.
            fontFamily = this.addFallbackFont(fontFamily);

            var strokeColor = RolandKioskPrint.app.constants.CUT_PATH_STROKE_COLOR;
            if (appData.isActivePrintTypeCut()) {
                strokeColor = RolandKioskPrint.app.getCutViewingColor(appData.productModelData.cutMaterialColor);
            }

            var chkCurvedText = this.getView().down('#chkCurvedText');
            if (chkCurvedText.checked) {
                textObject = new fabric.CurvedText(newValue, {
                    fontFamily: fontFamily,
                    fontSize: 10,
                    fontWeight: attributes.fontWeight,
                    fontStyle: attributes.fontStyle,
                    underline: attributes.underline,
                    fill: '',
                    stroke: strokeColor,
                    strokeWidth: RolandKioskPrint.app.constants.CUT_TEXT_STROKE_WIDTH,
                    scaleX: 0.8,
                    scaleY: 0.8,
                    savedTextValue: newValue,
                    textAlign: attributes.textAlignment,
                    sourceType: sourceType,
                    isCutPath: true, // Custom property
                    radius: attributes.radius,
                    placement: attributes.placement,
                    spacing: 2,
                    printType: RolandKioskPrint.app.constants.PRINT_TYPE_CUT
                });
            } else {
                textObject = new fabric.Text(newValue, {
                    fontFamily: fontFamily,
                    fontSize: 10,
                    fontWeight: attributes.fontWeight,
                    fontStyle: attributes.fontStyle,
                    underline: attributes.underline,
                    fill: '',
                    stroke: strokeColor,
                    strokeWidth: RolandKioskPrint.app.constants.CUT_TEXT_STROKE_WIDTH,
                    scaleX: 0.8,
                    scaleY: 0.8,
                    textAlign: attributes.textAlignment,
                    savedTextValue: newValue,
                    isCutPath: true, // Custom property
                    sourceType: sourceType,
                    printType: RolandKioskPrint.app.constants.PRINT_TYPE_CUT
                });
            }
            this.setDeselectHandler(textObject);

            // fabric.js caching for text objects causes truncation issues for certain fonts.
            // Since fonts can be added to cotodesign system after we ship, we disable object
            // caching to be safe.
            textObject.set('objectCaching', false);

            // Position the object centered in bounds.
            var referenceBounds = canvasPanelController.getProductBounds();

            // If cut edit area is selected, add the text object to that area.
            if (editArea) {
                referenceBounds = canvasPanelController.getBoundingRect(editArea);
                canvasPanelController.addObjectToEditArea(textObject, editArea);
            } else {
                canvas.add(textObject);
            }


            // Set default text font size at 15% of long side of the template.
            var longSide = (referenceBounds.width < referenceBounds.height) ? referenceBounds.height : referenceBounds.width;
            var lineHeight = longSide * 0.15, // 15% of long side
                lineHeightFactor = 1.25; // line-height to font-size ratio

            var reqFontSize = lineHeight / lineHeightFactor;
            if (reqFontSize < 9) {
                reqFontSize = 9;
            }

            var scale = reqFontSize / (textObject.fontSize * textObject.scaleX),
                scaleX = textObject.scaleX * scale,
                scaleY = textObject.scaleY * scale;

            textObject.set({
                'scaleX': scaleX,
                'scaleY': scaleY,
                'startScaleX': scaleX,
                'startScaleY': scaleY
            });
            textObject.setCoords();

            canvasPanelController.alignObjectWithinBounds(textObject, referenceBounds, attributes.textAlignment, true);
            textObject.setCoords();

            // Remember the previous width and height.
            var prevSize = textObject._getTransformedDimensions();

            // Limit width and height to parent, by adjusting the scaling.
            this.limitTextObjectSize(textObject);

            // Adjust the object position as per the alignment.
            this.adjustTextObjectPosition(textObject, prevSize.x, prevSize.y);

            undoRedoPanel.getController().unmute();
            canvas.fire('object:added', {target: textObject});

            // Set as active.
            canvas.setActiveObject(textObject);
        } else if (textObjects.length == 1) {
            var textObject = textObjects[0];

            // Remember the previous width and height.
            var prevSize = textObject._getTransformedDimensions();

            // Update the text.
            if (textObject.get('type') == 'curved-text') {
                textObject.setText(newValue);
            } else {
                textObjects[0].set('text', newValue);
            }

            // Limit width and height to parent, by adjusting the scaling.
            this.limitTextObjectSize(textObject);

            // Adjust the object position as per the alignment.
            this.adjustTextObjectPosition(textObject, prevSize.x, prevSize.y);

            // Don't register every char input as an undo step. Do it for a block of chars.
            if ((newValue.length % RolandKioskPrint.app.constants.UNDO_TEXT_BLOCK_LENGTH) === 0) {
                textObjects[0].set('savedTextValue', newValue);
                canvas.fire('object:modified', {target: textObjects[0]});
            }
        }

        canvas.calcOffset();
        canvas.renderAll();
    },

    onTextChange: function(newValue) {
        var appData = RolandKioskPrint.AppData,
            canvas = appData.getCanvas(),
            canvasPanelController = appData.getCanvasPanel().getController(),
            productModel = appData.productModelData;

        // Get default color from color settings. Earlier we used to use Black.
        var colorValue = RolandKioskPrint.AppData.getDefaultColor();

        var sharpness = RolandKioskPrint.app.constants.METAL_FILL_SHARPNESS_DEFAULT;

        if (appData.isActivePrintTypeFoil()) {
            // Foil color.
            var foilColor = appData.getCurrentFoilColor();
            colorValue = foilColor.value;
        } else if (appData.isActivePrintTypeMetal()) {
            // Default sharpness.
            var backgroundColor = productModel.backgroundColor;
            if (!backgroundColor) {
                backgroundColor = productModel.materialColor;
            }
            colorValue = canvasPanelController.applySharpnessToColor(backgroundColor, sharpness);
        }

        // If a text object is selected, update the text.
        // In all other cases, add a new text object.
        var textObjects = this.getSelectedTextObjects();
        if (textObjects.length === 0) {
            // In product designer, text can be added only to text or free edit areas.
            var isProductDesigner = appData.isProductDesigner();

            var editArea;
            var targetAreas = this.getTextTargetAreas(isProductDesigner);
            if (targetAreas.length !== 0) {
                // For product model designer, this picks the selected edit area.
                // For product designer, this would pick up the selected or first available area.
                editArea = targetAreas[0];
            }

            if (isProductDesigner && !editArea && canvas.imageAreaList.length !== 0) {
                // If product designer, and we only have image areas, we can't place text.
                return;
            }

            if (!canvasPanelController.canAddObject()) {
                // Check if we have reached the maximum limit on number of objects.
                return;
            }

            // Exit clip mode if active.
            canvasPanelController.endClipping();

            var attributes = this.getPanelTextAttributes();

            var sourceType = (
                isProductDesigner ? RolandKioskPrint.app.constants.OBJECT_SOURCE_PD
                : RolandKioskPrint.app.constants.OBJECT_SOURCE_PMD
            );

            var textObject;

            var undoRedoPanel = appData.getUndoRedoPanel();
            undoRedoPanel.getController().mute();

            var fontFamily = attributes.fontFamily;
            if (!fontFamily) {
                fontFamily = this.getDefaultFontFamily();
            }

            // Add the fallback font.
            fontFamily = this.addFallbackFont(fontFamily);

            var chkCurvedText = this.getView().down('#chkCurvedText');
            if (chkCurvedText.checked) {
                textObject = new fabric.CurvedText(newValue, {
                    fontFamily: fontFamily,
                    fontSize: 10,
                    fontWeight: attributes.fontWeight,
                    fontStyle: attributes.fontStyle,
                    underline: attributes.underline,
                    fill: colorValue,
                    scaleX: 0.8,
                    scaleY: 0.8,
                    savedTextValue: newValue,
                    textAlign: attributes.textAlignment,
                    sourceType: sourceType,
                    radius: attributes.radius,
                    placement: attributes.placement,
                    spacing: 2,
                    printType: appData.getActivePrintType()
                });
            } else {
                textObject = new fabric.Text(newValue, {
                    fontFamily: fontFamily,
                    fontSize: 10,
                    fontWeight: attributes.fontWeight,
                    fontStyle: attributes.fontStyle,
                    underline: attributes.underline,
                    fill: colorValue,
                    scaleX: 0.8,
                    scaleY: 0.8,
                    textAlign: attributes.textAlignment,
                    savedTextValue: newValue,
                    sourceType: sourceType,
                    printType: appData.getActivePrintType()
                });
            }
            this.setDeselectHandler(textObject);

            // Set the fill sharpness if metal print.
            if (appData.isActivePrintTypeMetal()) {
                textObject.set({
                    'fillSharpness': sharpness,
                    'paintFirst': 'stroke'
                });

                // Apply outline if enabled by default.
                if (productModel.enableOutline) {
                    textObject.set({
                        'stroke': RolandKioskPrint.app.constants.METAL_OUTLINE_COLOR_DEFAULT,
                        'strokeWidth': RolandKioskPrint.app.constants.DEFAULT_STROKE_WIDTH,
                        'isOutlinePath': true
                    });
                }
            }

            // fabric.js caching for text objects causes truncation issues for certain fonts.
            // Since fonts can be added to cotodesign system after we ship, we disable object
            // caching to be safe.
            textObject.set('objectCaching', false);

            // Position the object centered in bounds.
            var referenceBounds = canvasPanelController.getProductBounds();

            // If text or free edit area is selected, add the text object to that area.
            if (editArea) {
                referenceBounds = canvasPanelController.getBoundingRect(editArea);
                canvasPanelController.addObjectToEditArea(textObject, editArea);
            } else {
                if (!isProductDesigner && appData.isActivePrintTypeFoilOrMetal()) {
                    var imprintArea = canvasPanelController.getImprintArea(
                        appData.getActivePrintType());
                    if (imprintArea) {
                        referenceBounds = canvasPanelController.getBoundingRect(imprintArea);
                    }
                }
                canvas.add(textObject);
            }

            // Set default text font size at 15% of long side of the template.
            var productBounds = canvasPanelController.getProductBounds();
            var longSide = (productBounds.width < productBounds.height) ? productBounds.height : productBounds.width;
            var lineHeight = longSide * 0.15, // 15% of long side
                lineHeightFactor = 1.25; // line-height to font-size ratio

            if (lineHeight > referenceBounds.height) {
                // Possible edit area case.
                lineHeight = referenceBounds.height;
            }

            var reqFontSize = lineHeight / lineHeightFactor;
            var scale = reqFontSize / (textObject.fontSize * textObject.scaleX),
                scaleX = textObject.scaleX * scale,
                scaleY = textObject.scaleY * scale;

            textObject.set({
                'scaleX': scaleX,
                'scaleY': scaleY,
                'startScaleX': scaleX,
                'startScaleY': scaleY
            });
            textObject.setCoords();

            canvasPanelController.alignObjectWithinBounds(textObject, referenceBounds, attributes.textAlignment, true);
            textObject.setCoords();

            // Remember the previous width and height.
            var prevSize = textObject._getTransformedDimensions();

            // Limit width and height to parent, by adjusting the scaling.
            this.limitTextObjectSize(textObject);

            // Adjust the object position as per the alignment.
            this.adjustTextObjectPosition(textObject, prevSize.x, prevSize.y);

            undoRedoPanel.getController().unmute();
            canvas.fire('object:added', {target: textObject});

            // Set as active.
            canvas.setActiveObject(textObject);
        } else if (textObjects.length == 1) {
            var textObject = textObjects[0];

            // Remember the previous width and height.
            var prevSize = textObject._getTransformedDimensions();

            // Update the text.
            if (textObject.get('type') == 'curved-text') {
                textObject.setText(newValue);
            } else {
                textObjects[0].set('text', newValue);
            }

            // Limit width and height to parent, by adjusting the scaling.
            this.limitTextObjectSize(textObject);

            // Adjust the object position as per the alignment.
            this.adjustTextObjectPosition(textObject, prevSize.x, prevSize.y);

            // Don't register every char input as an undo step. Do it for a block of chars.
            if ((newValue.length % RolandKioskPrint.app.constants.UNDO_TEXT_BLOCK_LENGTH) === 0) {
                textObjects[0].set('savedTextValue', newValue);
                canvas.fire('object:modified', {target: textObjects[0]});
            }
        }

        canvas.calcOffset();
        canvas.renderAll();
    },

    addFallbackFont: function(fontFamily) {
        // Add the notdef font, shows the not defined glyph.
        return '\'' + fontFamily + '\', Notdef';
    },

    removeFallbackFont: function(fontFamily) {
        // Remove the notdef font.
        fontFamily = fontFamily.replace(/, Notdef/i, '');
        return fontFamily.replace(/'/g, '');
    },

    limitTextObjectSize: function(textObject) {
        var canvasPanel = RolandKioskPrint.AppData.getCanvasPanel(),
            canvasPanelController = canvasPanel.getController();

        var parentBounds = canvasPanelController.getProductBounds();

        // If child of edit area, get the edit area bounds.
        if (textObject.editAreaId) {
            var editArea = canvasPanelController.getEditArea(textObject.editAreaId);
            parentBounds = canvasPanelController.getBoundingRect(editArea);
        }

        var rx = 1,
            ry = 1,
            startScaleX = textObject.startScaleX,
            startScaleY = textObject.startScaleY;

        if (!startScaleX) {
            startScaleX = textObject.scaleX;
            textObject.startScaleX = startScaleX;
        }

        if (!startScaleY) {
            startScaleY = textObject.scaleY;
            textObject.startScaleY = startScaleY;
        }

        var textBounds = canvasPanelController.getBoundingRect(textObject),
            textWidth = textBounds.width,
            textHeight = textBounds.height;

        if (textWidth > parentBounds.width || textObject.scaleX < startScaleX) {
            rx = parentBounds.width / textWidth;
        }

        if (textHeight > parentBounds.height || textObject.scaleY < startScaleY) {
            ry = parentBounds.height / textHeight;
        }

        var rr = (rx < ry) ? rx : ry;
        var applyRR = startScaleY >= textObject.scaleY * rr || startScaleX >= textObject.scaleX * rr;
        if (applyRR) {
            textObject.set({
                'scaleX': textObject.scaleX * rr,
                'scaleY': textObject.scaleY * rr
            });
        } else {
            textObject.set({
                'scaleX': startScaleX,
                'scaleY': startScaleY
            });
        }
    },

    onTextAreaChange: function(field, newValue, oldValue, eOpts) {
        if (this.suppressEvents) {
            return;
        }

        if (this.getViewModel().get('isCutPath')) {
            this.onCutTextChange(newValue);
        } else {
            this.onTextChange(newValue);
        }
    },

    onTextAreaFocusLeave: function(component, event, eOpts) {
        if (this.suppressEvents) {
            return;
        }

        var textObjects = this.getSelectedTextObjects();

        if (textObjects.length === 1) {
            this.syncText(textObjects[0]);
        }
    },

    onTextTypeChange: function(field, newValue, oldValue, eOpts) {
        if (this.suppressEvents) {
            return;
        }

        var textObjects = this.getSelectedTextObjects();
        if (textObjects.length === 0) {
            return;
        }

        var undoRedoPanel = RolandKioskPrint.AppData.getUndoRedoPanel();
        undoRedoPanel.getController().mute(); // Mute undo/redo handling. We notify once at end.

        var canvas = RolandKioskPrint.AppData.getCanvas();
        var canvasPanel = RolandKioskPrint.AppData.getCanvasPanel();

        var temp = canvas.renderOnAddRemove;
        canvas.renderOnAddRemove = false;

        // Discard the active selection.
        canvas.discardActiveObject();

        var radius = this.getView().down('#radiusSlider').getValue();
        var newObjects = [];

        for (var i = 0; i < textObjects.length; i++) {
            var newTextObject;
            if (newValue) {
                if (textObjects[i].type == 'curved-text') {
                    newObjects.push(textObjects[i]);
                    continue;
                }

                var options = this.getTextProperties(textObjects[i]);

                // Add the curved text attributes.
                options.radius = radius;

                newTextObject = new fabric.CurvedText(textObjects[i].text, options);
            } else {
                if (textObjects[i].type == 'text') {
                    newObjects.push(textObjects[i]);
                    continue;
                }

                var options = this.getTextProperties(textObjects[i]);

                // Remove the curved text attributes.
                delete options.radius;
                delete options.spacing;
                delete options.placement;

                newTextObject = new fabric.Text(textObjects[i].text, options);
            }

            this.limitTextObjectSize(newTextObject);

            newTextObject.set('objectCaching', false);
            if (newTextObject.editAreaId) {
                canvasPanel.getController().setClipToEditArea(newTextObject);
            }

            newObjects.push(newTextObject);

            // Add to canvas at the same position.
            var index = canvas.getObjects().indexOf(textObjects[i]);
            canvas.insertAt(newTextObject, index, true);
        }

        var newObject;
        if (newObjects.length == 1) {
            // Set the object as active.
            canvas.setActiveObject(newObjects[0]);
            newObject = newObjects[0];
        } else {
            // Create a selection group for the objects.
            var selectionGroup = new fabric.ActiveSelection(newObjects, {
                canvas: canvas
            });
            canvas.setActiveObject(selectionGroup);
            newObject = selectionGroup;
        }

        canvas.renderOnAddRemove = temp;

        undoRedoPanel.getController().unmute();
        canvas.fire('object:modified', newObject);

        canvas.calcOffset();
        canvas.renderAll();
    },

    onRadiusSliderChange: function(slider, newValue, thumb, type, eOpts) {
        if (!this.suppressEvents) {
            // Keep changing the radius. Notify at end.
            this.applyTextAttribute('radius', newValue, true, true);
            RolandKioskPrint.AppData.getCanvas().requestRenderAll();
        }
    },

    onRadiusSliderDragEnd: function(slider, e, eOpts) {
        if (!this.suppressEvents) {
            var canvas = RolandKioskPrint.AppData.getCanvas();
            canvas.fire('object:modified');
        }
    },

    onOutsideCurvedButtonClick: function(button, e, eOpts) {
        if (!this.suppressEvents) {
            this.applyTextAttribute('placement', 'outside', true);
        }
    },

    onInsideCurvedButtonClick: function(button, e, eOpts) {
        if (!this.suppressEvents) {
            this.applyTextAttribute('placement', 'inside', true);
        }
    },

    onFontComboChange: function(field, newValue, oldValue, eOpts) {
        if (!this.suppressEvents) {
            var fontStyles = this.getFontStyles(newValue);

            var textObjects = this.getSelectedTextObjects();
            if (textObjects.length !== 0) {
                // Update the font family and allowed styling based on font.
                var me = this;
                textObjects.forEach(function(object) {
                    object.set('fontFamily', me.addFallbackFont(newValue));
                    me.limitTextObjectSize(object);

                    me.fixupFontStyles(object, fontStyles);
                    object.initDimensions();
                });

                this.updateActiveGroup();

                var canvas = RolandKioskPrint.AppData.getCanvas();
                canvas.fire('object:modified');
                canvas.renderAll();
            }

            this.updateFontStyleButtons(textObjects); // Update the buttons state
        }
    },

    onFontStyleBoldButtonClick: function(button, e, eOpts) {
        if (!this.suppressEvents) {
            var fontWeight = button.pressed ? 'bold' : 'normal';

            var textObjects = this.getSelectedTextObjects();
            if (textObjects.length !== 0) {
                var me = this;
                textObjects.forEach(function(object) {
                    // Update the font weight and allowed styling based on font weight.
                    object.set('fontWeight', fontWeight);
                    object.set('origFontWeight', fontWeight);
                    me.limitTextObjectSize(object);

                    me.fixupFontStyles(object);
                    object.initDimensions();
                });

                this.updateActiveGroup();

                var canvas = RolandKioskPrint.AppData.getCanvas();
                canvas.fire('object:modified');
                canvas.renderAll();

                this.updateFontStyleButtons(textObjects);
            } else {
                this.updateFontStyleButtonsState(textObjects);
            }
        }
    },

    onFontStyleItalicButtonClick: function(button, e, eOpts) {
        if (!this.suppressEvents) {
            var fontStyle = button.pressed ? 'italic' : 'normal';

            var textObjects = this.getSelectedTextObjects();
            if (textObjects.length !== 0) {
                var me = this;
                textObjects.forEach(function(object) {
                    // Update the font style and allowed styling based on font style.
                    object.set('fontStyle', fontStyle);
                    object.set('origFontStyle', fontStyle);
                    me.limitTextObjectSize(object);

                    me.fixupFontStyles(object);
                    object.initDimensions();
                });

                this.updateActiveGroup();

                var canvas = RolandKioskPrint.AppData.getCanvas();
                canvas.fire('object:modified');
                canvas.renderAll();

                this.updateFontStyleButtons(textObjects);
            } else {
                this.updateFontStyleButtonsState(textObjects);
            }
        }
    },

    onFontStyleUnderlineButtonClick: function(button, e, eOpts) {
        if (!this.suppressEvents) {
            this.applyTextAttribute('underline', button.pressed);
        }
    },

    onAlignLeftButtonClick: function(button, e, eOpts) {
        if (!this.suppressEvents) {
            this.applyTextAttribute('textAlign', 'left', true, true);
            this.alignTextObjects();
            this.lastUsedAlignment = 'left';
        }
    },

    onAlignCenterButtonClick: function(button, e, eOpts) {
        if (!this.suppressEvents) {
            this.applyTextAttribute('textAlign', 'center', true, true);
            this.alignTextObjects();
            this.lastUsedAlignment = 'center';
        }
    },

    onAlignRightButtonClick: function(button, e, eOpts) {
        if (!this.suppressEvents) {
            this.applyTextAttribute('textAlign', 'right', true, true);
            this.alignTextObjects();
            this.lastUsedAlignment = 'right';
        }
    },

    onPanelAfterRender: function(component, eOpts) {
        var txtArea = this.getView().down('#txtArea');

        // Set the maximum number of input characters.
        // txtArea.enforceMaxLength seems to only work with config.
        txtArea.inputEl.set({
            maxLength : RolandKioskPrint.app.constants.MAX_INPUT_CHARS
        });

        // Text box isn't taking the focus on tap on iOS. Setting the focus explicitly.
        if (Ext.os.deviceType == 'Tablet' || Ext.os.deviceType == 'Phone') {
            txtArea.getEl().on({
                click : function(e) {
                    txtArea.focus();
                }
            });
        }

        this.suppressEvents = true;
        var radiusSlider = this.getView().down('#radiusSlider');
        radiusSlider.setMinValue(RolandKioskPrint.app.constants.CURVED_TEXT_RADIUS_MIN);
        radiusSlider.setMaxValue(RolandKioskPrint.app.constants.CURVED_TEXT_RADIUS_MAX);

        this.getViewModel().setData({
            curvedTextRadius: RolandKioskPrint.app.constants.CURVED_TEXT_RADIUS_DEFAULT
        });

        var chkCurvedText = this.getView().down('#chkCurvedText');
        chkCurvedText.setValue(false);

        var cboFonts = this.getView().down('#cboFonts'),
            panelType = this.getView().up().xtype,
            store = cboFonts.getStore(),
            fontsStore = [];

        if (panelType == 'panel.textpanel') {
            store.each(function(record) {
                if (record.data.textPanel) {
                    fontsStore.push(record);
                }
            });
            cboFonts.setStore(fontsStore);
        } else {
            store.each(function(record) {
                if (record.data.cutPanel){
                    fontsStore.push(record);
                }
            });
            cboFonts.setStore(fontsStore);
        }

        this.fontsStore = cboFonts.getStore();
        this.suppressEvents = false;
    }

});
