/*
 * File: app/view/panel/AlignPanelViewController.js
 *
 * This file was generated by Sencha Architect version 4.2.4.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 6.6.x Classic library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 6.6.x Classic. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RolandKioskPrint.view.panel.AlignPanelViewController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.panel.alignpanel',

    createSelectionGroup: function(canvas, objects) {
        // Create a selection group for the objects.
        var selectionGroup = new fabric.ActiveSelection(objects, {
            canvas: canvas
        })


        canvas.setActiveObject(selectionGroup)

        return selectionGroup

    },

    parentShown: function() {
        // Update the panel.
        this.updatePanel()


        // Register for further selection change notifications.
        var canvas = RolandKioskPrint.AppData.getCanvas()

        var me = this


        if (!this.onCanvasSelectionChange) {
            this.onCanvasSelectionChange = {
                'selection:created': function() {
                    me.updatePanel()

                },
                'selection:updated': function() {
                    me.updatePanel()

                },
                'selection:cleared': function() {
                    me.updatePanel()

                }
            }

        }
        canvas.on(this.onCanvasSelectionChange)

    },

    parentHidden: function() {
        // Unregister for canvas notifications.
        if (this.onCanvasSelectionChange) {
            var canvas = RolandKioskPrint.AppData.getCanvas()

            canvas.off(this.onCanvasSelectionChange)

        }
    },

    updatePanel: function() {
        var canAlign = false,
            canAlignHorzVert = false


        var canvas = RolandKioskPrint.AppData.getCanvas()

        var activeObject = canvas.getActiveObject()


        var cropMode = RolandKioskPrint.AppData.getCropMode()

        if (!cropMode) {
            // Enable align if we have multiple items selected.
            // For fabric canvas, this means that we have an active selection group.
            canAlign = (activeObject && !activeObject.isLocked && !activeObject.isEffectivelyLocked &&
                        activeObject.get('type') == 'activeSelection') ? true : false


            // Enable horizontal and vertical align if we have a selection.
            canAlignHorzVert = (activeObject && !activeObject.isEffectivelyLocked &&
                                !activeObject.isLocked) ? true : false

        }

        if (canAlign || canAlignHorzVert){
            var objects = [],
                isProductDesigner = RolandKioskPrint.AppData.isProductDesigner()


            if (activeObject.get('type') == 'activeSelection') {
                objects = activeObject.getObjects()

            } else {
                objects = [activeObject]

            }

            // While the edit areas are selectable as targets in product designer, we do not
            // allow those to be moved around.
            if (isProductDesigner) {
                for (var i = 0, length = objects.length
 i < length; i++) {
                    if (objects[i].editAreaType) {
                        canAlign = false

                        canAlignHorzVert = false

                        break

                    }
                }
            }

            // For now, do not allow foil imprint area to participate in align operation.
            // Going forward, we can do fancy things like aligning to imprint area.
            if (!isProductDesigner) {
                for (var i = 0, length = objects.length
 i < length; i++) {
                    if (RolandKioskPrint.AppData.isImprintArea(objects[i])) {
                        canAlign = false

                        canAlignHorzVert = false

                        break

                    }
                }
            }
        }

        // Doing away with view-model bindings.
        // These were not functioning correctly with ExtJS 6.6
        // Now enabling/disabling buttons directly.
        var view = this.getView()


        view.down('#btnAlignMiddle').setDisabled(!canAlign)

        view.down('#btnAlignCenter').setDisabled(!canAlign)

        view.down('#btnAlignTop').setDisabled(!canAlign)

        view.down('#btnAlignLeft').setDisabled(!canAlign)

        view.down('#btnAlignBottom').setDisabled(!canAlign)

        view.down('#btnAlignRight').setDisabled(!canAlign)


        view.down('#btnAlignVerticalCenter').setDisabled(!canAlignHorzVert)

        view.down('#btnAlignHorizontalCenter').setDisabled(!canAlignHorzVert)

    },

    alignHorzVertCenter: function(alongHorz) {
        var canvas = RolandKioskPrint.AppData.getCanvas()


        var objects = []

        var activeObject = canvas.getActiveObject()


        if(!activeObject || activeObject.isLocked){
            return

        }

        if (activeObject.get('type') == 'activeSelection') {
            objects = activeObject.getObjects()

        } else {
            objects = [activeObject]

        }

        canvas.discardActiveObject()


        var canvasPanel = RolandKioskPrint.AppData.getCanvasPanel()

        var canvasPanelController = canvasPanel.getController()


        var productBounds =  canvasPanelController.getProductBounds()


        objects.forEach(function(object) {
            var diff = 0,
                referenceCenter, objectCenter


            // Get the reference bounds - product or the edit area.
            referenceBounds = productBounds

            if (object.editAreaId) {
                var editArea = canvasPanelController.getEditArea(object.editAreaId)

                if (editArea) {
                    referenceBounds = editArea.getBoundingRect(true)

                }
            }

            var objectBounds = object.getBoundingRect(true)


            // Now position the object.
            if (alongHorz) {
                referenceCenter = referenceBounds.left + referenceBounds.width / 2

                objectCenter = objectBounds.left + objectBounds.width / 2


                diff = referenceCenter - objectCenter


                object.left = object.left + diff

            } else {
                referenceCenter = referenceBounds.top + referenceBounds.height / 2

                objectCenter = objectBounds.top + objectBounds.height / 2


                diff = referenceCenter - objectCenter


                object.top = object.top + diff

            }
            object.setCoords()

        })


        if (objects.length == 1) {
            canvas.setActiveObject(objects[0])

            activeObject = objects[0]

        } else {
            activeObject = this.createSelectionGroup(canvas, objects)

        }

        canvas.renderAll()

        canvas.calcOffset()


        this.notifyModified(canvas, activeObject)

    },

    notifyModified: function(canvas, object) {
        canvas.fire('object:modified', {target: object})

    },

    onAlignMiddleButtonClick: function(button, e, eOpts) {
        var canvas = RolandKioskPrint.AppData.getCanvas()

        var activeObject = canvas.getActiveObject()


        if (activeObject && !activeObject.isLocked && activeObject.get('type') == 'activeSelection') {
            var objectsInGroup = activeObject.getObjects()

            canvas.discardActiveObject()


            // Find the group middle.
            var groupTop,
                groupBottom

            objectsInGroup.forEach(function(o) {
                var objectBounds = o.getBoundingRect(true)

                if (groupTop === undefined || objectBounds.top < groupTop) {
                    groupTop = objectBounds.top

                }
                var objectBottom = objectBounds.top + objectBounds.height

                if (groupBottom === undefined || objectBottom > groupBottom) {
                    groupBottom = objectBottom

                }
            })


            var groupMiddle = (groupTop + groupBottom) / 2


            // Move the objects.
            objectsInGroup.forEach(function(o) {
                var objectBounds = o.getBoundingRect(true)

                var dy = groupMiddle - (objectBounds.top + objectBounds.height / 2)

                o.top = o.top + dy

                o.setCoords()

            })


            activeObject = this.createSelectionGroup(canvas, objectsInGroup)


            canvas.renderAll()

            canvas.calcOffset()


            this.notifyModified(canvas, activeObject)

        }
    },

    onAlignCenterButtonClick: function(button, e, eOpts) {
        var canvas = RolandKioskPrint.AppData.getCanvas()

        var activeObject = canvas.getActiveObject()


        if (activeObject && !activeObject.isLocked && activeObject.get('type') == 'activeSelection') {
            var objectsInGroup = activeObject.getObjects()

            canvas.discardActiveObject()


            // Find the group center.
            var groupLeft,
                groupRight

            objectsInGroup.forEach(function(o) {
                var objectBounds = o.getBoundingRect(true)

                if (groupLeft === undefined || objectBounds.left < groupLeft) {
                    groupLeft = objectBounds.left

                }
                var objectRight = objectBounds.left + objectBounds.width

                if (groupRight === undefined || objectRight > groupRight) {
                    groupRight = objectRight

                }
            })


            var groupCenter = (groupLeft + groupRight) / 2


            // Move the objects.
            objectsInGroup.forEach(function(o) {
                var objectBounds = o.getBoundingRect(true)

                var dx = groupCenter - (objectBounds.left + objectBounds.width / 2)

                o.left = o.left + dx

                o.setCoords()

            })


            activeObject = this.createSelectionGroup(canvas, objectsInGroup)


            canvas.renderAll()

            canvas.calcOffset()


            this.notifyModified(canvas, activeObject)

        }
    },

    onAlignTopButtonClick: function(button, e, eOpts) {
        var canvas = RolandKioskPrint.AppData.getCanvas()

        var activeObject = canvas.getActiveObject()


        if (activeObject && !activeObject.isLocked && activeObject.get('type') == 'activeSelection') {
            var objectsInGroup = activeObject.getObjects()

            canvas.discardActiveObject()


            // Find the group top.
            var groupTop

            objectsInGroup.forEach(function(o) {
                var objectBounds = o.getBoundingRect(true)

                if (groupTop === undefined || objectBounds.top < groupTop) {
                    groupTop = objectBounds.top

                }
            })


            // Move the objects.
            objectsInGroup.forEach(function(o) {
                var objectBounds = o.getBoundingRect(true)

                var dy = groupTop - objectBounds.top

                o.top = o.top + dy

                o.setCoords()

            })


            activeObject = this.createSelectionGroup(canvas, objectsInGroup)


            canvas.renderAll()

            canvas.calcOffset()


            this.notifyModified(canvas, activeObject)

        }
    },

    onAlignLeftButtonClick: function(button, e, eOpts) {
        var canvas = RolandKioskPrint.AppData.getCanvas()

        var activeObject = canvas.getActiveObject()


        if (activeObject && !activeObject.isLocked && activeObject.get('type') == 'activeSelection') {
            var objectsInGroup = activeObject.getObjects()

            canvas.discardActiveObject()


            // Find the group left.
            var groupLeft

            objectsInGroup.forEach(function(o) {
                var objectBounds = o.getBoundingRect(true)

                if (groupLeft === undefined || objectBounds.left < groupLeft) {
                    groupLeft = objectBounds.left

                }
            })


            // Move the objects.
            objectsInGroup.forEach(function(o) {
                var objectBounds = o.getBoundingRect(true)

                var dx = groupLeft - objectBounds.left

                o.left = o.left + dx

                o.setCoords()

            })


            activeObject = this.createSelectionGroup(canvas, objectsInGroup)


            canvas.renderAll()

            canvas.calcOffset()


            this.notifyModified(canvas, activeObject)

        }
    },

    onAlignBottomButtonClick: function(button, e, eOpts) {
        var canvas = RolandKioskPrint.AppData.getCanvas()

        var activeObject = canvas.getActiveObject()


        if (activeObject && !activeObject.isLocked && activeObject.get('type') == 'activeSelection') {
            var objectsInGroup = activeObject.getObjects()

            canvas.discardActiveObject()


            // Find the group bottom.
            var groupBottom

            objectsInGroup.forEach(function(o) {
                var objectBounds = o.getBoundingRect(true)

                var objectBottom = objectBounds.top + objectBounds.height

                if (groupBottom === undefined || objectBottom > groupBottom) {
                    groupBottom = objectBottom

                }
            })


            // Move the objects.
            objectsInGroup.forEach(function(o) {
                var objectBounds = o.getBoundingRect(true)

                var dy = groupBottom - (objectBounds.top + objectBounds.height)

                o.top = o.top + dy

                o.setCoords()

            })


            activeObject = this.createSelectionGroup(canvas, objectsInGroup)


            canvas.renderAll()

            canvas.calcOffset()


            this.notifyModified(canvas, activeObject)

        }
    },

    onAlignRightButtonClick: function(button, e, eOpts) {
        var canvas = RolandKioskPrint.AppData.getCanvas()

        var activeObject = canvas.getActiveObject()


        if (activeObject && !activeObject.isLocked && activeObject.get('type') == 'activeSelection') {
            var objectsInGroup = activeObject.getObjects()

            canvas.discardActiveObject()


            // Find the group right.
            var groupRight

            objectsInGroup.forEach(function(o) {
                var objectBounds = o.getBoundingRect(true)

                var objectRight = objectBounds.left + objectBounds.width

                if (groupRight === undefined || objectRight > groupRight) {
                    groupRight = objectRight

                }
            })


            // Move the objects.
            objectsInGroup.forEach(function(o) {
                var objectBounds = o.getBoundingRect(true)

                var dx = groupRight - (objectBounds.left + objectBounds.width)

                o.left = o.left + dx

                o.setCoords()

            })


            activeObject = this.createSelectionGroup(canvas, objectsInGroup)


            canvas.renderAll()

            canvas.calcOffset()


            this.notifyModified(canvas, activeObject)

        }
    },

    onAlignVerticalCenterButtonClick: function(button, e, eOpts) {
        this.alignHorzVertCenter(false)

    },

    onAlignHorizontalCenterButtonClick: function(button, e, eOpts) {
        this.alignHorzVertCenter(true)

    }

})

