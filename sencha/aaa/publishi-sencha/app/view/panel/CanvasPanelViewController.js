/*
 * File: app/view/panel/CanvasPanelViewController.js
 *
 * This file was generated by Sencha Architect version 4.2.4.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 6.6.x Classic library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 6.6.x Classic. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RolandKioskPrint.view.panel.CanvasPanelViewController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.panel.canvaspanel',

    setCanvasAttributes: function(canvas, previewCanvas, panCanvas) {
        // Set fabric custom attributes here.
        canvas.preserveObjectStacking = true
 // Ensures that objects remain in current stack position when selected
        canvas.controlsAboveOverlay = true
	// Ensures that the object selection handles draw outside margins as well
        canvas.rotationFeedback = true
 // Show rotation feedback on the main canvas

        // Debug
        //canvas.backgroundColor = 'orange'


        // Customize object controls.
        var isDeviceTabOrPhone = (Ext.os.deviceType == 'Tablet' || Ext.os.deviceType == 'Phone')

        fabric.Object.prototype.set({
            borderColor: '#3399FF',
            cornerColor: '#99CCFF',
            cornerStrokeColor: '#3399FF',
            cornerStyle: 'circle',
            cornerSize: isDeviceTabOrPhone ? 11 : 8,
            cornerHitTolerance: Ext.supports.TouchEvents ? 3 : 1,
            transparentCorners: false
        })


        var cornerSettings = {
            cornerSize: isDeviceTabOrPhone ? 33 : 24,
            cornerStrokeColor: '#CBCED0',
            cornerColor: 'white',
            cornerPadding: 10,
            cornerHitTolerance: 1
        }


        fabric.Object.prototype.customiseControlsAppearance({
            mtr: {
                icon: 'resources/icons/rotate.svg',
                settings: cornerSettings
            },
            br: {
                icon: 'resources/icons/resize.svg',
                settings: cornerSettings
            },
            bl: {
                icon: 'resources/icons/unlocked.svg',
                settings: cornerSettings
            }
        })


        // Add the adornments.
        var me = this

        fabric.Object.prototype.addSelectionAdornment('noColor', {
                boxSize: 20,
                fillColor: '#FFFFFF',
                strokeColor: '#CBCED0',
                padding: 4
            },
            me.shouldDrawAdornment.bind(me),
            me.drawAdornment.bind(me)
        )


        fabric.Object.prototype.addSelectionAdornment('varnish', {
                boxSize: 20,
                fillColor: '#FFFFFF',
                strokeColor: '#CBCED0',
                padding: 4
            },
            me.shouldDrawAdornment.bind(me),
            me.drawAdornment.bind(me)
        )


        fabric.CurvedText.prototype.delegatedProperties.fillSharpness = true

        fabric.CurvedText.prototype.delegatedProperties.strokeSharpness = true


        fabric.Object.prototype.noColorIcon =
            this.loadIcon('resources/images/SpecialEffect_NotPrint.png')

        fabric.Object.prototype.glossIcon =
            this.loadIcon('resources/images/SpecialEffect_Gloss.png')

        fabric.Object.prototype.matteIcon =
            this.loadIcon('resources/images/SpecialEffect_Matte.png')

        fabric.Object.prototype.textureIcon =
            this.loadIcon('resources/images/SpecialEffect_Texture.png')


        // Add crop control for images and clipping groups.
        fabric.Image.prototype.customiseControlsAppearance({
            tr: {
                icon: 'resources/icons/crop.svg',
                settings: cornerSettings
            },
            tl: {
                icon: 'resources/icons/sliders.svg',
                settings: cornerSettings,
                enabledCallback: function(target) {
                    var printType = target.printType

                    return (printType == RolandKioskPrint.app.constants.PRINT_TYPE_METAL ||
                           printType == RolandKioskPrint.app.constants.PRINT_TYPE_FOIL)

                }
            }
        })


        fabric.ClippingGroup.prototype.customiseControlsAppearance({
            tr: {
                icon: 'resources/icons/crop.svg',
                settings: cornerSettings
            },
            tl: {
                icon: 'resources/icons/sliders.svg',
                settings: cornerSettings,
                enabledCallback: function(target) {
                    var printType = target.printType

                    return (printType == RolandKioskPrint.app.constants.PRINT_TYPE_METAL ||
                           printType == RolandKioskPrint.app.constants.PRINT_TYPE_FOIL)

                }
            }
        })


        // Call on canvas instance, and not on Canvas.prototype.
        // setCanvasAttributes gets called twice, once for the product
        // designer canvas, and again for the product model designer canvas.
        // This ensure we get appropriate 'me' and canvas objects in the
        // acion callback below.
        canvas.customiseControlsBehaviour({
            // Lock/Unlock
            bl: {
                cursor: 'pointer',
                actionSupported: true,
                actionDisabled: false,
                action: function(e, target) {
                    var lock = !target.isLocked

                    target.set({
                        'isLocked': lock
                    })


                    me.setLockedProperties(target, true)

                    canvas.fire('object:modified', {target: target})

                    canvas.fire('selection:updated', {target: target})

                }
            },
            // Crop
            tr: {
                cursor: 'pointer',
                actionSupported: function(target) {
                    var type = target.get('type')

                    return type == 'image' || type == 'clippingGroup'

                },
                actionDisabled: false,
                action: function(e, target) {
                    var type = target.get('type')

                    if (type == 'image') {
                        var undoRedoPanel = RolandKioskPrint.AppData.getUndoRedoPanel()

                        undoRedoPanel.getController().mute()


                        canvas.renderOnAddRemove = false


                        // Create a clipping group for the image object.
                        var index = canvas.getObjects().indexOf(target)

                        canvas.remove(target)


                        // If the image is clipped by edit area, clip the group too.
                        target.clipTo = null

                        var group = fabric.createRectClippingGroup(target)

                        if (target.editAreaId) {
                            group.editAreaId = target.editAreaId

                            me.setClipToEditArea(group)

                            target.editAreaId = null

                        }

                        // Copy cotodesign specific properties.
                        group.sourceType = target.sourceType

                        group.printType = target.printType


                        if (target.id == 'background') {
                            group.set({
                                id: 'background',
                                skipDrawing: true
                            })

                        }

                        canvas.insertAt(group, index)

                        canvas.setActiveObject(group)

                        canvas.renderOnAddRemove = true


                        group.startClipping()

                        canvas.renderAll()

                    } else if (type == 'clippingGroup') {
                        target.startClipping()

                    }
                }
            },
            // Image edit
            tl: {
                cursor: 'pointer',
                actionSupported: function(target) {
                    var type = target.get('type'),
                        printType = target.get('printType')

                    return (type == 'image' || type == 'clippingGroup') &&
                        (printType == RolandKioskPrint.app.constants.PRINT_TYPE_METAL ||
                         printType == RolandKioskPrint.app.constants.PRINT_TYPE_FOIL)

                },
                actionDisabled: false,
                action: function(e, target) {
                    me.adjustImage(target)

                }
            }
        })


        var view = this.getView()


        // Register for canvas notifications.
        if (!this.onCanvasEvents) {
            var onCanvasEvents = {
                'selection:created': function() {
                    me.updateSelectionState()

                },
                'selection:updated': function() {
                    me.updateSelectionState()

                },
                'object:scaling': function(event) {
                    me.onObjectScaling(event.target)

                },
                'clipping:start': function(event) {
                    me.onClippingStart(event.target)

                },
                'clipping:end': function(event) {
                    me.onClippingEnd(event.target)

                }
            }


            if (view.clientPanel) {
                onCanvasEvents['object:scaled'] = function(event) {
                    var object = event.target

                    object.effectiveWidth = undefined

                    object.effectiveHeight = undefined

                    object.effectiveCenterPoint = undefined

                }

                onCanvasEvents['object:moved'] = function(event) {
                    var object = event.target

                    object.effectiveCenterPoint = undefined

                }

            }
            this.onCanvasEvents = onCanvasEvents

        }
        canvas.on(this.onCanvasEvents)


        // Defines the number of fraction digits to use when serializing object values.
        fabric.Object.NUM_FRACTION_DIGITS = 6


        // Disable WebGL image filtering.
        // Try enabling when we have shaders for BlackWhite and Tint filters in place.
        fabric.enableGLFiltering = false


        // Set the canvas clip callback.
        canvas.clipTo = previewCanvas.clipTo = function(ctx) {
            me.clipCanvas(ctx, this)

        }


        // Set the draw custom background callback.
        canvas.renderCustomBackground = previewCanvas.renderCustomBackground = function(ctx) {
            me.drawCustomBackground(ctx, this)

        }


        // Set the draw custom overlay callback.
        canvas.renderCustomOverlay = previewCanvas.renderCustomOverlay = function(ctx) {
            me.drawCustomOverlay(ctx, this)

        }


        // Now set the main canvas only callbacks.

        // Set the object allow move callback.
        canvas.allowObjectMove = function(object, newLeft, newTop) {
            return me.allowObjectMove(object, newLeft, newTop)

        }


        // Set the prune group selection callback.
        canvas.pruneGroupSelection = function(objects) {
            me.pruneGroupSelection(objects)

        }


        // Set the object lowest/highest index callbacks.
        canvas.getLowestObjectIndex = function(object) {
            return me.getLowestObjectIndex(object)

        }


        canvas.getHighestObjectIndex = function(object) {
            return me.getHighestObjectIndex(object)

        }


        // Set the object badge related callbacks.
        canvas.drawObjectBadge = function(ctx, object) {
            me.drawObjectBadge(ctx, object)

        }


        canvas.hitTestObjectBadge = function(object, pointer) {
            return me.hitTestObjectBadge(object, pointer)

        }


        canvas.performObjectBadgeAction = function(object, badge) {
            return me.performObjectBadgeAction(object, badge)

        }


        canvas.shouldCacheGroup = function(object) {
            return me.shouldCacheGroup(object)

        }


        // Define the imprint area classes.
        this.defineFoilImprintFabricClass()

        this.defineMetalImprintFabricClass()


        // Define the background grid class.
        this.defineBackgroundGridFabricClass()


        // Define the image adjust filter.
        this.defineImageAdjustFilter()


        // Set listener to render the preview canvas.
        canvas.on('after:render', me.refreshPreviewPanel.bind(me))


        // Add pan rect to the pan canvas.
        var zoomRect = new fabric.Rect({
            left: 0,
            top: 0,
            width: 0,
            height: 0,
            hasControls: false,
            hasBorders: false,
            lockRotation: true,
            lockScalingX: true,
            lockScalingY: true,
            lockSkewingX: true,
            lockSkewingY: true,
            fill: '',
            stroke: 'red',
            strokeWidth: 0,
            deviceStroke: true,
            deviceStrokeWidth: 1,
            objectCaching: false
        })


        panCanvas.add(zoomRect)


        zoomRect.on('moving', function(options) {
            var object = options.target

            if (object.left < 0) {
                object.set('left', 0)

            }
            if (object.top < 0) {
                object.set('top', 0)

            }
            if (object.left + object.width > panCanvas.width) {
                object.set('left', panCanvas.width - object.width)

            }
            if (object.top + object.height > panCanvas.height) {
                object.set('top', panCanvas.height - object.height)

            }
            me.transformCanvasViewport(object.left, object.top)

        })


        var img = new Image()

        img.onload = function() {
            me.warningIcon = img

        }

        img.src = 'resources/icons/warning.svg'


        this.loadEditAreaImage('resources/icons/image-area.svg',
                               RolandKioskPrint.app.getString('label.designer.imageAreaTipText', view.clientPanel),
                               RolandKioskPrint.app.constants.EDIT_AREA_IMAGE)

        this.loadEditAreaImage('resources/icons/text-area.svg',
                               RolandKioskPrint.app.getString('label.designer.textAreaTipText', view.clientPanel),
                               RolandKioskPrint.app.constants.EDIT_AREA_TEXT)

        this.loadEditAreaImage('resources/icons/free-area.svg',
                               RolandKioskPrint.app.getString('label.designer.freeAreaTipText', view.clientPanel),
                               RolandKioskPrint.app.constants.EDIT_AREA_FREE)

        this.loadEditAreaImage('resources/icons/foil-area.svg',
                               RolandKioskPrint.app.getString('label.designer.foilAreaTipText', view.clientPanel),
                               RolandKioskPrint.app.constants.EDIT_AREA_FOIL)

        this.loadEditAreaImage('resources/icons/metal-area.svg',
                               RolandKioskPrint.app.getString('label.designer.metalAreaTipText', view.clientPanel),
                               RolandKioskPrint.app.constants.EDIT_AREA_METAL)

        this.loadEditAreaImage('resources/icons/cut-area.svg',
                               RolandKioskPrint.app.getString('label.designer.cutAreaTipText', view.clientPanel),
                               RolandKioskPrint.app.constants.EDIT_AREA_CUT)

    },

    refreshPreviewPanel: function() {
        if (this.previewCanvasHidden || this.previewCanvasHiddenOverride) {
            return

        }

        // Draw the preview canvas with objects from the main canvas.
        var objects = this.canvas.getObjects().concat(),
            me = this


        objects.forEach(function(object) {
            object.previewCanvas = me.previewCanvas

        })


        this.previewCanvas._objects = objects

        this.previewCanvas.renderAll()


        objects.forEach(function(object) {
            delete object.previewCanvas

        })

    },

    loadEditAreaImage: function(path, text, editAreaType) {
        var img = new Image()

        var me = this

        if (!this.editAreaBadge) {
            this.editAreaBadge = {}

        }
        img.onload = function() {
            me.editAreaBadge[editAreaType] = {
                icon: img,
                text: text
            }

        }

        img.src = path

    },

    drawObjectBadge: function(ctx, object) {
        if (this.drawingPreview) {
            return
 // Don't draw badge when drawing the thumbnail
        }

        if (object.previewCanvas) {
            return
 // Don't draw badge in the pan canvas
        }

        if (this.canDrawLowResBadge(object) && this.isLowResImage(object)) {
            this.drawLowResBadge(ctx, object)

        } else if (object.editAreaType && this.isEditAreaEmpty(object)) {
            this.drawEditAreaBadge(ctx, object)

        }
    },

    drawLowResBadge: function(ctx, object) {
        // Draw the badge.
        // Skip when the image is being cropped.
        if (object.type == 'clippingGroup' && object.getClipMode()) {
            return

        }

        var bounds = this.getBadgeBounds(object, RolandKioskPrint.app.constants.LOW_RES_BADGE_SIZE)

        if (this.warningIcon) {
            ctx.drawImage(this.warningIcon, bounds.left, bounds.top, bounds.width, bounds.height)

        }
    },

    drawEditAreaBadge: function(ctx, object) {
        var dim = object._getTransformedDimensions()

        var badgeSize = dim.y * RolandKioskPrint.app.constants.EDIT_AREA_BADGE_ICON_SIZE_FRACTION

        var rr = object.canvas.viewportTransform[0]


        var minBadgeSize = RolandKioskPrint.app.constants.EDIT_AREA_BADGE_ICON_SIZE_MIN / rr, // Take viewport transform into account
            maxBadgeSize = RolandKioskPrint.app.constants.EDIT_AREA_BADGE_ICON_SIZE_MAX / rr


        if (badgeSize < minBadgeSize) {
            badgeSize = minBadgeSize

        } else if (badgeSize > maxBadgeSize) {
            badgeSize = maxBadgeSize

        }

        var editAreaType = object.editAreaType

        if (this.editAreaBadge) {
            var icon = this.editAreaBadge[editAreaType].icon,
                text = this.editAreaBadge[editAreaType].text,
                textFontSize


            // Get the badge bounds.
            var bounds = this.getBadgeBounds(object, 0)


            // Icon bounds.
            var imageLeft = bounds.left - badgeSize / 2,
                imageTop = bounds.top - badgeSize / 2


            // Uncomment the code below to suppress placeholder text drawing for small edit area objects.
            var canDrawText = true

            //var canDrawText = (badgeSize * 3 <= dim.x && badgeSize * 3 <= dim.y)


            // Compute the placeholder text size.
            var isProductDesigner = RolandKioskPrint.AppData.isProductDesigner()

            if (isProductDesigner && canDrawText) {
                var minFontSize = RolandKioskPrint.app.constants.EDIT_AREA_BADGE_FONT_SIZE_MIN / rr,  // Take viewport transform into account
                    maxFontSize = RolandKioskPrint.app.constants.EDIT_AREA_BADGE_FONT_SIZE_MAX / rr,
                    lineHeightFactor = 1.25
 // line-height to font-size ratio

                var lineHeight = dim.y * RolandKioskPrint.app.constants.EDIT_AREA_BADGE_TEXT_SIZE_FRACTION

                textFontSize = lineHeight / lineHeightFactor


                if (textFontSize < minFontSize) {
                    textFontSize = minFontSize

                } else if (textFontSize > maxFontSize) {
                    textFontSize = maxFontSize

                }

                ctx.font = textFontSize + "px Arial"

                ctx.fillStyle = RolandKioskPrint.app.constants.EDIT_AREA_BADGE_TEXT_COLOR


                // Adjust icon position above text.
                var numLines = this.wrapText(ctx, text, 0, 0, dim.x, textFontSize, true)
 // Don't draw
                imageTop -= (numLines * textFontSize) / 2

            }

            ctx.drawImage(icon, imageLeft, imageTop, badgeSize, badgeSize)


            if (isProductDesigner && canDrawText) {
                // Draw the placeholder text.
                var textLeft = imageLeft + badgeSize / 2,
                    textTop = imageTop + 2 * badgeSize


                this.wrapText(ctx, text, textLeft, textTop, dim.x, textFontSize)

            }
        }
    },

    wrapText: function(ctx, text, x, y, maxWidth, lineHeight, skipDrawing) {
        var words = text.split(' '),
            line = '',
            lineWidth = 0,
            numLines = 0


        var spaceWidth = ctx.measureText(' ').width
 // width of space

        // Loop over all words breaking those into lines.
        for (var n = 0
 n < words.length; n++) {
            var wordWidth = ctx.measureText(words[n]).width
 // get the word width

            var testLine = line + words[n] + ' '

            var testWidth = lineWidth + wordWidth + spaceWidth


            if (testWidth > maxWidth && n > 0) {
                if (!skipDrawing) {
                    ctx.fillText(line, -(lineWidth - spaceWidth) / 2 + x, y)

                }
                line = words[n] + ' '

                lineWidth = wordWidth + spaceWidth

                y += lineHeight

                ++numLines

            }
            else {
                line = testLine

                lineWidth = testWidth

            }
        }

        if (!skipDrawing) {
            ctx.fillText(line, -(lineWidth  - spaceWidth) / 2 + x, y)

        }

        return ++numLines

    },

    isEditAreaEmpty: function(editArea) {
        var objects = this.canvas.getObjects(),
            isEmpty = true


        var index = objects.indexOf(editArea)

        if (index < objects.length - 1) {
            // Check if the next object belongs to this edit area.
            isEmpty = (objects[index + 1].editAreaId != editArea.id)

        }
        return isEmpty

    },

    getBadgeBounds: function(object, badgeSize) {
        // Returns the badge bounds in fabric absolute coords.
        var options = fabric.util.qrDecompose(object.calcTransformMatrix())

        var matrix = [1, 0, 0, 1, options.translateX, options.translateY]


        var rr = object.canvas.viewportTransform[0]

        var dim = object._getTransformedDimensions()

        var size = badgeSize / rr

        size = Math.min(size, dim.x, dim.y)


        var p1 = {
            x: -size / 2,
            y: -size / 2
        }

        p1 = fabric.util.transformPoint(p1, matrix)


        var p2 = {
            x: size / 2,
            y: size / 2
        }

        p2 = fabric.util.transformPoint(p2, matrix)


        return {
            left: p1.x,
            top: p1.y,
            right: p2.x,
            bottom: p2.y,
            width: p2.x - p1.x,
            height: p2.y - p1.y
        }

    },

    hitTestObjectBadge: function(object, pointer) {
        var hit = false


        // Only low resolution badge on images is interactive for now.
        var me = this

        this.enumerateObjectsReverse(object, function(o) {
            if (me.canDrawLowResBadge(o) && me.isLowResImage(o)) {
                if (o.type == 'clippingGroup' && o.getClipMode()) {
                    return !hit

                }

                // Get the badge bounds and check if the point lies within those.
                var badgeBounds = me.getBadgeBounds(o, RolandKioskPrint.app.constants.LOW_RES_BADGE_SIZE)


                if (badgeBounds.left <= pointer.x &&
                    pointer.x <= badgeBounds.right &&
                    badgeBounds.top <= pointer.y &&
                    pointer.y <= badgeBounds.bottom) {
                    hit = 'lowres'

                }
            }

            return !hit
 // Keep enumerating
        })


        return hit

    },

    performObjectBadgeAction: function(object, badge) {
        if (badge == 'lowres') {
            Ext.Msg.show({
                title: RolandKioskPrint.app.getString('message.generic.warning'),
                msg: RolandKioskPrint.app.getString('message.designer.lowResolutionObjectWarning'),
                buttonText: {
                    ok: RolandKioskPrint.app.getString('label.button.ok')
                },
                icon: Ext.MessageBox.WARNING
            })


            return true

        }
    },

    canDrawLowResBadge: function(object) {
        // Must be a non-background image.
        if ((object.type != 'image' && object.type != 'clippingGroup') || object.id == 'background') {
            return false

        }

        // For cropped images (clipping group), we draw the badge on the group.
        if (object.group && object.group.type == 'clippingGroup') {
            return false

        }

        if (object.type == 'clippingGroup') {
            object = object.getElement()

        }

        // Check if image has the right source type.
        var isProductDesigner = RolandKioskPrint.AppData.isProductDesigner()


        var sourceType = (
            isProductDesigner ? RolandKioskPrint.app.constants.OBJECT_SOURCE_PD
                              : RolandKioskPrint.app.constants.OBJECT_SOURCE_PMD
        )


        if (object.sourceType != sourceType && !(isProductDesigner && this.isObjectWithinEditArea(object))) {
            return false

        }

        if (!object.origHeight || !object.origWidth) {
            // Original dimensions of the image are not available.
            // Can't do anything.
            return false

        }

        return true

    },

    isLowResImage: function(object) {
        if (object.type == 'clippingGroup') {
            object = object.getElement()

        }

        // Check if the image has a low effective resolution.
        var isLowRes = object.isLowRes

        if (isLowRes === undefined) {
            isLowRes = this.computeImageIsLowRes(object)

        }

        return isLowRes

    },

    getObjectsCoverage: function() {
        function getArea(object) {
            // Compute the object area. Handle rotation and sub-object cases.
            var matrix = object.calcTransformMatrix(),
                options = fabric.util.qrDecompose(matrix)


            var scaledHeight = object.height * options.scaleY,
                scaledWidth = object.width * options.scaleX


            return scaledHeight * scaledWidth

        }

        var me = this,
            imageCoverage = 0,
            textCoverage = 0,
            objects = this.canvas.getObjects()


        objects.forEach(function(object) {
            me.enumerateObjects(object, function(o) {
                if ((o.type == 'image' || o.type == 'clippingGroup') &&
                    o.id != 'background') {
                    if (o.type == 'clippingGroup') {
                        o = o.getClip()

                    }
                    imageCoverage += getArea(o)

                } else if (o.type == 'text') {
                    textCoverage += getArea(o)

                }
                return true
 // keep enumerating
            })

        })


        return {
            text: textCoverage,
            image: imageCoverage
        }

    },

    enumerateObjects: function(object, callback, includeGroups, descendPathGroups) {
        var keepEnumerating = true

        if (object.type == 'group' && (!object.isPathGroup || descendPathGroups)) {
            if (includeGroups) {
                keepEnumerating = callback(object)

            }

            var objects = object.getObjects()

            for (var i = 0, length = objects.length
 keepEnumerating && i < length; i++) {
                keepEnumerating = this.enumerateObjects(objects[i], callback, includeGroups, descendPathGroups)

            }
        } else {
            keepEnumerating = callback(object)

        }

        return keepEnumerating

    },

    enumerateObjectsReverse: function(object, callback) {
        var keepEnumerating = true

        if (object.type == 'group' && !object.isPathGroup) {
            var objects = object.getObjects()

            for (var i = objects.length - 1
 keepEnumerating && i >= 0; --i) {
                keepEnumerating = this.enumerateObjects(objects[i], callback)

            }
        } else {
            keepEnumerating = callback(object)

        }

        return keepEnumerating

    },

    hasLowResImage: function(object) {
        var isLowRes = false


        var me = this

        this.enumerateObjects(object, function(o) {
            if (me.canDrawLowResBadge(o) && me.isLowResImage(o)) {
                isLowRes = true

            }
            return !isLowRes
 // Stop enumerating when a low res image is found
        })


        return isLowRes

    },

    onObjectScaling: function(object) {
        var me = this,
            objects = [object]


        if (object.type == 'activeSelection') {
            objects = object.getObjects()

        }

        objects.forEach(function(object) {
            me.enumerateObjects(object, function(o) {
                if (me.canDrawLowResBadge(o)) {
                    if (o.type == 'clippingGroup') {
                        o = o.getElement()

                    }

                    // Re-compute the low resolution flag.
                    me.computeImageIsLowRes(o)

                }
                if (o.type == 'text' || o.type == 'curved-text') {
                    // Update the object's initial scaling values.
                    o.set({
                        'startScaleX': o.scaleX,
                        'startScaleY': o.scaleY
                    })

                }
                return true

            })

        })

    },

    getHasLowResImages: function() {
        var objects = this.canvas.getObjects()

        var hasLowResImage = false


        for (var i = 0, length = objects.length
 i < length && !hasLowResImage; ++i) {
            hasLowResImage = this.hasLowResImage(objects[i])

        }

        return hasLowResImage

    },

    computeImageIsLowRes: function(object) {
        // Compute the image object's effective DPI.
        // For that we first compute the object's final scaled dimensions.
        var dim = object._getNonTransformedDimensions(),
            m = object.calcTransformMatrix(),
            options = fabric.util.qrDecompose(m)

        var scaleMatrix = [options.scaleX, 0, 0, options.scaleY, 0, 0]


        var p1 = {
            x: -dim.x / 2,
            y: -dim.y / 2
        }

        p1 = fabric.util.transformPoint(p1, scaleMatrix)


        var p2 = {
            x: dim.x / 2,
            y: dim.y / 2
        }

        p2 = fabric.util.transformPoint(p2, scaleMatrix)


        dim = {
            x: Math.abs(p1.x - p2.x),
            y: Math.abs(p1.y - p2.y)
        }


        var xDPI = object.origWidth * 25.4 / dim.x,
            yDPI = object.origHeight * 25.4 / dim.y


        var minDPI = RolandKioskPrint.app.constants.MIN_IMAGE_DPI

        object.isLowRes = (xDPI < minDPI || yDPI < minDPI)


        return object.isLowRes

    },

    fixupImageObject: function(object, imageList) {
        var objectSrc = object.getSrc()

        var found = false

        for (var i = 0
 i < imageList.length; ++i) {
            var imgData = imageList[i]

            if (objectSrc.indexOf(imgData.thumbPath) >= 0) {
                object.origHeight = imgData.origHeight

                object.origWidth = imgData.origWidth

                found = true

                break

            }
        }
        return found

    },

    shouldCacheGroup: function(object) {
        if (!this.hasLowResImage(object)) {
            return true

        }

        return false

    },

    recalcCanvasLayout: function() {
        // Resize the canvas to fill the entire panel.
        var canvasPanel = this.getView()


        var panelWidth = canvasPanel.getWidth()

        var panelHeight = canvasPanel.getHeight()


        var canvasContainer = canvasPanel.down('#canvasContainer')

        canvasContainer.setWidth(panelWidth)

        canvasContainer.setHeight(panelHeight)

        canvasContainer.setX(canvasPanel.getX())

        canvasContainer.setY(canvasPanel.getY())


        // Set the viewport bounds.
        this.canvas.setDimensions({
            width: panelWidth,
            height: panelHeight
        })


        this.transformCanvasViewport()

    },

    transformCanvasViewport: function(left, top) {
        var canvasPanel = this.getView()


        var panelWidth = canvasPanel.getWidth()

        var panelHeight = canvasPanel.getHeight()


        // Leave 5% margins on all side.
        var canvasWidth = panelWidth * 0.9

        var canvasHeight = panelHeight * 0.9


        // Compute the product size including negative margins, if any.
        var data = this.productSizeData

        var productBounds = {
            left: 0,
            top: 0,
            right: data.widthMM,
            bottom: data.heightMM,
            width: data.widthMM,
            height: data.heightMM
        }


        var marginBounds = {
            left: data.leftMarginMM,
            top: data.topMarginMM,
            right: data.widthMM - data.rightMarginMM,
            bottom: data.heightMM - data.bottomMarginMM,
        }


        var totalBounds = this.getUnionBounds(productBounds, marginBounds)


        // Include the imprint area if it exceeds the product bounds.
        var imprintArea, imprintAreaBounds

        var drawFullImprintArea,
            printType


        if (this.drawingPreview) {
            printType = this.drawingThumbPrintType

            drawFullImprintArea =
                RolandKioskPrint.AppData.isProductDesigner() &&
                (printType == RolandKioskPrint.app.constants.PRINT_TYPE_FOIL ||
                 printType == RolandKioskPrint.app.constants.PRINT_TYPE_METAL)

        } else {
            printType = RolandKioskPrint.AppData.getActivePrintType()

            drawFullImprintArea =
                RolandKioskPrint.AppData.isProductModelDesigner() &&
                RolandKioskPrint.AppData.isActivePrintTypeFoilOrMetal()


        }

        if (drawFullImprintArea) {
            imprintArea = this.getImprintArea(printType)

            if (imprintArea) {
                imprintAreaBounds = this.getBoundingRect(imprintArea)

                totalBounds = this.getUnionBounds(totalBounds, imprintAreaBounds)

            }
        }

        var totalWidth = totalBounds.width

        var totalHeight = totalBounds.height


        var rx = canvasWidth / totalWidth

        var ry = canvasHeight / totalHeight


        var rr = (rx < ry) ? rx : ry


        // Scale accordingly if not drawing preview.
        if (!this.drawingPreview) {
            rr *= this.currentZoomLevel

            panelWidth *= this.currentZoomLevel

            panelHeight *= this.currentZoomLevel

        }

        canvasWidth = Math.ceil(totalWidth * rr)

        canvasHeight = Math.ceil(totalHeight * rr)


        this.canvasX = (panelWidth - canvasWidth) / 2 + (totalBounds.left > 0 ? 0 : Math.abs(totalBounds.left) * rr)

        this.canvasY = (panelHeight - canvasHeight) / 2 + (totalBounds.top > 0 ? 0 : Math.abs(totalBounds.top) * rr)


        // Add adjustment for zoom rect bounds, if required.
        var canvas = this.canvas

        var panCanvas = this.panCanvas


        var oldVisibility = this.previewCanvasContainer.style.visibility || 'hidden'

        var newVisibility = (this.previewCanvasHidden || this.previewCanvasHiddenOverride) ? 'hidden' : 'visible'


        this.previewCanvasContainer.style.visibility = newVisibility

        var reset = oldVisibility != newVisibility


        var panCanvasNewWidth = Math.floor(canvas.width / this.mainToPreviewCanvasSizeRatio)

        var panCanvasNewHeight = Math.floor(canvas.height / this.mainToPreviewCanvasSizeRatio)


        var resizing = (panCanvas.width != panCanvasNewWidth || panCanvas.height != panCanvasNewHeight)

        var movingZoomRect = false


        if (typeof left != 'undefined' && typeof top != 'undefined') {
            this.canvasX -= (left * this.mainToPreviewCanvasSizeRatio * this.currentZoomLevel)

            this.canvasY -= (top * this.mainToPreviewCanvasSizeRatio * this.currentZoomLevel)

            movingZoomRect = true

        } else if (!this.drawingPreview) {
            var zoomRectBounds = this.getNextZoomRectBounds({reset: reset, resizing: resizing})

            this.canvasX -= (zoomRectBounds.left * this.mainToPreviewCanvasSizeRatio * this.currentZoomLevel)

            this.canvasY -= (zoomRectBounds.top * this.mainToPreviewCanvasSizeRatio * this.currentZoomLevel)

        }

        canvas.setViewportTransform([rr, 0, 0, rr, this.canvasX, this.canvasY])


        // Adjust the linked preview canvas, if required.
        if (!this.drawingPreview && !movingZoomRect) {
            this.recalcPreviewCanvasLayout(totalBounds, zoomRectBounds, reset)

        }

        var productWidth = productBounds.width

        var productHeight = productBounds.height


        if (imprintArea) {
            totalBounds = this.getUnionBounds(productBounds, imprintAreaBounds)

            productWidth = totalBounds.width

            productHeight = totalBounds.height


            this.canvasX += totalBounds.left * rr

            this.canvasY += totalBounds.top * rr

        }

        this.canvasWidth = Math.ceil(productWidth * rr)

        this.canvasHeight = Math.ceil(productHeight * rr)

    },

    recalcPreviewCanvasLayout: function(totalBounds, zoomRectBounds, reset) {
        var canvas = this.canvas

        var previewCanvasContainer = this.previewCanvasContainer


        // Compute and set the preview container dimensions.
        var panelWidth = Math.floor(canvas.width / this.mainToPreviewCanvasSizeRatio)

        var previewHeight = Math.floor(canvas.height / this.mainToPreviewCanvasSizeRatio)

        var panelHeight = previewHeight + RolandKioskPrint.app.constants.PREVIEW_CANVAS_LABEL_HEIGHT
 // Adding label height

        previewCanvasContainer.style.width = panelWidth + 'px'

        previewCanvasContainer.style.height = panelHeight + 'px'


        // Position the preview container.
        var padding = RolandKioskPrint.app.constants.PREVIEW_CANVAS_PADDING

        previewCanvasContainer.style.left = (canvas.width - panelWidth - 2 - padding) + 'px'

        previewCanvasContainer.style.top = padding + 'px'


        // Set the dimensions for the contained canvas elements.
        var previewCanvas = this.previewCanvas

        var panCanvas = this.panCanvas


        previewCanvas.lowerCanvasEl.parentElement.style.height = previewHeight + 'px'

        previewCanvas.setDimensions({
            width: panelWidth,
            height: previewHeight
        })


        panCanvas.setDimensions({
            width: panelWidth,
            height: previewHeight
        })


        // Set the dimensions for container label.
        var previewCanvasLabel = this.previewCanvasLabel

        previewCanvasLabel.style.top = previewHeight + 'px'

        previewCanvasLabel.style.width = panelWidth + 'px'

        previewCanvasLabel.style.height = RolandKioskPrint.app.constants.PREVIEW_CANVAS_LABEL_HEIGHT + 'px'


        var rr = canvas.viewportTransform[0] / (this.currentZoomLevel * this.mainToPreviewCanvasSizeRatio)

        var canvasWidth = Math.ceil(totalBounds.width * rr)

        var canvasHeight = Math.ceil(totalBounds.height * rr)


        var tx = (panelWidth - canvasWidth) / 2 + (totalBounds.left > 0 ? 0 : Math.abs(totalBounds.left) * rr)

        var ty = (previewHeight - canvasHeight) / 2 + (totalBounds.top > 0 ? 0 : Math.abs(totalBounds.top) * rr)


        previewCanvas.setViewportTransform([rr, 0, 0, rr, tx, ty])


        var zoomRect = panCanvas.getObjects()[0]

        zoomRect.animate(
            {
                left: zoomRectBounds.left,
                top: zoomRectBounds.top,
                width: zoomRectBounds.width,
                height: zoomRectBounds.height
            },
            {
                duration: (reset ? 2 : 200),
                onChange: panCanvas.renderAll.bind(panCanvas),
                onComplete: function() {},
                easing: fabric.util.ease.easeInQuad
            }
        )

    },

    getBoundingRect: function(object) {
        var originalValues = this.canvas._realizeGroupTransformOnObject(object)

        if (originalValues) {
            object.setCoords()

        }

        var bounds = object.getBoundingRect(true)

        bounds.right = bounds.left + bounds.width

        bounds.bottom = bounds.top + bounds.height


        this.canvas._unwindGroupTransformOnObject(object, originalValues)

        if (originalValues) {
            object.setCoords()

        }

        return bounds

    },

    getUnionBounds: function(a, b) {
        var bounds = {
            left: (a.left < b.left) ? a.left : b.left,
            top: (a.top < b.top) ? a.top : b.top,
            right: (a.right > b.right) ? a.right : b.right,
            bottom: (a.bottom > b.bottom) ? a.bottom : b.bottom
        }


        bounds.width = bounds.right - bounds.left

        bounds.height = bounds.bottom - bounds.top


        return bounds

    },

    clipCanvas: function(ctx, canvas) {
        // The clipCanvas function gets called from fabric.js at the start of a drawing cycle.
        // This function is responsible for establishing the clip path for the drawing.

        // Some general notes about the implementation.
        // Since this callback is called without the canvas viewport transform in
        // place, we need to take care of the canvas viewport scaling here.
        // Besides drawing the clip area, the callback also leaves the clip path stroke
        // in ctx, which gets set as the canvas clip on return from this function.

        var data = this.productSizeData

        var hasCustomBackground = (this.getBackgroundObjects().length > 0)


        var drawFullImprintArea,
            printType


        if (this.drawingPreview) {
            printType = this.drawingThumbPrintType

            drawFullImprintArea =
                RolandKioskPrint.AppData.isProductDesigner() &&
                (printType == RolandKioskPrint.app.constants.PRINT_TYPE_FOIL ||
                 printType == RolandKioskPrint.app.constants.PRINT_TYPE_METAL)

        } else {
            printType = RolandKioskPrint.AppData.getActivePrintType()

            drawFullImprintArea =
                RolandKioskPrint.AppData.isProductModelDesigner() &&
                RolandKioskPrint.AppData.isActivePrintTypeFoilOrMetal()

        }

        if (drawFullImprintArea) {
        	var imprintArea = this.getImprintArea(printType)

            if (imprintArea) {
                var visibility = imprintArea.get('visible')


                // Draw the imprint area without any clipping.
                ctx.save()

                ctx.transform.apply(ctx, canvas.viewportTransform)


                if (!hasCustomBackground) {
                    ctx.fillStyle = 'white'

                    ctx.fillRect(0, 0, data.widthMM, data.heightMM)

                }

                imprintArea.set('visible', true)

                imprintArea.render(ctx)

                imprintArea.set('visible', visibility)


                ctx.restore()

            }
        }

        // Do the default fill only when we don't have a custom background.
        this.drawProductOutline(ctx, canvas, !hasCustomBackground && !drawFullImprintArea)


        var maskArea = this.getMaskArea(),
            marginArea = this.getMarginArea()


        var rr = canvas.viewportTransform[0]


        // Now draw the "margin" object.
        if (marginArea) {
            if (this.drawingPreview || (maskArea && !this.hasNegativeMargins())) {
                ctx.clip()
 // For negative margins, just clip to margin.
            }

            var stroke = 'black'

            var strokeWidth = 1 / rr

            var strokeDashArray = [5/rr, 5/rr]


            this.drawClipArea(ctx, marginArea, stroke, strokeWidth, strokeDashArray, false, canvas)

        }
    },

    drawProductOutline: function(ctx, canvas, doFill) {
        var maskArea = this.getMaskArea()

        var rr = canvas.viewportTransform[0]


        // The "mask" object if present, determines the model outline.
        if (maskArea) {
            var stroke = 'black'

            var strokeWidth = 1 / rr

            var fill = false


            if (doFill) {
                fill = 'white'

            }

            this.drawClipArea(ctx, maskArea, stroke, strokeWidth, [], fill, canvas)

        } else {
            // Otherwise, we just draw the canvas outline.
            var data = this.productSizeData


            ctx.save()

            ctx.beginPath()

            ctx.transform.apply(ctx, canvas.viewportTransform)


            var strokeWidth = 1 / rr

            this.roundedRect(ctx, strokeWidth/2, strokeWidth/2, data.widthMM - strokeWidth, data.heightMM - strokeWidth, data.cornerRadiusMM)


            if (doFill) {
                ctx.fillStyle = 'white'

                ctx.fill()

            }

            ctx.strokeStyle = 'black'

            ctx.lineWidth = 1/rr

            ctx.stroke()


            ctx.restore()

        }
    },

    roundedRect: function(ctx, x, y, width, height, radius) {
        // Create rounded rect path on the specified canvas 2D context.
        var r = Math.min(radius, width / 2, height / 2)


        ctx.beginPath()


        if (r) {
            // Code taken from fabric rounded rect render function.

            // "magic number" for bezier approximations of arcs
            var k = 1 - 0.5522847498


            ctx.moveTo(x + r, y)

            ctx.lineTo(x + width - r, y)

            ctx.bezierCurveTo(x + width - k * r, y, x + width, y + k * r, x + width, y + r)

            ctx.lineTo(x + width, y + height - r)

            ctx.bezierCurveTo(x + width, y + height - k * r, x + width - k * r, y + height, x + width - r, y + height)

            ctx.lineTo(x + r, y + height)

            ctx.bezierCurveTo(x + k * r, y + height, x, y + height - k * r, x, y + height - r)

            ctx.lineTo(x, y + r)

            ctx.bezierCurveTo(x, y + k * r, x + k * r, y, x + r, y)

        } else {
            ctx.rect(x, y, width, height)

        }
        ctx.closePath()

    },

    drawCustomBackground: function(ctx, canvas) {
        // Get the background objects.
        var objects = this.getBackgroundObjects()

        if (objects.length === 0) {
            return

        }

        // Draw the background objects with product outline as the clip.
        ctx.save()

        this.drawProductOutline(ctx, canvas, true)


        ctx.clip()

        ctx.transform.apply(ctx, canvas.viewportTransform)


        objects.forEach(function(object) {
            if (object.sourceType == RolandKioskPrint.app.constants.OBJECT_SOURCE_SVG) {
                object.set('visible', true)

                object.render(ctx)

                object.set('visible', false)

            } else {
                object.render(ctx)

            }
        })


        ctx.restore()

    },

    drawCustomOverlay: function(ctx, canvas) {
        // For the case of negative margins (borderless printing), the content
        // obscures the outline of the product. We draw the model outline one more
        // time here after all content has drawn.
        // This function lifts code from clipCanvas function's model outline drawing.

        if (!this.hasNegativeMargins()) {
            return

        }

        var maskArea = this.getMaskArea(),
            marginArea = this.getMarginArea()


        var rr = canvas.viewportTransform[0]


        // The "mask" object if present, determines the model outline.
        if (maskArea) {
            var stroke = 'black'

            var strokeWidth = 1/rr

            var fill = false


            this.drawClipArea(ctx, maskArea, stroke, strokeWidth, [], fill, canvas)

        } else {
            // Otherwise, we just draw the canvas outline.
            var data = this.productSizeData


            ctx.save()

            ctx.beginPath()

            ctx.transform.apply(ctx, canvas.viewportTransform)


            var strokeWidth = 1/rr

            this.roundedRect(ctx, strokeWidth/2, strokeWidth/2, data.widthMM - strokeWidth, data.heightMM - strokeWidth, data.cornerRadiusMM)


            ctx.strokeStyle = 'black'

            ctx.lineWidth = 1/rr

            ctx.stroke()


            ctx.restore()

        }
    },

    getCanvas: function() {
        // Returns the fabric canvas.
        return this.canvas

    },

    createImprintArea: function(printType, sourceType, x, y) {
        var canvas = this.canvas


        // Compute the position, if not specified.
        var left = x

        var top = y


        var data = this.productSizeData,
            className = 'FoilImprintArea',
            imprintAreaSize = RolandKioskPrint.app.constants.FOIL_PRINT_PRINTABLE_SIZE,
            fillColor = RolandKioskPrint.app.constants.FOIL_PRINTABLE_AREA_BACK_COLOR,
            gridColor = RolandKioskPrint.app.constants.FOIL_PRINTABLE_AREA_GRID_COLOR,
            areaId = 'foilImprintArea',
            imprintArea


        if (printType == RolandKioskPrint.app.constants.PRINT_TYPE_METAL) {
            className = 'MetalImprintArea'

            imprintAreaSize = RolandKioskPrint.app.constants.METAL_PRINT_PRINTABLE_SIZE

            fillColor = RolandKioskPrint.app.constants.METAL_PRINTABLE_AREA_BACK_COLOR

            gridColor = RolandKioskPrint.app.constants.METAL_PRINTABLE_AREA_GRID_COLOR

            areaId = 'metalImprintArea'

        }

        if (x === undefined || y === undefined) {
            // Center the foil imprint area in the product model.
            left = (data.widthMM - imprintAreaSize) / 2

            top = (data.heightMM - imprintAreaSize) / 2

        }

        var imprintArea = new fabric[className]({
            left: left,
            top: top,
            width: imprintAreaSize,
            height: imprintAreaSize,
            fill: fillColor,
            stroke: gridColor,
            id: areaId,
            sourceType: sourceType
        })


        imprintArea.on('mouseup', this.transformCanvasViewport.bind(this))


        if (sourceType == RolandKioskPrint.app.constants.OBJECT_SOURCE_SVG) {
            imprintArea.set({
                'selectable': false,
                'evented': false
            })

        }

        canvas.add(imprintArea)

        this.transformCanvasViewport()

    },

    initialize: function(parentView, productSizeData, productDesignPath) {
        // Since no data binding is required, we keep the data off the view controller itself.
        this.parentView = parentView

        this.productSizeData = productSizeData

        this.productDesignPath = productDesignPath

        this.designLoaded = false

        this.designLoading = false


        var productModelData = RolandKioskPrint.AppData.productModelData

        this.printType = productModelData.printType


        this.foilPrint = productModelData.isFoilPrint()

        this.metalPrint = productModelData.isMetalPrint()

        this.cutPrint = productModelData.isCutPrint()


        this.isProductModelDesigner =
            (RolandKioskPrint.AppData.appMode == RolandKioskPrint.app.constants.APP_MODE_PRODUCT_MODEL_DESIGNER)


        // Clear the canvas.
        this.clear()


        this.currentZoomLevel = RolandKioskPrint.app.constants.INITIAL_ZOOM_LEVEL

        this.previewCanvasHidden = (this.currentZoomLevel <= 1)

        this.initialized = true

    },

    initializeWithSVG: function(parentView, productSizeData, productDesignSVG, productDesignSVGPath, defaultSpecialColor) {
        // Since no data binding is required, we keep the data off the view controller itself.
        this.parentView = parentView

        this.productSizeData = productSizeData

        this.productDesignSVG = productDesignSVG

        this.productDesignSVGPath = productDesignSVGPath

        this.defaultSpecialColor = defaultSpecialColor

        this.designLoaded = false

        this.designLoading = false


        var productModelData = RolandKioskPrint.AppData.productModelData

        this.printType = productModelData.printType


        this.foilPrint = productModelData.isFoilPrint()

        this.metalPrint = productModelData.isMetalPrint()

        this.cutPrint = productModelData.isCutPrint()


        this.isProductModelDesigner =
            (RolandKioskPrint.AppData.appMode == RolandKioskPrint.app.constants.APP_MODE_PRODUCT_MODEL_DESIGNER)


        // Clear the canvas.
        this.clear()


        this.currentZoomLevel = RolandKioskPrint.app.constants.INITIAL_ZOOM_LEVEL

        this.previewCanvasHidden = (this.currentZoomLevel <= 1)

        this.initialized = true

    },

    terminate: function() {
        // Fire the custom finish event.
        this.canvas.fire('canvas:x-finish')


        this.productDesignPath = ''

        this.productDesignSVG = ''

        this.productDesignSVGPath = ''


        this.designLoaded = false

        this.designLoading = false

        this.clear()


        this.initialized = false

    },

    getProductSizeData: function() {
        return this.productSizeData

    },

    alignObjectWithinBounds: function(object, referenceBounds, alignment, centerVertically) {
        var objectBounds = this.getBoundingRect(object)


        var dx = 0

        if (alignment == 'left') {
            dx = referenceBounds.left - objectBounds.left

        } else if (alignment == 'center') {
            var referenceCenter = referenceBounds.left + referenceBounds.width / 2

            var objectCenter = objectBounds.left + objectBounds.width / 2

            dx = referenceCenter - objectCenter

        } else if (alignment == 'right') {
            var referenceRight = referenceBounds.left + referenceBounds.width

            var objectRight = objectBounds.left + objectBounds.width

            dx = referenceRight - objectRight

        }

        object.left = object.left + dx


        if (centerVertically) {
            var referenceMiddle = referenceBounds.top + referenceBounds.height / 2

            var objectMiddle = objectBounds.top + objectBounds.height / 2

            object.top = object.top + (referenceMiddle - objectMiddle)

        }
    },

    clear: function() {
        var canvas = this.canvas


        // Wipe clean the canvas.
        canvas.clear()


        // Clear edit area book-keeping information.
        var isProductDesigner =
            (RolandKioskPrint.AppData.appMode == RolandKioskPrint.app.constants.APP_MODE_PRODUCT_DESIGNER)


        if (isProductDesigner) {
            canvas.imageAreaList = []

            canvas.textAreaList = []

            canvas.freeAreaList = []

            canvas.foilAreaList = []

            canvas.metalAreaList = []

            canvas.cutAreaList = []

        } else {
            canvas.nextEditAreaId = 1

        }

        // Clear the preview canvas.
        this.previewCanvas.clear()

    },

    writeCanvasClipToSVG: function() {
        var maskArea = this.getMaskArea(),
            marginArea = this.getMarginArea()


        var markup = []

        if (maskArea && !this.hasNegativeMargins()) {
            markup.push('<clipPath id="svgmask">')

            maskArea.set('visible', true)

            markup.push(maskArea.toSVG())

            maskArea.set('visible', false)


            markup.push('</clipPath>')

        }

        if (marginArea) {
            markup.push('<clipPath id="svgmargin">')

            marginArea.set('visible', true)

            markup.push(marginArea.toSVG())

            marginArea.set('visible', false)


            markup.push('</clipPath>')

        }
        return markup.join('')

    },

    getCanvasClipId: function() {
        var clipIds = []


        var maskArea = this.getMaskArea(),
            marginArea = this.getMarginArea()


        if (maskArea && !this.hasNegativeMargins()) {
            clipIds.push('svgmask')

        }
        if (marginArea) {
            clipIds.push('svgmargin')

        }
        return clipIds

    },

    writeObjectClipsToSVG: function() {
        var canvas = this.canvas

        var markup = []


        var objects = canvas.getObjects()

        for (var i = 0, length = objects.length
 i < length; i++) {
            if (objects[i].editAreaType) {
                var editArea = objects[i]


                // Remove the edit area stroke and fill when writing to SVG. Restore later.
                var fill = editArea.fill

                var stroke = editArea.stroke


                editArea.fill = false

                editArea.stroke = false


                markup.push('<clipPath id="' + editArea.id + '-clip">')

                markup.push(editArea.toSVG())

                markup.push('</clipPath>')


                editArea.fill = fill

                editArea.stroke = stroke

            }
        }

        return markup.join('')

    },

    getSVG: function(printType, options) {
        var canvas = this.canvas


        canvas.writeCanvasClipPathToSVG = null

        canvas.getCanvasClipPathSVGId = null


        var me = this

        if (options.emitCanvasClip) {
            // Set the canvas clip SVG writing callback.
            canvas.writeCanvasClipPathToSVG = function() {
                return me.writeCanvasClipToSVG()

            }

            canvas.getCanvasClipPathSVGId = function() {
                return me.getCanvasClipId()

            }

        }

        var maskArea = this.getMaskArea(),
            marginArea = this.getMarginArea()


        var imprintArea

        if (printType == RolandKioskPrint.app.constants.PRINT_TYPE_FOIL ||
            printType == RolandKioskPrint.app.constants.PRINT_TYPE_METAL) {
            imprintArea = this.getImprintArea(printType)

        }

        var clipartImages,
            backgroundColor


        // For clipart images, change the background color to black.
        // Revert after exporting.
        if (printType == RolandKioskPrint.app.constants.PRINT_TYPE_METAL) {
            canvas.getUseFilteredImage = function(object) {
                return (object.getSrc().indexOf('data:') === 0)

            }


            clipartImages = this.getClipartImages(printType)


            for (var i = 0, len = clipartImages.length
 i < len; i++) {
                var filter = this.getImageFilter(clipartImages[i], 'Tint')

                if (!backgroundColor) {
                    backgroundColor = filter.color

                }
                filter.color = '#000000'

                clipartImages[i].applyFilters()

            }
        }

        if (maskArea) {
            maskArea.excludeFromExport = options.emitCanvasClip

        }

        if (marginArea) {
            marginArea.excludeFromExport = options.emitCanvasClip

        }

        if (imprintArea) {
            imprintArea.excludeFromExport = true

        }

        // Object clips.
        canvas.writeObjectClipPathsToSVG = function() {
            return me.writeObjectClipsToSVG()

        }

        canvas.getObjectClipPathSVGId = function(object) {
            if (object.clipTo && object.editAreaId) {
                return object.editAreaId + '-clip'

            }
        }


        canvas.writeColorProfilesToSVG = function() {
            // Write RDG special colors profile to SVG.
            return '<color-profile name="RDGSpecialInks" xlink:href="../../designer/resources/namedcolorprofile/RDGSpecialInks.icc"/>'

        }


        canvas.writeColorPatternsToSVG = function() {
            // Write texture patterns to SVG.
            return me.writeColorPatternsToSVG()

        }


        if (printType == RolandKioskPrint.app.constants.PRINT_TYPE_METAL ||
            printType == RolandKioskPrint.app.constants.PRINT_TYPE_FOIL) {
            canvas.writeImageFilterAttributesToSVG = function(object) {
                // Write image filter attributes.
                return me.writeImageFilterAttributesToSVG(object)

            }

        }

        if (options.suppressBgObjects) {
            this.suppressBackground(true)

        }

        this.suppressEditAreas(true)


        // Cut lines are drawn in device (pixels) space, unlike other objects which are
        // drawn in the mm units space. The deviceStrokeWidth for a cutline object specifies
        // its stroke width in pixels. The strokeWidth is set at 0, so that it does not affect
        // the bounds calculations etc.
        // However, Batik, the component used for SVG to PDF conversion, drops objects with
        // 0 stroke width. So here we emit a 1pt stroke width for the cut lines.
        var cutLines = this.getCutLines()

        this.setStrokeWidth(cutLines, RolandKioskPrint.app.constants.CUT_MINIMAL_STROKE_WIDTH)


        var svgViewBox = this.getSVGViewBox(printType)

        var svgOptions = {
            viewBox: {
                x: svgViewBox.left,
                y: svgViewBox.top,
                width: svgViewBox.width,
                height: svgViewBox.height
            },
            width: svgViewBox.width.toString() + 'mm',
            height: svgViewBox.height.toString() + 'mm',
            suppressPreamble: true
        }


        // For cut, we need to emit the bounds of the cut contents as a cut path itself.
        // We create a temporary bounds object below, add to canvas, and get its SVG.
        // Remove it when done.
        var cutBoundsObject


        if (printType == RolandKioskPrint.app.constants.PRINT_TYPE_CUT) {
            cutBoundsObject = this.createCutBoundsObject(svgViewBox)

        }

        if (printType == RolandKioskPrint.app.constants.PRINT_TYPE_METAL) {
            svgOptions.backgroundColor = '#000000'

        }

        var modelData = RolandKioskPrint.AppData.productModelData

        modelData.hasPrimerObjects = false

        modelData.hasWhiteObjects = false

        modelData.hasVarnishObjects = false


        var svg = canvas.toSVG(svgOptions,
                               function(s, object) {
            var imgsvg = '',
                replaceGlobally = (object.type == 'curved-text'),
                group = object.group


            // Replace surrogates with html entity.
            if (object.type == 'text') {
                s = s.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, function(str) {
                    var code = 0x10000

                    code += (str.charCodeAt(0) & 0x03FF) << 10

                    code += (str.charCodeAt(1) & 0x03FF)

                    return '&#x' + code.toString(16) + '
';
                })

            }

            // For image objects, we change the thumb path to original hires image.
            // Also remove the host name and port from the image url, and make it a relative path.
            // Also remove any nonce from the url.
            if (object.type == 'image') {
                // Make url a relative path.
                s = s.replace(/xlink:href="(.*)\/cotodesign\//, 'xlink:href="../../../cotodesign/')


                // Remove query string parameters (mainly nonce) if any.
                s = s.replace(/\?(.*?)"/, '"')


                imgsvg = s


                if (options.useHiResImages) {
                    s = s.replace('/thumbs/', '/')

                }
            } else if (printType == RolandKioskPrint.app.constants.PRINT_TYPE_FOIL && me.shouldReplaceColor(object)) {
                s = me.replaceFoilColor(s, object.fill, object.stroke, '#000')

            } else if (printType == RolandKioskPrint.app.constants.PRINT_TYPE_METAL && me.shouldReplaceColor(object)) {
                var fillSharpness = object.fillSharpness,
                    strokeSharpness = object.strokeSharpness,
                    isOutlinePath = object.isOutlinePath


                if (group && group.isPathGroup && group.uniColor) {
                    fillSharpness = group.fillSharpness

                    strokeSharpness = group.strokeSharpness

                    isOutlinePath = group.isOutlinePath

                }

                if (!isOutlinePath) {
                    s = me.replaceMetalColor(s, object.fill, object.stroke, fillSharpness, strokeSharpness)

                } else {
                    s = me.replaceMetalColor(s, object.fill, false, fillSharpness, 0)


                    // For outline paths, change stroke color to Outline named color. This results in a
                    // PDF separation colorspace for the object. Such objects undergo special processing
                    // when sending the print data to the metal printer.
                    var minimalStrokeWidth = 0.001

                    if (replaceGlobally) {
                        s = s.replace(/stroke:(.*?)
/g, 'stroke: #00f icc-named-color(RDGSpecialInks, Outline);');
                        s = s.replace(/stroke-width:(.*?)
/g, 'stroke-width: ' + minimalStrokeWidth + ';');
                    } else {
                        s = s.replace(/stroke:(.*?)
/, 'stroke: #00f icc-named-color(RDGSpecialInks, Outline);');
                        s = s.replace(/stroke-width:(.*?)
/, 'stroke-width: ' + minimalStrokeWidth + ';');
                    }
                }
            }

            // For cut paths, change stroke color to RDG CutContour named color. When
            // converting to PDF, this ensures we get a PDF separation colorspace.
            if (object.isCutPath) {
                if (replaceGlobally) {
                    s = s.replace(/stroke:(.*?)
/g, 'stroke: #f00 icc-named-color(RDGSpecialInks, CutContour);');
                } else {
                    s = s.replace(/stroke:(.*?)
/, 'stroke: #f00 icc-named-color(RDGSpecialInks, CutContour);');
                }
            }

            if (object.id == 'cutBounds') {
                // Emit cut bounds with CutContour2 named color.
                // We need to distinguish cut bounds from other cut paths in downstream code.
                s = s.replace(/stroke:(.*?)
/g, 'stroke: #f00 icc-named-color(RDGSpecialInks, CutContour2);');
            }

            // Earlier, we generated additional objects in special color for SVG objects only.
            // For other objects (created in PMD and PD), RVWD auto generation was used.
            // Since we no longer use RVWD special color auto generation, we need to generate
            // additional objects in special color for PMD and PD objects as well.

            var specialColor = object.specialColor || '000'

            var textureType = object.textureType

            var noColor = object.noColor


            if (group && group.isPathGroup &&
                group.sourceType != RolandKioskPrint.app.constants.OBJECT_SOURCE_SVG) {
                // For path group objects, get the special color from parent.
                specialColor = group.specialColor || '000'

                textureType = group.textureType

                noColor = group.noColor

            }

            if (me.shouldGenerateSpecialColorObjects(object)) {
                specialColor = specialColor.split('')


                // Override the per-object primer and white settings coming in from SVG.
                specialColor[0] = options.generatePrimer == 'on' ? '1' : '0'

                specialColor[1] = options.generateWhite == 'on' ? '1' : '0'


                // Suppress the object varnish setting, if the master setting is off.
                if (options.generateVarnish == 'off') {
                    specialColor[2] = '0'

                }

                specialColor = specialColor.join('')

            } else {
                specialColor = '000'

            }

            var specialColorObjects = ''


            if (specialColor.length >= 3 &&
                specialColor.substring(0, 3) != '000') {
                var objsvg = s

                if (object.type == 'image') {
                    // Check if png image. If yes, it can potentially have alpha.
                    // We use the image's alpha mask for generating the special colors.
                    // Otherwise, we use the rect tag for the entire image area.
                    if (/xlink:href="(.*)\.png"/i.test(imgsvg)) {
                        // Change to use image's mask.
                        objsvg = imgsvg.replace('/thumbs/', '/masks/')

                    } else {
                        // Replace image tag by rect.
                        // Leave in the xlink:href and other attributes.
                        objsvg = s.replace(/image/g, 'rect')

                    }
                }

                if (specialColor[0] == '1') {
                    // Primer
                    var primer = me.replaceColor(
                        objsvg, object.fill, object.stroke, 'RDG_PRIMER', '#fbd', replaceGlobally)

                    specialColorObjects = primer

                    modelData.hasPrimerObjects = true

                }
                if (specialColor[1] == '1') {
                    // White
                    var white = me.replaceColor(
                        objsvg, object.fill, object.stroke, 'RDG_WHITE', '#888', replaceGlobally)

                    specialColorObjects += white

                    modelData.hasWhiteObjects = true

                }
                if (specialColor[2] == '1') {
                    // Varnish. Check if matte texture.
                    var varnish

                    if (options.varnishType == RolandKioskPrint.app.constants.MATTE_VARNISH && textureType) {
                        varnish = me.replacePatternColor(
                            objsvg, object.fill, object.stroke, textureType, replaceGlobally)

                    } else {
                        varnish = me.replaceColor(
                            objsvg, object.fill, object.stroke, 'RDG_GLOSS', '#8cc', replaceGlobally)

                    }
                    specialColorObjects += varnish

                    modelData.hasVarnishObjects = true

                }
            }

            // For groups, noColor is handled at child level.
            var markup = specialColorObjects

            if (!noColor || (object.type == 'group' || object.type == 'clipingGroup')) {
                markup += s

            }
            return markup

        })


        if (options.suppressBgObjects) {
            this.suppressBackground(false)

        }

        this.suppressEditAreas(false)


        if (cutBoundsObject) {
            canvas.remove(cutBoundsObject)

        }

        this.setStrokeWidth(cutLines, 0)


        // Remove the callbacks.
        canvas.writeCanvasClipPathToSVG = null

        canvas.getCanvasClipPathSVGId = null

        canvas.writeObjectClipPathsToSVG = null

        canvas.getObjectClipPathSVGId = null

        canvas.writeColorProfilesToSVG = null

        canvas.writeColorPatternsToSVG = null

        canvas.writeImageFilterAttributesToSVG = null

        canvas.getUseFilteredImage = null


        // Restore background color.
        if (clipartImages) {
            for (var i = 0, len = clipartImages.length
 i < len; i++) {
                var filter = this.getImageFilter(clipartImages[i], 'Tint')

                filter.color = backgroundColor

                clipartImages[i].applyFilters()

            }
        }

        return svg

    },

    getThumbnail: function(options) {
        var canvas = this.canvas

        var needToRedraw = false


        // We are drawing for preview.
        this.drawingPreview = true


        var editAreas = this.getAllEditAreas()

        if (options.suppressEditAreas) {
            this.showHideObjects(
                // Leave cut edit areas.
                editAreas.filter(function(o) {
                    return o.editAreaType != RolandKioskPrint.app.constants.EDIT_AREA_CUT

                }),
                false
            )

            needToRedraw = true

        }

        this.drawingThumbPrintType = options.printType

        if (RolandKioskPrint.AppData.isProductModelDesigner() || options.printType) {
            // Adjust the canvas viewport to accomodate the protuding imprint area.
            this.transformCanvasViewport()

            needToRedraw = true

        } else if (this.currentZoomLevel != 1) {
            // Adjust the canvas layout without any zooming effect.
            this.transformCanvasViewport()

            needToRedraw = true

        }

        if (this.hasNegativeMargins()) {
            needToRedraw = true

        }

        if (!needToRedraw && (editAreas.length > 0 || this.getHasLowResImages())) {
            // No badge in thumbnail.
            needToRedraw = true

        }

        if (needToRedraw) {
            canvas.renderAll()

        }

        var png = canvas.toDataURL({
            format: 'png',
            left: this.canvasX,
            top: this.canvasY,
            width: this.canvasWidth,
            height: this.canvasHeight
        })


        this.drawingPreview = false


        if (options.suppressEditAreas) {
            this.showHideObjects(editAreas, true)

        }

        if (RolandKioskPrint.AppData.isProductModelDesigner() || options.printType) {
            this.drawingThumbPrintType = false


            // Revert back to normal.
            this.transformCanvasViewport()

        } else if (this.currentZoomLevel != 1) {
            this.transformCanvasViewport()

        }

        if (needToRedraw) {
            canvas.renderAll()

        }

        return png

    },

    getJSON: function(options) {
        var canvas = this.canvas


        // Handle options.
        var origIncludeDefaults = canvas.includeDefaultValues

        canvas.includeDefaultValues = options.includeDefaultValues


        // Clear object clip before saving out to JSON.
        // Restore after save.
        this.clearObjectClip(canvas.getObjects())


        var json = canvas.toJSON([
            // Additionally including these properties.
            'id',
            'selectable',
            'evented',
            'isCutPath',
            'specialColor',
            'textureType',
            'noColor',
            'editAreaType',
            'editAreaId',
            'perPixelTargetFind',
            'targetFindTolerance',
            'objectCaching',
            'sourceType',
            'skipDrawing',
            'isLocked',
            'origWidth',
            'origHeight',
            'printType',
            'fillSharpness',
            'strokeSharpness',
            'uniColor',
            'isOutlinePath',
            'startScaleX',
            'startScaleY'
        ])
 // Get the JSON representation of canvas

        // Update the image source URLs - absolute to relative.
        this.updateImageURLs(json.objects)


        // Save the lowest fg object index.
        json.lowestFgObjectIndex = canvas.lowestFgObjectIndex


        // Save the edit area book-keeping info.
        json.nextEditAreaId = canvas.nextEditAreaId


        canvas.includeDefaultValues = origIncludeDefaults


        this.setObjectClip(canvas.getObjects())


        return json

    },

    updateImageURLs: function(objects) {
        var me = this


        objects.forEach(function(o) {
            if (o.type == 'image') {
                var s = o.src

                if (s.indexOf('data:') !== 0) {
                    o.src = s.replace(/(.*)\/cotodesign\//, '../../../cotodesign/')

                }
            } else if (o.type == 'group' || o.type == 'clippingGroup') {
                me.updateImageURLs(o.objects)

            }
        })

    },

    reloadImages: function(objects, imageData) {
        var canvas = this.canvas


        var me = this

        objects.forEach(function(o) {
            if (o.type == 'image') {
                var src = o.getSrc()
 // fully qualified path

                // Remove the nonce for comparison.
                src = src.replace(/\?(.*)/, '')


                if (src.indexOf(imageData.thumbPath) != -1) {
                    // Need to reload the image.
                    var prevWidth = o.width

                    o.setSrc(imageData.thumbPathWithNonce, function(img) {
                        // Keep object width the same. Change object height to preserve
                        // the aspect ratio.
                        var elWidth = img.naturalWidth || img.width

                        var scale = (o.scaleX || 1) * prevWidth / elWidth


                        o.scale(scale)

                        o.applyFilters()

                        o.origWidth = imageData.origWidth

                        o.origHeight = imageData.origHeight

                        me.computeImageIsLowRes(o)

                        canvas.renderAll()

                    })

                }
            } else if (o.type == 'group' || o.type == 'clippingGroup') {
                me.reloadImages(o.getObjects(), imageData)

            }
        })

    },

    loadProductDesignJSON: function() {
        var canvas = this.canvas


        var productModel = RolandKioskPrint.AppData.productModelData,
            isPrintTypeCut = productModel.isCutPrint()

        var version = productModel.version


        // When opening a product model in product designer, we designate the product model
        // objects as background. These are made un-selectable, and therefore cannot be modified.
        // Foreground objects (created in product designer) can not be sent beneath background.
        var isProductDesigner = RolandKioskPrint.AppData.isProductDesigner()

        var deferred = new Ext.Deferred()


        var maskArea = false,
            marginArea = false,
            foilImprintArea = false,
            metalImprintArea = false


        // Get the product design and load.
        Ext.Ajax.request({
            scope: this,
            url: this.productDesignPath,
            success: function(response, opts) {
                var json = Ext.decode(response.responseText)

                var me = this

                canvas.loadFromJSON(
                    json,
                    true,
                    function() { // callback
                        var objects = canvas.getObjects()


                        if (maskArea || marginArea) {
                            // Do away with the default margin area.
                            if (objects[0].get('id') == 'margin') {
                                canvas.remove(objects[0])

                            }
                        }

                        if (foilImprintArea) {
                            // Remove the default foil imprint area.
                            var defaultFoilImprintArea = me.getImprintArea(RolandKioskPrint.app.constants.PRINT_TYPE_FOIL)

                            if (defaultFoilImprintArea && defaultFoilImprintArea != foilImprintArea) {
                                canvas.remove(defaultFoilImprintArea)

                            }
                        }

                        if (metalImprintArea) {
                            // Remove the default metal imprint area.
                            var defaultMetalImprintArea = me.getImprintArea(RolandKioskPrint.app.constants.PRINT_TYPE_METAL)

                            if (defaultMetalImprintArea && defaultMetalImprintArea != metalImprintArea) {
                                canvas.remove(defaultMetalImprintArea)

                            }
                        }

                        // Set the lowest modifiable object index.
                        if (isProductDesigner) {
                            // Check if background objects can be added.
                            // Or if product model contains edit areas, in which case product designer
                            // objects are added to edit areas only.
                            var productModel = RolandKioskPrint.AppData.productModelData

                            var userBackground = productModel.userBackground || 'off'

                            if (userBackground == 'on') {
                                canvas.lowestFgObjectIndex = me.getBGColorObjectIndex()

                            } else if (me.hasOneOrMoreEditAreas()) {
                                canvas.lowestFgObjectIndex = me.getLowestEditAreaIndex()

                            } else {
                                canvas.lowestFgObjectIndex = canvas.getObjects().length

                            }
                        } else {
                            canvas.lowestFgObjectIndex = json.lowestFgObjectIndex

                        }

                        if (json.nextEditAreaId !== undefined) { // undefined for earlier saved product models
                            canvas.nextEditAreaId = json.nextEditAreaId

                        }

                        // Sort the edit areas left top first.
                        if (isProductDesigner) {
                            me.sortObjects(canvas.imageAreaList)

                            me.sortObjects(canvas.textAreaList)

                            me.sortObjects(canvas.freeAreaList)

                            me.sortObjects(canvas.foilAreaList)

                            me.sortObjects(canvas.metalAreaList)

                            me.sortObjects(canvas.cutAreaList)

                        }

                        canvas.renderAll()

                        deferred.resolve()

                    },
                    function(o, object, index) { // reviver
                        if (!object.editAreaType) {
                            if (isProductDesigner) {
                                // Allow selection if child of edit area.
                                var selectable = object.editAreaId ? true : false

                                object.set({
                                    'selectable': selectable,
                                    'evented': selectable
                                })

                            }
                        }
                        else if (isProductDesigner || object.sourceType == RolandKioskPrint.app.constants.OBJECT_SOURCE_SVG) {
                            // Edit area. Keep it selectable, but disallow any transformations.
                            // Also need to disallow actions like copy, delete, arrange etc.
                            // In case you make any changes to edit area properties here, do make
                            // the corresponding change in undo/redo panel when loading saved state.
                            object.set({
                                'selectable': true,
                                'lockMovementX': true,
                                'lockMovementY': true,
                                'lockScalingX': true,
                                'lockScalingY': true,
                                'lockRotation': true,
                                'hasControls': false,
                                'hasRotatingPoint': false,
                                'evented': true,
                                'borderScaleFactor': 3 // 3px selection border
                            })


                            if (isProductDesigner) {
                                switch (object.editAreaType) {
                                    case RolandKioskPrint.app.constants.EDIT_AREA_IMAGE:
                                        canvas.imageAreaList.push(object)

                                        break

                                    case RolandKioskPrint.app.constants.EDIT_AREA_TEXT:
                                        canvas.textAreaList.push(object)

                                        break

                                    case RolandKioskPrint.app.constants.EDIT_AREA_FOIL:
                                        canvas.foilAreaList.push(object)

                                        break

                                    case RolandKioskPrint.app.constants.EDIT_AREA_METAL:
                                        canvas.metalAreaList.push(object)

                                        break

                                    case RolandKioskPrint.app.constants.EDIT_AREA_CUT:
                                        canvas.cutAreaList.push(object)

                                        break

                                    default:
                                        canvas.freeAreaList.push(object)

                                        break

                                }
                            }
                        }

                        if (object.editAreaId) {
                            me.setClipToEditArea(object)

                        }

                        if (object.editAreaType) {
                            // Fixup edit area color. Changed in cotodesign 2.4
                            switch (object.editAreaType) {
                                case RolandKioskPrint.app.constants.EDIT_AREA_IMAGE:
                                    object.set('stroke', RolandKioskPrint.app.constants.IMAGE_AREA_STROKE_COLOR)

                                    break

                                case RolandKioskPrint.app.constants.EDIT_AREA_TEXT:
                                    object.set('stroke', RolandKioskPrint.app.constants.TEXT_AREA_STROKE_COLOR)

                                    break

                                case RolandKioskPrint.app.constants.EDIT_AREA_FOIL:
                                    object.set('stroke', RolandKioskPrint.app.constants.FOIL_AREA_STROKE_COLOR)

                                    break

                                case RolandKioskPrint.app.constants.EDIT_AREA_METAL:
                                    object.set('stroke', RolandKioskPrint.app.constants.METAL_AREA_STROKE_COLOR)

                                    break

                                case RolandKioskPrint.app.constants.EDIT_AREA_CUT:
                                    object.set('stroke', RolandKioskPrint.app.constants.CUT_AREA_STROKE_COLOR)

                                    break

                                default:
                                    object.set('stroke', RolandKioskPrint.app.constants.FREE_AREA_STROKE_COLOR)

                                    break

                            }
                        }

                        me.enumerateObjects(object, function(o) {
                            if (!version && !o.printType) {
                                var printType = RolandKioskPrint.app.constants.PRINT_TYPE_COLOR

                                if (o.isCutPath) {
                                    printTye = RolandKioskPrint.app.constants.PRINT_TYPE_CUT

                                } else if (productModel.isFoilPrint()) {
                                    printType = RolandKioskPrint.app.constants.PRINT_TYPE_FOIL

                                }
                                o.set('printType', printType)

                            }

                            // Update the cut path color.
                            // The materal color may have changed since the last time.
                            if (isPrintTypeCut && o.isCutPath) {
                                o.set({
                                    stroke: RolandKioskPrint.app.getCutViewingColor(productModel.cutMaterialColor)
                                })

                            }

                            // Mark clipart objects as unicolor, if they are the same color.
                            if (o.type == 'group') {
                                if (o.isPathGroup && o.isSameColor()) {
                                    o.uniColor = true

                                }
                                return true
 // Keep enumerating
                            }

                            // For text objects, apply the notdef fallback font, if not already applied.
                            if (o.type == 'text' || o.type == 'curved-text') {
                                var fontFamily = o.fontFamily

                                if (fontFamily.indexOf(', Notdef') == -1) {
                                    o.fontFamily = fontFamily + ', Notdef'

                                }
                            }

                            // For image objects, apply the original image width and height properties, if
                            // not alreay available. Required for Product model designer only.
                            if (!isProductDesigner && o.type == 'image' && o.id != 'background' &&
                               o.sourceType != RolandKioskPrint.app.constants.OBJECT_SOURCE_SVG) {
                                if (!o.origHeight || !o.origWidth) {
                                    var userImages =
                                        RolandKioskPrint.app.getProductModelImages(productModel.printType)


                                    var found = me.fixupImageObject(o, userImages.images)

                                    if (!found) {
                                        var categoriesData = RolandKioskPrint.app.getBundledImages().imageCategories

                                        var i = 0

                                        while (!found && i < categoriesData.length) {
                                            found = me.fixupImageObject(o, categoriesData[i++].imageItems)

                                        }
                                    }
                                }
                            }
                            return true

                        }, true)


                        var id = object.get('id')

                        if (id == 'mask') {
                            maskArea = object

                        } else if (id == 'margin') {
                            marginArea = object

                        } else if (RolandKioskPrint.AppData.isImprintArea(object)) {
                            // registering mouse up event
                            object.on('mouseup', me.transformCanvasViewport.bind(me))

                            if (id == 'foilImprintArea') {
                                foilImprintArea = object

                            } else {
                                metalImprintArea = object

                            }
                            object.set({
                                'visible': !isProductDesigner
                            })

                            if (object.sourceType != RolandKioskPrint.app.constants.OBJECT_SOURCE_SVG) {
                                object.set({
                                    'evented': true,
                                    'selectable': true
                                })

                            }
                        } else if (id == 'background') {
                            object.set({
                                evented: false,
                                selectable: false
                            })

                        }

                        if (object.isLocked) {
                            me.setLockedProperties(object)

                        }
                    }
                )

            },
            failure: function() {
                deferred.reject()

            }
        })


        return deferred.promise

    },

    loadProductDesignSVG: function() {
        var canvas = this.canvas

        var imageBasePath = ''

        var productModel = RolandKioskPrint.AppData.productModelData


        if (this.productDesignSVGPath) {
            var index = this.productDesignSVGPath.lastIndexOf('/')

            if (index != -1) {
                imageBasePath = this.productDesignSVGPath.substring(0, index + 1)
 // remove the SVG file name
            }
        }

        var deferred = new Ext.Deferred()

        var me = this


        // Import the product design.
        fabric.loadSVGFromString(
            this.productDesignSVG,
            function(objects, options) { // callback
                // Determine the mask, margin, background and design objects.
                var segregatedObjects = me.segregateSVGObjects(objects)


                var maskArea = segregatedObjects.mask

                var marginArea = segregatedObjects.margin

                var foilImprintArea = segregatedObjects.foilImprint

                var metalImprintArea = segregatedObjects.metalImprint

                var backgroundObjects = segregatedObjects.background

                var designObjects = segregatedObjects.design

                var hasEditAreas = false


                // Calculate scaling to mm units.
                var sx = 1.0,
                    sy = 1.0


                var data = me.productSizeData

                if (options.width !== 0) {
                    sx = data.widthMM / options.width

                }

                if (options.height !== 0) {
                    sy = data.heightMM / options.height

                }

                canvas.renderOnAddRemove = false


                // Add the SVG margin area.
                var defaultMarginArea

                if (marginArea) {
                    // Remove the default margin.
                    defaultMarginArea = me.getMarginArea()

                    if (defaultMarginArea) {
                        canvas.remove(defaultMarginArea)

                    }

                    var marginGroup = fabric.util.groupSVGElements([marginArea], options)

                    marginGroup.scale(sx, sy)

                    marginGroup.set({
                        left: 0,
                        top: 0,
                        id: 'margin',
                        selectable: false,
                        evented: false,
                        visible: false,
                        objectCaching: false,
                        sourceType: RolandKioskPrint.app.constants.OBJECT_SOURCE_SVG
                    })

                    canvas.insertAt(marginGroup, 0)


                    // Update margin values in product model.
                    me.setProductMargins(marginGroup)

                }

                // Add the mask area.
                if (maskArea) {
                    // Remove the default margin.
                    if (!marginArea) {
                        defaultMarginArea = me.getMarginArea()

                        if (defaultMarginArea) {
                            canvas.remove(defaultMarginArea)

                        }
                    }

                    var maskGroup = fabric.util.groupSVGElements([maskArea], options)

                    maskGroup.scale(sx, sy)

                    maskGroup.set({
                        left: 0,
                        top: 0,
                        id: 'mask',
                        selectable: false,
                        evented: false,
                        visible: false,
                        objectCaching: false,
                        sourceType: RolandKioskPrint.app.constants.OBJECT_SOURCE_SVG
                    })

                    canvas.insertAt(maskGroup, 0)
 // Add as the first object
                }

                // Add the background objects.
                if (backgroundObjects.length > 0) {
                    var backgroundGroup = fabric.util.groupSVGElements(backgroundObjects, options)

                    backgroundGroup.scale(sx, sy)

                    backgroundGroup.set({
                        left: 0,
                        top: 0,
                        id: 'background',
                        selectable: false,
                        evented: false,
                        visible: false,
                        objectCaching: false,
                        skipDrawing: true,
                        sourceType: RolandKioskPrint.app.constants.OBJECT_SOURCE_SVG
                    })


                    me.fixupGroupColor(backgroundGroup)


                    // Add below the foil imprint area, if any.
                    if (me.foilPrint) {
                        var index = me.getImprintAreaIndex(RolandKioskPrint.app.constants.PRINT_TYPE_FOIL)

                        if (index == -1) {
                            canvas.add(backgroundGroup)

                        } else {
                            canvas.insertAt(backgroundGroup, index)
 // Add below foil imprint
                        }
                    } else {
                        canvas.add(backgroundGroup)

                    }
                }

                // Add the foil imprint area.
                if (me.foilPrint && foilImprintArea) {
                    // Remove the default foil imprint area.
                    var defaultFoilImprintArea = me.getImprintArea(RolandKioskPrint.app.constants.PRINT_TYPE_FOIL)

                    if (defaultFoilImprintArea) {
                        canvas.remove(defaultFoilImprintArea)

                    }
                    me.createImprintArea(RolandKioskPrint.app.constants.PRINT_TYPE_FOIL,
                                         RolandKioskPrint.app.constants.OBJECT_SOURCE_SVG,
                                         foilImprintArea.left * sx,
                                         foilImprintArea.top * sy)

                }

                // Add the metal imprint area.
                if (me.metalPrint && metalImprintArea) {
                    // Remove the default metal imprint area.
                    var defaultMetalImprintArea = me.getImprintArea(RolandKioskPrint.app.constants.PRINT_TYPE_METAL)

                    if (defaultMetalImprintArea) {
                        canvas.remove(defaultMetalImprintArea)

                    }
                    me.createImprintArea(RolandKioskPrint.app.constants.PRINT_TYPE_METAL,
                                         RolandKioskPrint.app.constants.OBJECT_SOURCE_SVG,
                                         metalImprintArea.left * sx,
                                         metalImprintArea.top * sy)

                }

                // Add the design objects.
                if (designObjects.length > 0) {
                    var i, length

                    var object, fill, stroke


                    if (me.foilPrint) {
                        // Apply foil color to objects.
                        var foilColor = RolandKioskPrint.AppData.getCurrentFoilColor()

                        for (i = 0, length = designObjects.length
 i < length; i++) {
                            object = designObjects[i]

                            if (object.isCutPath || object.editAreaType) {
                                continue

                            }

                            if (object.get('type') == 'image') {
                                object.filters.push(new fabric.Image.filters.Tint({
                                    color: foilColor.value,
                                    skipWhite: true
                                }))

                                object.applyFilters()

                            } else {
                                object.set('fill', foilColor.value)


                                // If the object has a stroke color, change it as well.
                                stroke = object.get('stroke') || ''

                                if (stroke !== '') {
                                    object.set('stroke', foilColor.value)

                                }
                            }
                        }
                    }

                    if (me.metalPrint) {
                        for (i = 0, length = designObjects.length
 i < length; i++) {
                            object = designObjects[i]

                            if (object.isCutPath || object.editAreaType) {
                                continue

                            }

                            var materialColor = productModel.materialColor

                            if (object.get('type') == 'image') {
                                object.filters.push(new fabric.Image.filters.Tint({
                                    color: materialColor
                                }))

                                object.applyFilters()

                            } else {
                                fill = object.get('fill')

                                if (fill) {
                                    object.fillSharpness = me.getColorSharpness(fill)


                                    var fillColor

                                    if (fill.toLive) {
                                        var colorStops = fill.colorStops,
                                            fillSharpness = object.fillSharpness

                                        for (var k = 0
 k < colorStops.length; k++) {
                                            colorStops[k].color = me.applySharpnessToColor(materialColor, fillSharpness[k].color)

                                        }
                                        fillColor = fill

                                    } else {
                                        fillColor = me.applySharpnessToColor(materialColor, object.fillSharpness)

                                    }
                                    object.set('fill', fillColor)

                                }

                                // If the object has a stroke color, change it as well.
                                stroke = object.get('stroke')

                                if (stroke) {
                                    object.strokeSharpness = RolandKioskPrint.app.constants.METAL_FILL_SHARPNESS_DEFAULT

                                    object.set({
                                        'stroke': RolandKioskPrint.app.constants.METAL_OUTLINE_COLOR_DEFAULT,
                                        'strokeWidth': RolandKioskPrint.app.constants.DEFAULT_STROKE_WIDTH,
                                        'isOutlinePath': true
                                    })

                                }
                            }
                        }
                    }

                    if (me.cutPrint) {
                        for (i = 0, length = designObjects.length
 i < length; i++) {
                            object = designObjects[i]

                            if (object.editAreaType) {
                                continue

                            }
                            if (object.isCutPath) {
                                object.set('stroke', RolandKioskPrint.app.getCutViewingColor(productModel.cutMaterialColor))

                            }
                        }
                    }

                    designObjects.forEach (function(object) {
                        object.left *= sx

                        object.top *= sy

                        object.scaleX *= sx

                        object.scaleY *= sy


                        var isEditArea = object.editAreaType !== undefined

                        object.set({
                            selectable: isEditArea,
                            evented: isEditArea,
                            sourceType: RolandKioskPrint.app.constants.OBJECT_SOURCE_SVG
                        })


                        if (isEditArea) {
                            object.set({
                                'lockMovementX': true,
                                'lockMovementY': true,
                                'lockScalingX': true,
                                'lockScalingY': true,
                                'lockRotation': true,
                                'hasControls': false,
                                'hasRotatingPoint': false,
                                'borderScaleFactor': 3 // 3px selection border
                            })

                            hasEditAreas = true

                        }
                        canvas.add(object)

                    })

                }

                if (hasEditAreas) {
                    canvas.lowestFgObjectIndex = me.getLowestEditAreaIndex()

                } else {
                    canvas.lowestFgObjectIndex = canvas.getObjects().length
 // With the mask, margin and imported contents beneath.
                }

                canvas.renderOnAddRemove = true

                canvas.renderAll()


                if (marginArea) {
                    // Update the layout with new SVG margins.
                    me.getView().updateLayout()

                }

                deferred.resolve()

            },
            null, // reviver
            function(url, id) { // fixup
                // Change the image url wrt to the svg path on server.
                // No change if data url.
                if (url.startsWith('data:')) {
                    return url

                }

                var s = url.replace(/\\/g, '/')

                var index = s.lastIndexOf('/')


                var fileName = s.substring(index + 1)

                var filePath = s.substring(0, index + 1)

                var addon = ''


                if ((me.foilPrint || me.metalPrint) && !(id && id.startsWith('background'))) {
                    addon = 'filtered/'

                }

                return imageBasePath + filePath + addon + 'thumbs/' + fileName

            }
        )


        return deferred.promise

    },

    suppressBackground: function(suppress) {
        var objects = this.getBackgroundObjects()

        objects.forEach(function(object) {
            object.excludeFromExport = suppress

        })

    },

    replaceColor: function(s, fill, stroke, colorName, altColor, globally) {
        // Create a copy to start with.
        s = s.slice(0)


        var namedColor = altColor + ' icc-named-color(RDGSpecialInks, ' + colorName + ')
';

        // If the object has no fill or stroke, generate the fill in special color.
        // Otherwise, generate the fill and stroke in special color.

        if (fill || !stroke) {
            if (globally) {
                s = s.replace(/fill:(.*?)
/g, 'fill: ' + namedColor);
            } else {
                s = s.replace(/fill:(.*?)
/, 'fill: ' + namedColor);
            }
        }

        if (stroke) {
            if (globally) {
                s = s.replace(/stroke:(.*?)
/g, 'stroke: ' + namedColor);
            } else {
                s = s.replace(/stroke:(.*?)
/, 'stroke: ' + namedColor);
            }
        }
        return s

    },

    replaceFoilColor: function(s, fill, stroke, color) {
        // Create a copy to start with.
        s = s.slice(0)


        if (fill) {
            s = s.replace(/fill:(.*?)
/, 'fill: ' + color);
        }

        if (stroke) {
            s = s.replace(/stroke:(.*?)
/, 'stroke: ' + color);
        }

        return s

    },

    replaceMetalColor: function(s, fill, stroke, fillSharpness, strokeSharpness) {
        function replaceColors(sharpness, isFill, isShading) {
            if (isShading) {
                var i = 0,
                    stopColors = []

                for (i = 0
 i < sharpness.length; i++) {
                    stopColors.push({
                        offset: sharpness[i].offset,
                        color: sharpness[i].color
                    })

                }
                stopColors.sort(function(a, b) {
                    // Sort to match the SVG order.
                    return a.offset - b.offset

                })

                i = 0

                s = s.replace(/stop-color:(.*?)
/g, function() {
                    var stopColor = Math.floor(stopColors[i++].color)

                    stopColor = 'rgb(' + stopColor + ',' + stopColor + ',' + stopColor + ')
';
                    return 'stop-color: ' + stopColor

                })

            } else {
                sharpness = Math.floor(sharpness)

                var color = 'rgb(' + sharpness + ',' + sharpness + ',' + sharpness + ')
';
                if (isFill) {
                    s = s.replace(/fill:(.*?)
/, 'fill: ' + color);
                } else {
                    s = s.replace(/stroke:(.*?)
/, 'stroke: ' + color);
                }
            }
        }

        if (fill) {
            replaceColors(fillSharpness, true, fill.toLive)

        }
        if (stroke) {
            replaceColors(strokeSharpness, false, stroke.toLive)

        }
        return s

    },

    replacePatternColor: function(s, fill, stroke, patternId, globally) {
        // Create a copy to start with.
        s = s.slice(0)


        var patternColor = 'url(#' + patternId + ')
';

        // If the object has no fill or stroke, generate the fill in special color.
        // Otherwise, generate the fill and stroke in special color.

        if (fill || !stroke) {
            if (globally) {
                s = s.replace(/fill:(.*?)
/g, 'fill: ' + patternColor);
            } else {
                s = s.replace(/fill:(.*?)
/, 'fill: ' + patternColor);
            }
        }

        if (stroke) {
            if (globally) {
                s = s.replace(/stroke:(.*?)
/g, 'stroke: ' + patternColor);
            } else {
                s = s.replace(/stroke:(.*?)
/, 'stroke: ' + patternColor);
            }
        }
        return s

    },

    clipObjectToEditArea: function(object, ctx) {
        var canvas = this.canvas


        // Get the object edit area.
        var editArea


        var objects = canvas.getObjects()

        for (var i = 0, length = objects.length
 i < length; i++) {
            if (objects[i].id == object.editAreaId) {
                editArea = objects[i]

                break

            }
        }

        if (editArea) {
            ctx.save()


            // Draw the edit area path in canvas context, which gets set as the clip on
            // return from this function.
            // The code below takes the relevant portions from fabric.Object.render.
            editArea.transform(ctx)

            if (editArea.transformMatrix) {
                ctx.transform.apply(ctx, editArea.transformMatrix)

            }

            var fill = editArea.fill

            var stroke = editArea.stroke


            editArea.fill = false

            editArea.stroke = false


            editArea.drawObject(ctx)
 // Draws the path in canvas context
            editArea.fill = fill

            editArea.stroke = stroke


            ctx.restore()

        }
    },

    setClipToEditArea: function(object) {
        var me = this

        object.clipTo = function(ctx) {
            return me.clipObjectToEditArea(this, ctx)

        }

    },

    clearObjectClip: function(objects) {
        var me = this


        objects.forEach(function(o) {
            o.clipTo = null

        })

    },

    setObjectClip: function(objects) {
        var me = this


        objects.forEach(function(o) {
            if (o.editAreaId) {
                me.setClipToEditArea(o)

            }
        })

    },

    suppressEditAreas: function(suppress) {
        var canvas = this.canvas

        var objects = canvas.getObjects()


        objects.forEach(function(o) {
            if (o.editAreaType) {
                o.excludeFromExport = suppress

            }
        })

    },

    allowObjectMove: function(object, newLeft, newTop) {
        // If the object is moving too much outside the parent bounds, disallow move.
        // Object area must be within the tolerance limit of the parent or 50% the
        // object size (whichever is smaller).

        var oldLeft = object.get('left')

        var oldTop = object.get('top')


        // Get the updated object bounds.
        object.set('left', newLeft)

        object.set('top', newTop)


        // The canvas bounds.
        var data = this.getProductMargins()

        canvasBounds = {
            left: data.leftMarginMM,
            top: data.topMarginMM,
            right: data.widthMM - data.rightMarginMM,
            bottom: data.heightMM - data.bottomMarginMM,
            sideTolerance: 0.05,
            areaTolerance: 0.01
        }

        canvasBounds.width = canvasBounds.right - canvasBounds.left

        canvasBounds.height = canvasBounds.bottom - canvasBounds.top


        var objects = []

        var isActiveGroup = false


        if (object.get('type') == 'activeSelection') {
            objects = object.getObjects()

            isActiveGroup = true

        } else {
            objects.push(object)

        }

        var canvas = this.canvas

        var originalProperties = []

        var allowMove = true


        for (var i = 0, length = objects.length
 i < length; i++) {
            var parentBounds = canvasBounds

            if (objects[i].editAreaId) {
                var editArea = this.getEditArea(objects[i].editAreaId)

                if (editArea) {
                    parentBounds = editArea.getBoundingRect(true)

                    parentBounds.sideTolerance = parentBounds.areaTolerance = 0.1

                    parentBounds.right = parentBounds.left + parentBounds.width

                    parentBounds.bottom = parentBounds.top + parentBounds.height

                }
            }

            if (isActiveGroup) {
                originalProperties.push(canvas._realizeGroupTransformOnObject(objects[i]))

            }

            var coords = objects[i].calcCoords(true)


            if ((objects[i].angle % 90) === 0) {
                // Orthogonal rotation case.
                var objectBounds = {
                    left: Math.min(coords.tl.x, coords.tr.x, coords.bl.x, coords.br.x),
                    top: Math.min(coords.tl.y, coords.tr.y, coords.bl.y, coords.br.y),
                    right: Math.max(coords.tl.x, coords.tr.x, coords.bl.x, coords.br.x),
                    bottom: Math.max(coords.tl.y, coords.tr.y, coords.bl.y, coords.br.y)
                }

                objectBounds.width = objectBounds.right - objectBounds.left

                objectBounds.height = objectBounds.bottom - objectBounds.top


                // Find the intersection of object and parent bounds.
                var intersect = this.intersectRect(parentBounds, objectBounds)


                if (intersect) {
                    var minWidth = Math.min(0.5 * objectBounds.width, parentBounds.sideTolerance * parentBounds.width)

                    var minHeight = Math.min(0.5 * objectBounds.height, parentBounds.sideTolerance * parentBounds.height)


                    if (intersect.width >= minWidth && intersect.height >= minHeight) {
                        continue

                    }
                }

                allowMove = false

                break

            } else {
                var points = []


                // For non orthogonal rotation cases, we compute the intersection of the parent
                // with the object polygon (quad), and ensure that the intersection area is above
                // a particular threshold - 1% of the canvas or 10% of the editArea.
                // Below we implement the algorithm to find the intersection area.
                // https://math.stackexchange.com/questions/141798/two-quadrilaterals-intersection-area-special-case

                // First, check if the object is fully contained in the parent.
                var containsTL = this.pointInRect(coords.tl, parentBounds, points)

                var containsTR = this.pointInRect(coords.tr, parentBounds, points)

                var containsBL = this.pointInRect(coords.bl, parentBounds, points)

                var containsBR = this.pointInRect(coords.br, parentBounds, points)


                if (containsTL && containsTR && containsBL && containsBR) {
                    continue

                }

                // Check if the object completely overlaps the parent.
                var lines = this.getLines(coords)


                var point = new fabric.Point(parentBounds.left, parentBounds.top)

                containsTL = objects[i].containsPoint(point, lines)

                if (containsTL) {
                    points.push(point)

                }

                point = new fabric.Point(parentBounds.right, parentBounds.top)

                containsTR = objects[i].containsPoint(point, lines)

                if (containsTR) {
                    points.push(point)

                }

                point = new fabric.Point(parentBounds.left, parentBounds.bottom)

                containsBL = objects[i].containsPoint(point, lines)

                if (containsBL) {
                    points.push(point)

                }

                point = new fabric.Point(parentBounds.right, parentBounds.bottom)

                containsBR = objects[i].containsPoint(point, lines)

                if (containsBR) {
                    points.push(point)

                }

                if (containsTL && containsTR && containsBL && containsBR) {
                    continue

                }

                // Else compute the intersection area.
                var intersection =
                    fabric.Intersection.intersectPolygonRectangle(this.getCoordsArray(coords),
                                                                  new fabric.Point(parentBounds.left, parentBounds.top),
                                                                  new fabric.Point(parentBounds.right, parentBounds.bottom))

                if (intersection.points.length === 0) {
                    allowMove = false

                    break

                }

                points.push.apply(points, intersection.points)


                // Sort the intersection area points.
                this.sortPolygonPoints(points)


                // Find its area.
                var area = this.computePolygonArea(points)


                // If the intersection area is within the tolerance of the parent object.
                if (area > parentBounds.areaTolerance * parentBounds.width * parentBounds.height) {
                    continue

                }

                allowMove = false

                break

            }
        }

        if (isActiveGroup) {
            for (var i = 0, length = originalProperties.length
 i < length; i++) {
                canvas._unwindGroupTransformOnObject(objects[i], originalProperties[i])

            }
        }

        object.set('left', oldLeft)

        object.set('top', oldTop)


        return allowMove

    },

    sortPolygonPoints: function(points) {
        var center = this.findPolygonCenter(points)

        points.sort(function(a, b) {
            if (a.x - center.x >= 0 && b.x - center.x < 0)
                return 1

            if (a.x - center.x < 0 && b.x - center.x >= 0)
                return -1

            if (a.x - center.x === 0 && b.x - center.x === 0) {
                if (a.y - center.y >= 0 || b.y - center.y >= 0)
                    return a.y > b.y ? 1 : -1

                return b.y > a.y ? -1 : 1

            }

            // compute the cross product of vectors (center -> a) x (center -> b)
            var det = (a.x - center.x) * (b.y - center.y) - (b.x - center.x) * (a.y - center.y)

            if (det < 0)
                return -1

            if (det > 0)
                return 1


            // points a and b are on the same line from the center
            // check which point is closer to the center
            var d1 = (a.x - center.x) * (a.x - center.x) + (a.y - center.y) * (a.y - center.y)

            var d2 = (b.x - center.x) * (b.x - center.x) + (b.y - center.y) * (b.y - center.y)

            return d1 > d2 ? 1 : -1

        })

    },

    findPolygonCenter: function(points) {
        var sx = points[0].x,
            sy = points[0].y


        for (var i = 1, length = points.length
 i < length; i++) {
            sx += points[i].x

            sy += points[i].y

        }

        return new fabric.Point(sx / points.length, sy / points.length)

    },

    computePolygonArea: function(points) {
        // Computes the area using shoelace method.
        var area = 0
  // Accumulates area in the loop'
        var length = points.length


        var j = length - 1
  // The last vertex is the 'previous' one to the first

        for (var i = 0
 i < length; i++) {
            area += (points[j].x + points[i].x) * (points[j].y - points[i].y)

            j = i
  // j is previous vertex to i
        }

        return Math.abs(area / 2)

    },

    getLines: function(coords) {
        return {
            topline: {
                o: coords.tl,
                d: coords.tr
            },
            rightline: {
                o: coords.tr,
                d: coords.br
            },
            bottomline: {
                o: coords.br,
                d: coords.bl
            },
            leftline: {
                o: coords.bl,
                d: coords.tl
            }
        }

    },

    getCoordsArray: function(coords) {
        return [
            new fabric.Point(coords.tl.x, coords.tl.y),
            new fabric.Point(coords.tr.x, coords.tr.y),
            new fabric.Point(coords.br.x, coords.br.y),
            new fabric.Point(coords.bl.x, coords.bl.y)
        ]

    },

    intersectRect: function(r1, r2) {
        var intersect = !(r2.left > r1.right ||
                          r2.right < r1.left ||
                          r2.top > r1.bottom ||
                          r2.bottom < r1.top)


        if (!intersect) {
            return false

        }

        // Return the intersection bounds.
        intersect = {
            left: Math.max(r1.left, r2.left),
            right: Math.min(r1.right, r2.right),
            top: Math.max(r1.top, r2.top),
            bottom: Math.min(r1.bottom, r2.bottom)
        }


        intersect.width = intersect.right - intersect.left

        intersect.height = intersect.bottom - intersect.top


        return intersect

    },

    pointInRect: function(p, r, points) {
        var contains = (r.left <= p.x && p.x <= r.right &&
                        r.top <= p.y && p.y <= r.bottom)


        if (contains && points) {
            points.push(new fabric.Point(p.x, p.y))

        }

        return contains

    },

    sortObjects: function(objects) {
        objects.sort(this.compareObjects)

    },

    compareObjects: function(a, b) {
        var bounds_a = a.getBoundingRect(true)

        var bounds_b = b.getBoundingRect(true)


        // Sort left top first.
        return ((bounds_a.left - bounds_b.left) +
                (bounds_a.top - bounds_b.top))

    },

    showHideObjects: function(objects, show) {
        objects.forEach(function(o) {
            o.visible = show

        })

    },

    addObjectToEditArea: function(object, editArea) {
        var canvas = this.canvas

        var objects = canvas.getObjects()


        var index = objects.indexOf(editArea)

        if (index == -1) {
            return

        }

        var i = index + 1,
            length = objects.length

        for (
 i < length; i++) {
            if (objects[i].editAreaId != editArea.id) {
                break

            }
        }

        object.set({
            editAreaId: editArea.id
        })


        // Set clip to edit area.
        this.setClipToEditArea(object)


        canvas.insertAt(object, i)

    },

    addObjectToEditAreaById: function(object, editAreaId) {
        var canvas = this.canvas

        var objects = canvas.getObjects()


        var index = this.getEditAreaIndex(editAreaId)

        if (index == -1) {
            return
 // Not found
        }

        var i = index + 1,
            length = objects.length

        for (
 i < length; i++) {
            if (objects[i].editAreaId != editAreaId) {
                break

            }
        }

        object.set({
            editAreaId: editAreaId
        })


        // Set clip to edit area.
        this.setClipToEditArea(object)


        canvas.insertAt(object, i)

    },

    hasOneOrMoreEditAreas: function() {
        var canvas = this.canvas

        return (
            canvas.imageAreaList.length > 0 ||
            canvas.textAreaList.length > 0 ||
            canvas.freeAreaList.length > 0 ||
            canvas.foilAreaList.length > 0 ||
            canvas.metalAreaList.length > 0 ||
            canvas.cutAreaList.length > 0
        )

    },

    getEditAreaIndex: function(editAreaId) {
        var canvas = this.canvas

        var objects = canvas.getObjects()


        var index = -1

        for (var i = 0, length = objects.length
 i < length; i++) {
            if (objects[i].id == editAreaId) {
                index = i

                break

            }
        }

        return index

    },

    getEditArea: function(editAreaId) {
        var canvas = this.canvas

        var objects = canvas.getObjects()


        for (var i = 0, length = objects.length
 i < length; i++) {
            if (objects[i].id == editAreaId) {
                return objects[i]

            }
        }
    },

    getLowestObjectIndex: function(object) {
        var canvas = this.canvas,
            objects = canvas.getObjects()


        if (object.clipTo !== null) {
            // Edit area's child object.
            // Find the object's edit area index. Can't go beneath it.
            var index = this.getEditAreaIndex(object.editAreaId)

            if (index != -1) {
                return index + 1

            }
        }

        if (object.id == 'background') {
            // Background object.
            var bgObjects = this.getSelectableBackgroundObjects(RolandKioskPrint.app.constants.OBJECT_SOURCE_PMD)


            if (this.isProductModelDesigner) {
                // Can't go beneath the lowest background object.
                return objects.indexOf(bgObjects[0])

            } else {
                if (bgObjects.length > 0) {
                    // Can't go beneath the highest background object of product model designer.
                    return objects.indexOf(bgObjects[bgObjects.length - 1]) + 1

                } else {
                    // Can't go beneath the lowest product designer background object.
                    bgObjects = this.getSelectableBackgroundObjects(RolandKioskPrint.app.constants.OBJECT_SOURCE_PD)

                    return objects.indexOf(bgObjects[0])

                }
            }
        }

        if (this.isProductModelDesigner &&
            (object.printType == RolandKioskPrint.app.constants.PRINT_TYPE_FOIL ||
             object.printType == RolandKioskPrint.app.constants.PRINT_TYPE_METAL)) {
            // Can't go beneath the corresponding imprint area.
            var index = this.getImprintAreaIndex(object.printType)

            if (index != -1) {
                return index + 1

            }
        }

        if (this.isProductModelDesigner) {
            // Design objects in product model designer can't go beneath background objects.
            return this.getNextBGObjectIndex()

        } else {
            // Design objects in product designer can't go beneath the lowest product designer object.
            for (var length = objects.length, i = length - 1
 i >= 0; i--) {
                if (objects[i].sourceType != RolandKioskPrint.app.constants.OBJECT_SOURCE_PD ||
                    objects[i].id == 'background') {
                    return i + 1

                }
            }
        }

        return this.lowestFgObjectIndex

    },

    getHighestObjectIndex: function(object) {
        var canvas = this.canvas,
            objects = canvas.getObjects()


        if (object.id == 'background') {
            // If background object, can't come above any non-background object.
            return this.getNextBGObjectIndex()

        }

        if (object.clipTo !== null) {
            // Edit area's child object.
            // First find the object's edit area index.
            var index = this.getEditAreaIndex(object.editAreaId)

            if (index != -1) {
                // Find the last object for this edit area.
                var i = index + 1,
                    length = objects.length


                for (
 i < length; i++) {
                    if (objects[i].editAreaId != object.editAreaId) {
                        return i

                    }
                }
            }
        }

        return objects.length

    },

    padString: function(pad, str, padLeft) {
        if (typeof str == 'undefined') {
            return pad

        }

        if (padLeft) {
            return (pad + str).slice(-pad.length)

        } else {
            return (str + pad).substring(0, pad.length)

        }
    },

    shouldGenerateSpecialColorObjects: function(object) {
        // Exclude cut paths/text, outlines and edit areas.
        if (object.isCutPath || object.isOutlinePath || object.editAreaType) {
            return false

        }

        // Exclude groups (including clipart path groups).
        // Exclude clipping groups.
        // Special color objects get generated for child objects.
        if (object.type == 'group' || object.type == 'clippingGroup') {
            return false

        }

        return true

    },

    shouldReplaceColor: function(object) {
        // Exclude cut paths/text and edit areas.
        if (object.isCutPath || object.editAreaType) {
            return false

        }

        // Exclude images and groups.
        if (object.type == 'image' || object.type == 'clippingGroup' || object.type == 'group') {
            return false

        }

        return true

    },

    getMaskArea: function() {
        var canvas = this.canvas

        var objects = canvas.getObjects()


        // No need to iterate over all objects.
        // "mask" object if present, is always the first object.
        if (objects.length !== 0 && objects[0].id == "mask") {
            return objects[0]

        }
    },

    getMarginArea: function() {
        var canvas = this.canvas

        var objects = canvas.getObjects()


        // No need to iterate over all objects.
        // "margin" object if present, is either the first or second object.
        if (objects.length !== 0 && objects[0].id == "margin") {
            return objects[0]

        }

        if (objects.length > 1 && objects[1].id == "margin") {
            return objects[1]

        }
    },

    getImprintArea: function(printType) {
        var canvas = this.canvas

        var objects = canvas.getObjects()


        var imprintAreaId =
            (printType == RolandKioskPrint.app.constants.PRINT_TYPE_FOIL) ? 'foilImprintArea' : 'metalImprintArea'


        for (var i = 0, length = objects.length
 i < length; i++) {
            if (objects[i].get('id') == imprintAreaId) {
                return objects[i]

            }
        }
    },

    getImprintAreaIndex: function(printType) {
        var canvas = this.canvas

        var objects = canvas.getObjects()


        var imprintAreaId =
            (printType == RolandKioskPrint.app.constants.PRINT_TYPE_FOIL) ? 'foilImprintArea' : 'metalImprintArea'


        for (var i = 0, length = objects.length
 i < length; i++) {
            if (objects[i].get('id') == imprintAreaId) {
                return i

            }
        }
        return -1

    },

    drawClipArea: function(ctx, clipArea, stroke, strokeWidth, strokeDashArray, fill, canvas) {
        // Since the fabric canvas.clipTo is called without the canvas viewport transform
        // in place, we take care of the canvas scaling here.
        ctx.save()

        ctx.beginPath()

        ctx.transform.apply(ctx, canvas.viewportTransform)


        if (stroke) {
            clipArea.set('strokeWidth', strokeWidth)

        }

        // Draw the clip area. This also leaves the clip path stroke in ctx, which
        // gets set as the canvas clip on return from this function.
        clipArea.set('visible', true)

        clipArea.render(ctx)

        clipArea.set('visible', false)


        if (fill) {
            ctx.fillStyle = fill

            ctx.fill()

        }

        if (stroke) {
            ctx.strokeStyle = stroke

            ctx.lineWidth = strokeWidth

            ctx.setLineDash(strokeDashArray)

            ctx.stroke()

        }

        ctx.restore()

    },

    getBackgroundObjects: function() {
        var objects = this.canvas.getObjects()

        var bgObjects = []


        objects.forEach(function(object) {
            if (object.get('id') == 'background') {
                bgObjects.push(object)

            }
        })


        return bgObjects

    },

    getSelectableBackgroundObjects: function(sourceType) {
        var objects = this.canvas.getObjects()

        var bgObjects = []


        objects.forEach(function(object) {
            if (object.get('id') == 'background') {
                var objectType = object.get('type')

                if (objectType != 'rect' && objectType != 'grid') {
                    if (!sourceType || sourceType == object.sourceType) {
                        bgObjects.push(object)

                    }
                }
            }
        })


        return bgObjects

    },

    getNextBGObjectIndex: function(objects) {
        // If we already have any background objects, the next one goes above.
        var bgObjects = this.getBackgroundObjects()


        if (bgObjects.length > 0) {
            var objects = this.canvas.getObjects()

            return objects.indexOf(bgObjects[bgObjects.length - 1]) + 1

        }

        // Otherwise, add just after the mask/margin objects.
        var index = -1


        var mask = this.getMaskArea()

        if (mask) {
            index++

        }

        var margin = this.getMarginArea()

        if (margin) {
            index++

        }

        return index + 1

    },

    getBGColorObjectIndex: function() {
        // Add background color object just after the mask/margin objects.
        var index = -1


        var mask = this.getMaskArea()

        if (mask) {
            index++

        }

        var margin = this.getMarginArea()

        if (margin) {
            index++

        }

        return index + 1

    },

    getProductMargins: function() {
        var data = this.getProductSizeData()


        // If we have a margin area, return its bounds for the margins.
        var marginArea = this.getMarginArea()


        // Margin area can be a fabric group (from SVG), or a rect object (if default).
        if (marginArea) {
            if (marginArea.get('type') == 'group') {
                // SVG margin area.
                var bounds = this.getPathGroupBoundingRect(marginArea)


                var leftMargin = bounds.left

                var topMargin = bounds.top

                var rightMargin = data.widthMM - (bounds.left + bounds.width)

                var bottomMargin = data.heightMM - (bounds.top + bounds.height)

                return {
                    widthMM: data.widthMM,
                    heightMM: data.heightMM,
                    leftMarginMM: leftMargin,
                    topMarginMM: topMargin,
                    rightMarginMM: rightMargin,
                    bottomMarginMM: bottomMargin
                }

            } else {
                // The default margins.
                return data

            }
        }

        // If we have a mask area, return its bounds for the margins.
        var maskArea = this.getMaskArea()


        // Mask area is a fabric group (from SVG).
        if (maskArea && maskArea.get('type') == 'group') {
            // SVG mask area.
            var bounds = this.getPathGroupBoundingRect(maskArea)

            return {
                widthMM: data.widthMM,
                heightMM: data.heightMM,
                leftMarginMM: bounds.left,
                topMarginMM: bounds.top,
                rightMarginMM: data.widthMM - (bounds.left + bounds.width),
                bottomMarginMM: data.heightMM - (bounds.top + bounds.height)
            }

        }

        // Otherwise, return the product size data itself.
        return data

    },

    getProductBounds: function() {
        var data = this.getProductMargins()


        return {
            left: data.leftMarginMM,
            top: data.topMarginMM,
            width: data.widthMM - data.leftMarginMM - data.rightMarginMM,
            height: data.heightMM - data.topMarginMM - data.bottomMarginMM
        }

    },

    getPathGroupBoundingRect: function(pathGroup) {
        var groupBounds

        var objects = pathGroup.getObjects()


        for (var i = 0, length = objects.length
 i < length; i++) {
            var objectBounds = this.getGroupChildBoundingRect(objects[i])


            objectBounds.right = objectBounds.left + objectBounds.width

            objectBounds.bottom = objectBounds.top + objectBounds.height


            if (!groupBounds) {
                groupBounds = objectBounds

            } else {
                groupBounds = this.getUnionBounds(groupBounds, objectBounds)

            }
        }

        return groupBounds

    },

    getGroupChildBoundingRect: function(object) {
        var matrix = object.calcTransformMatrix()

        var options = fabric.util.qrDecompose(matrix)


        var translateMatrix = [1, 0, 0, 1, options.translateX, options.translateY]

        var rotateMatrix = fabric.iMatrix.concat()

        if (options.angle) {
            var theta = fabric.util.degreesToRadians(options.angle),
                cos = Math.cos(theta),
                sin = Math.sin(theta)

            rotateMatrix = [cos, sin, -sin, cos, 0, 0]

        }

        var finalMatrix = fabric.util.multiplyTransformMatrices(translateMatrix, rotateMatrix)


        var transformPoint = fabric.util.transformPoint

        var p = object._getNonTransformedDimensions(),
            matrix = fabric.util.customTransformMatrix(options.scaleX, options.scaleY, options.skewX),
            dim = transformPoint(p, matrix),
            w = dim.x / 2,
            h = dim.y / 2,
            tl = transformPoint({ x: -w, y: -h }, finalMatrix),
            tr = transformPoint({ x: w, y: -h }, finalMatrix),
            bl = transformPoint({ x: -w, y: h }, finalMatrix),
            br = transformPoint({ x: w, y: h }, finalMatrix)


        // corners
        var points = [
            new fabric.Point(tl.x, tl.y),
            new fabric.Point(tr.x, tr.y),
            new fabric.Point(br.x, br.y),
            new fabric.Point(bl.x, bl.y)
        ]


        return fabric.util.makeBoundingBoxFromPoints(points)

    },

    pruneGroupSelection: function(objects) {
        var isProductDesigner =
            (RolandKioskPrint.AppData.appMode == RolandKioskPrint.app.constants.APP_MODE_PRODUCT_DESIGNER)


        if (isProductDesigner && this.hasOneOrMoreEditAreas()) {
            // If there is an edit area in the selection range, and if there are other normal
            // objects, we cancel the selected state of the edit area.
            var hasEditAreaSelection = false,
                hasNormalObjectSelection = false,
                i


            for (i = objects.length
 i--; ) {
                if (objects[i].editAreaType) {
                    hasEditAreaSelection = true

                } else {
                    hasNormalObjectSelection = true

                }
            }

            // If we have both edit areas and other objects in the selection, remove the edit areas.
            if (hasEditAreaSelection && hasNormalObjectSelection) {
                for (i = objects.length
 i--; ) {
                    if (objects[i].editAreaType) {
                        objects.splice(i, 1)

                    }
                }
            }
        }
    },

    canAddObject: function() {
        var canvas = this.canvas,
            objects = canvas.getObjects()


        // Get the number of objects already added.
        var isProductDesigner = RolandKioskPrint.AppData.isProductDesigner()


        var objectCount = this.getObjectCountByAppMode(objects, isProductDesigner, this.excludeSpecialObjects)

        if (objectCount >= RolandKioskPrint.app.constants.MAX_OBJECT_COUNT) {
            Ext.toast(RolandKioskPrint.app.getString('message.designer.cantAddObjectCountExceeds'))

            return false

        }

        return true

    },

    canCopyObjects: function(objects) {
        var copyCount = this.getObjectCount(objects, this.excludeSpecialObjects)


        // Check if the object count will exceed the limit after copying.
        if (copyCount * 2 <= RolandKioskPrint.app.constants.MAX_OBJECT_COUNT) {
            // Get the number of objects already present.
            var isProductDesigner = RolandKioskPrint.AppData.isProductDesigner()


            var canvas = this.canvas

            var objectCount = this.getObjectCountByAppMode(canvas.getObjects(), isProductDesigner, this.excludeSpecialObjects)

            if (objectCount + copyCount <= RolandKioskPrint.app.constants.MAX_OBJECT_COUNT) {
                return true
 // Allow copying
            }
        }

        Ext.toast(RolandKioskPrint.app.getString('message.designer.cantCopyObjectsCountExceeds'))

        return false

    },

    getObjectCountByAppMode: function(objects, isProductDesigner, excludeCallback) {
        var sourceType = (
            isProductDesigner ? RolandKioskPrint.app.constants.OBJECT_SOURCE_PD
                              : RolandKioskPrint.app.constants.OBJECT_SOURCE_PMD
        )


        var objectCount = 0

        for (var i = 0, length = objects.length
 i < length; i++) {
            var object = objects[i]


            // Objects within a fabric group are counted separately.
            if (object.get('type') == 'group' && !object.isPathGroup) {
                objectCount += this.getObjectCountByAppMode(object.getObjects(), isProductDesigner)

            } else if (object.sourceType == sourceType || (isProductDesigner && this.isObjectWithinEditArea(object))) {
                // For product designer, we count both the product designer created objects, or those
                // created in product model designer, but belonging to an edit area and therefore editable.
                if (!excludeCallback || !excludeCallback(object)) {
                    objectCount++

                }
            }
        }

        return objectCount

    },

    getObjectCount: function(objects, excludeCallback) {
        var objectCount = 0

        for (var i = 0, length = objects.length
 i < length; i++) {
            var object = objects[i]


            // Objects within a fabric group are counted separately.
            if (object.get('type') == 'group' && !object.isPathGroup) {
                objectCount += this.getObjectCount(object.getObjects())

            } else {
               if (!excludeCallback || !excludeCallback(object)) {
                objectCount++

            }
        }
        }

        return objectCount

    },

    excludeSpecialObjects: function(object) {
        // Exclude any background objects, edit areas and imprint areas.
        return object.id == 'background' || object.editAreaType || RolandKioskPrint.AppData.isImprintArea(object)

    },

    segregateSVGObjects: function(objects) {
        var maskArea

        var marginArea

        var foilImprintArea

        var metalImprintArea

        var backgroundObjects = []

        var designObjects = []


        // Determine the mask, margin, foil imprint, background, and design objects.
        for (var i = 0, length = objects.length
 i < length; i++) {
            var object = objects[i]

            var id = object.get('id')

            if (id) {
                id = id.toLowerCase()

            }

            // Below we check if id begins with specific keywords like mask, margin etc.
            if (id && id.startsWith('mask')) {
                // Mask object.
                if (!maskArea) {
                    maskArea = object

                    maskArea.set({
                        fill: false,
                        stroke: false,
                        objectCaching: false
                    })


                    this.resetStrokeWidth(maskArea)

                }
            } else if (id && id.startsWith('margin')) {
                // Margin area object.
                if (!marginArea) {
                    marginArea = object

                    marginArea.set({
                        fill: false,
                        stroke: false,
                        objectCaching: false
                    })


                    this.resetStrokeWidth(marginArea)

                }
            } else if (id && id.startsWith('foilimprint')) {
                // Foil imprint area.
                if (!foilImprintArea && object.type == 'rect') {
                    foilImprintArea = object
 // We only need its position
                }
            } else if (id && id.startsWith('metalimprint')) {
                // Metal imprint area.
                if (!metalImprintArea && object.type == 'rect') {
                    metalImprintArea = object
 // We only need its position
                }
            } else if (id && id.startsWith('background')) {
                // Background object.
                backgroundObjects.push(object)

            } else if (id && id.startsWith('cutcontour')) {
                // Cut object.
                object.set({
                    'fill': '',
                    'stroke': RolandKioskPrint.app.constants.CUT_PATH_STROKE_COLOR,
                    'deviceStroke': true,
                    'deviceStrokeWidth': RolandKioskPrint.app.constants.CUT_LINE_STROKE_WIDTH,
                    'perPixelTargetFind': true,
                    'targetFindTolerance': RolandKioskPrint.app.constants.CUT_LINE_HIT_TOLERANCE,
                    'isCutPath': true, // Custom property
                    'objectCaching': false,
                    'printType': RolandKioskPrint.app.constants.PRINT_TYPE_CUT
                })


                this.resetStrokeWidth(object)


                designObjects.push(object)

            } else if (id && (id.startsWith('imagearea') || id.startsWith('textarea') ||
                              id.startsWith('freearea') || id.startsWith('foilarea') ||
                              id.startsWith('metalarea')|| id.startsWith('cutarea'))) {
                var strokeColor,
                    areaType


                areaType = ''

                if (this.foilPrint && id.startsWith('foilarea')) {
                    strokeColor = RolandKioskPrint.app.constants.FOIL_AREA_STROKE_COLOR

                    areaType = RolandKioskPrint.app.constants.EDIT_AREA_FOIL

                } else if (this.metalPrint && id.startsWith('metalarea')) {
                    strokeColor = RolandKioskPrint.app.constants.METAL_AREA_STROKE_COLOR

                    areaType = RolandKioskPrint.app.constants.EDIT_AREA_METAL

                } else if (this.cutPrint && id.startsWith('cutarea')) {
                    if (object.type != 'rect') {
                        continue

                    }
                    strokeColor = RolandKioskPrint.app.constants.CUT_AREA_STROKE_COLOR

                    areaType = RolandKioskPrint.app.constants.EDIT_AREA_CUT

                } else if (!this.foilPrint && !this.metalPrint && !this.cutPrint) {
                    if (id.startsWith('imagearea')) {
                        strokeColor = RolandKioskPrint.app.constants.IMAGE_AREA_STROKE_COLOR

                        areaType = RolandKioskPrint.app.constants.EDIT_AREA_IMAGE

                    } else if (id.startsWith('textarea')) {
                        strokeColor = RolandKioskPrint.app.constants.TEXT_AREA_STROKE_COLOR

                        areaType = RolandKioskPrint.app.constants.EDIT_AREA_TEXT

                    } else if (id.startsWith('freearea')) {
                        strokeColor = RolandKioskPrint.app.constants.FREE_AREA_STROKE_COLOR

                        areaType = RolandKioskPrint.app.constants.EDIT_AREA_FREE

                    }
                }

                if (!areaType) {
                    continue

                }

                object.set({
                    'fill': false,
                    'stroke': strokeColor,
                    'id': 'editarea-' + this.canvas.nextEditAreaId,
                    'deviceStroke': true,
                    'deviceStrokeWidth': RolandKioskPrint.app.constants.EDIT_AREA_STROKE_WIDTH,
                    'perPixelTargetFind': true,
                    'targetFindTolerance': RolandKioskPrint.app.constants.EDIT_AREA_HIT_TOLERANCE,
                    'editAreaType': areaType, // Custom property
                    'objectCaching': false,
                    'printType': this.printType
                })


                this.resetStrokeWidth(object)


                designObjects.push(object)

                this.canvas.nextEditAreaId++

            } else if(this.printType == RolandKioskPrint.app.constants.PRINT_TYPE_CUT) {
                continue

            } else {
                object.printType = this.printType

                var specialColor = this.defaultSpecialColor

                if (id) {
                    var idSplit = id.split(':')

                    if (idSplit.length > 2 && idSplit[2] !== '') {
                        specialColor = idSplit[2]

                        specialColor = this.padString('000', specialColor, false)

                    }
                }
                object.set('specialColor', specialColor)

                if (!object.stroke) {
                    this.resetStrokeWidth(object)

                }
                designObjects.push(object)

            }
        }

        return {
            mask: maskArea,
            margin: marginArea,
            foilImprint: foilImprintArea,
            metalImprint: metalImprintArea,
            background: backgroundObjects,
            design: designObjects
        }

    },

    resetStrokeWidth: function(object) {
        var prevBounds = object.getBoundingRect(true)


        object.set('strokeWidth', 0)

        object.setCoords()


        var newBounds = object.getBoundingRect(true),
            dx = (prevBounds.width - newBounds.width) / 2,
            dy = (prevBounds.height - newBounds.height) / 2


        object.set({
            left: object.left + dx,
            top: object.top + dy
        })

    },

    getSVGViewBox: function(printType) {
        var data = this.productSizeData

        var viewbox = {
            top: 0,
            left: 0,
            bottom: data.heightMM,
            right: data.widthMM,
            width: 0,
            height: 0
        }


        if (printType == RolandKioskPrint.app.constants.PRINT_TYPE_FOIL ||
            printType == RolandKioskPrint.app.constants.PRINT_TYPE_METAL) {
            var bounds

            var imprintArea = this.getImprintArea(printType)

            if (imprintArea) {
                bounds = imprintArea.getBoundingRect(true)

            } else {
                bounds = this.getContentBounds(printType)

            }

            viewbox.left = bounds.left

            viewbox.top = bounds.top

            viewbox.right = bounds.left + bounds.width

            viewbox.bottom = bounds.top + bounds.height


        } else if (printType == RolandKioskPrint.app.constants.PRINT_TYPE_CUT) {
            var bounds = this.getCutContentBounds()

            if (bounds) {
                viewbox.left = bounds.left

                viewbox.top = bounds.top

                viewbox.right = bounds.left + bounds.width

                viewbox.bottom = bounds.top + bounds.height

            }
        } else {
            if (data.leftMarginMM < 0) {
                viewbox.left += data.leftMarginMM

            }
            if (data.topMarginMM < 0) {
                viewbox.top += data.topMarginMM

            }
            if (data.rightMarginMM < 0) {
                viewbox.right += Math.abs(data.rightMarginMM)

            }
            if (data.bottomMarginMM < 0) {
                viewbox.bottom += Math.abs(data.bottomMarginMM)

            }
        }

        viewbox.width = viewbox.right - viewbox.left

        viewbox.height = viewbox.bottom - viewbox.top


        return viewbox

    },

    fixupGroupColor: function(group) {
        if (group.isSameColor()) {
            // When loading a group with all paths having the same fill
            // and stroke color (a simple case is that of a single child path),
            // fabric.js ends up applying none color to the child paths.
            // We work around this issue here, by setting the paths fill and
            // stroke color on the path group. This way, the paths color stays as is.
            var paths = group.getObjects()


            var firstPathFill = paths[0].get('fill') || ''

            var firstPathStroke = paths[0].get('stroke') || ''


            if (typeof firstPathFill == 'string' &&
                typeof firstPathStroke == 'string') {
                group.set({
                    'fill': firstPathFill,
                    'stroke': firstPathStroke
                })

            }
        }
    },

    setProductMargins: function(marginGroup) {
        // Update the product model margins based on SVG margin group.
        var modelData = RolandKioskPrint.AppData.productModelData

        var sizeData = this.productSizeData

        var bounds = this.getPathGroupBoundingRect(marginGroup)


        sizeData.leftMarginMM = bounds.left

        sizeData.topMarginMM = bounds.top

        sizeData.rightMarginMM = sizeData.widthMM - (bounds.left + bounds.width)

        sizeData.bottomMarginMM = sizeData.heightMM - (bounds.top + bounds.height)


        modelData.leftMargin = sizeData.leftMarginMM

        modelData.topMargin = sizeData.topMarginMM

        modelData.rightMargin = sizeData.rightMarginMM

        modelData.bottomMargin = sizeData.bottomMarginMM

    },

    getAllEditAreas: function() {
        var canvas = this.canvas


        if (RolandKioskPrint.AppData.isProductDesigner()) {
            return canvas.imageAreaList.concat(
                canvas.textAreaList,
                canvas.freeAreaList,
                canvas.foilAreaList,
                canvas.metalAreaList,
                canvas.cutAreaList
            )

        } else {
            var objects = canvas.getObjects(),
                editAreas = []


            objects.forEach(function(o) {
                if (o.editAreaType) {
                    editAreas.push(o)

                }
            })

            return editAreas

        }
    },

    hasNegativeMargins: function() {
        var data = this.productSizeData


        return (data.leftMarginMM < 0 || data.topMarginMM < 0 ||
                data.rightMarginMM < 0 || data.bottomMarginMM < 0)

    },

    getContentBounds: function(printType) {
        var canvas = this.canvas

        var objects = canvas.getObjects()


        var contentBounds

        for (var i = 0, length = objects.length
 i < length; i++) {
            var object = objects[i]

            var id = object.get('id')


            // Exclude margin and mask.
            // Exclude background objects.
            // Exclude foil imprint area object.
            if (id == 'margin' || id == 'mask' || id == 'background' || RolandKioskPrint.AppData.isImprintArea(object)) {
                // Not a content object.
                continue

            }

            // Exclude objects in edit areas (we take the edit area bounds).
            // Exclude cut paths.
            if (object.editAreaId || object.isCutPath) {
                continue

            }

            // Exclude other print type objects.
            if (printType && object.printType !== printType) {
                continue

            }

            var objectBounds

            if (object.get('type') == 'group' && object.isPathGroup) {
                objectBounds = this.getPathGroupBoundingRect(object)

            } else {
                objectBounds = this.getBoundingRect(object)

            }

            objectBounds.right = objectBounds.left + objectBounds.width

            objectBounds.bottom = objectBounds.top + objectBounds.height


            if (!contentBounds) {
                contentBounds = objectBounds

            } else {
                // Take the overall bounds.
                contentBounds = this.getUnionBounds(contentBounds, objectBounds)

            }
        }

        return contentBounds

    },

    getCutContentBounds: function() {
        var canvas = this.canvas

        var objects = canvas.getObjects()


        var contentBounds

        for (var i = 0, length = objects.length
 i < length; i++) {
            var object = objects[i]


            // Exclude objects in edit areas (we take the edit area bounds).
            if (object.editAreaId) {
                continue

            }

            if (!object.isCutPath && !object.editAreaType && object.type != 'group') {
                continue

            }

            var objectBounds

            if (object.get('type') == 'group' && object.isPathGroup) {
                objectBounds = this.getPathGroupBoundingRect(object)

            } else {
                objectBounds = this.getBoundingRect(object)

            }

            objectBounds.right = objectBounds.left + objectBounds.width

            objectBounds.bottom = objectBounds.top + objectBounds.height


            if (!contentBounds) {
                contentBounds = objectBounds

            } else {
                // Take the overall bounds.
                contentBounds = this.getUnionBounds(contentBounds, objectBounds)

            }
        }
        if (contentBounds) {
            var data = this.getProductBounds()

            if (contentBounds.left < data.left) {
                contentBounds.left = data.left

            }
            if (contentBounds.top < data.top) {
                contentBounds.top = data.top

            }
            var right = (data.left + data.width),
                bottom = (data.top + data.height)

            if (contentBounds.right > right) {
                contentBounds.right = right

            }
            if (contentBounds.bottom > bottom) {
                contentBounds.bottom = bottom

            }
            contentBounds.width = contentBounds.right - contentBounds.left

            contentBounds.heigth = contentBounds.bottom - contentBounds.top

        }

        return contentBounds

    },

    contentExceedsPrintableArea: function(printType) {
        var imprintArea = this.getImprintArea(printType)

        if (!imprintArea) {
            return false

        }

        // Get the printable bounds.
        var printableBounds = this.getBoundingRect(imprintArea)


        // And the content bounds.
        var contentBounds = this.getContentBounds(printType)


        // Compare the two.
        if (!contentBounds) {
            return false

        }

        // Add tolerance to the comparisons below.
        var EPSILON = 1e-3


        return (contentBounds.left < printableBounds.left - EPSILON ||
                contentBounds.top < printableBounds.top - EPSILON ||
                contentBounds.right > printableBounds.right + EPSILON ||
                contentBounds.bottom > printableBounds.bottom + EPSILON)

    },

    defineImageAdjustFilter: function() {
        var filters = fabric.Image.filters,
            extend = fabric.util.object.extend


        filters.ImageAdjust = fabric.util.createClass(filters.BaseFilter, /** @lends fabric.Image.filters.ImageAdjust.prototype */ {
            /**
             * Filter type
             * @param {String} type
             * @default
             */
            type: 'ImageAdjust',

            /**
             * Constructor
             * @memberOf fabric.Image.filters.GradientTransparency.prototype
             * @param {Object} [options] Options object
             * @param {Number} [options.brightness] brightness value
             * @param {Number} [options.contrast] contrast value
             * @param {Number} [options.gamma] contrast value
             * @param {Number} [options.background] background grayness value to blend with
             */
            initialize: function(options) {
                options = options || {}

                this.brightness = options.brightness || 0

                this.contrast = options.contrast || 0

                this.gamma = options.gamma || 0

                this.background = options.background || 0

            },

            /**
             * Apply the ImageAdjust operation to a Uint8Array representing the pixels of an image.
             *
             * @param {Object} options
             * @param {ImageData} options.imageData The Uint8Array to be filtered.
             */
            applyTo2d: function(options) {
                var imageData = options.imageData,
                    data = imageData.data, i,
                    len = data.length


                if (this.brightness || this.contrast || this.gamma) {
                    var gammaTable,
                        contrastTable,
                        gamma = this.gamma,
                        contrast = this.contrast,
                        brightness = this.brightness


                    if (contrast) {
                        contrastTable = this._getContrastTable()

                    }
                    if (gamma) {
                        gammaTable = this._getGammaTable()

                    }

                    var nGray, alpha, alphaRatio

                    var background = this.background

                    for (i = 0
 i < len; i += 4) {
                        alpha = data[i + 3]

                        alphaRatio = alpha / 255


                        // Applying data[i] * alphaRatio + 255 * (1 - alphaRatio)
                        nGray = Math.floor((data[i] - background) * alphaRatio + background)
 // Assumes we are working on grayscale

                        if (nGray === 0) {
                            continue

                        }

                        // Gamma correction.
                        if (gamma) {
                            nGray = gammaTable[nGray]

                        }

                        // Adjust contrast.
                        if (contrast) {
                            nGray = contrastTable[nGray]

                        }

                        // Adjust brightness.
                        if (brightness !== 0) {
                            nGray += brightness

                        }

                        if (nGray < 0) {
                            nGray = 0

                        } else if (nGray > 255) {
                            nGray = 255

                        }
                        data[i] = nGray

                        data[i + 1] = nGray

                        data[i + 2] =  nGray

                        data[i + 3] = (alpha > 0) ? 255 : 0

                    }
                }
            },

            _getGammaTable() {
                if (this.cachedGamma != this.gamma) {
                    var gamma = this.gamma, i, r, v

                    this.cachedGamma = gamma

                    if (gamma < 0) {
                        r =  1000.0 / (1000 + gamma)

                    } else {
                        r = 100.0 / (gamma + 100)

                    }
                    var gammaTable = []

                    for (i = 0
 i < 256; i++) {
                        v = Math.trunc(Math.pow(i / 255.0, r) * 255.0)

                        if (v < 0) {
                            v = 0

                        } else if (v > 255) {
                            v = 255

                        }
                        gammaTable[i] = v

                    }
                    this.cachedGammaTable = gammaTable

                }
                return this.cachedGammaTable

            },

            _getContrastTable() {
                if (this.cachedContrast != this.contrast){
                    var contrast = this.contrast, i, v

                    this.cachedContrast = contrast


                    var contrastTable = []

                    for (i = 0
 i < 256; i++) {
                        v = (i - 127) *  (100 + contrast) / (100 - contrast) + 127

                        if (v < 0) {
                            v = 0

                        } else if (v > 255) {
                            v = 255

                        }
                        contrastTable[i] = v

                    }
                    this.cachedContrastTable = contrastTable

                }
                return this.cachedContrastTable

            },

            /**
             * Returns object representation of an instance
             * @return {Object} Object representation of an instance
             */
            toObject: function() {
                return extend(this.callSuper('toObject'), {
                    brightness: this.brightness,
                    contrast: this.contrast,
                    gamma: this.gamma,
                    background: this.background
                })

            }
        })


        fabric.Image.filters.ImageAdjust.fromObject = function(object, callback) {
            object = object || { }

            object.type = 'ImageAdjust'

            return fabric.Image.filters.BaseFilter.fromObject(object, callback)

        }

    },

    defineFoilImprintFabricClass: function() {
        // Define the foil imprint fabric area extended class.
        fabric.FoilImprintArea = fabric.util.createClass(fabric.Rect, /** @lends fabric.FoilImprintArea.prototype */ {
            type: 'foil-imprint-area',
            initialize: function(options) {
                this.callSuper('initialize', options)

                // Disallow rotation and scaling. Can be moved.
                // Disable object caching, so that we can draw fine grid lines every time.
                this.lockRotation = true

                this.hasRotatingPoint = false

                this.lockScalingX =  true

                this.lockScalingY =  true

                this.objectCaching = false

                this.strokeWidth = 0

                // Allow lock/unlock control.
                this.hasControls = true

                this.setControlsVisibility({
                    br: false,
                    mb: false,
                    ml: false,
                    mr: false,
                    mt: false,
                    tl: false,
                    tr: false,
                    mtr: false
                })

            },
            _render: function(ctx, noTransform) {
                var width = this.width,
                    height = this.height,
                    x = noTransform ? this.left : -this.width / 2,
                    y = noTransform ? this.top : -this.height / 2


                ctx.save()

                ctx.globalAlpha = 0.5


                // First draw the background.
                ctx.fillStyle = this.fill

                ctx.fillRect(x, y, width, height)


                // Now draw the grid divisions.
                var numDivisions = RolandKioskPrint.app.constants.FOIL_PRINT_PRINTABLE_SIZE / RolandKioskPrint.app.constants.FOIL_PRINT_TRAY_GRID_SIZE

                var gap = width / numDivisions


                var rr = this.canvas.viewportTransform[0]

                for (var i = 1
 i < numDivisions; i++) {
                    if (i == (numDivisions / 2)) {
                        // Draw the center lines at the end.
                        continue

                    } else {
                        ctx.lineWidth = 1 / rr

                        ctx.strokeStyle = this.stroke

                    }

                    this._drawGridLinesPair(ctx, x, y, gap * i)

                }

                // When Printable Area size is 80, draw non printable area.
                if (RolandKioskPrint.app.constants.FOIL_PRINT_PRINTABLE_SIZE == RolandKioskPrint.app.constants.FOIL_PRINT_TRAY_SIZE) {
                    ctx.globalAlpha = 0.5

                    var nonPrintX = RolandKioskPrint.app.constants.FOIL_NON_PRINTABLE_X

                    var nonPrintY = RolandKioskPrint.app.constants.FOIL_NON_PRINTABLE_Y

                    var slideStartPositionX = RolandKioskPrint.app.constants.FOIL_PRINT_PRINTABLE_SIZE - nonPrintX

                    var slideStartPositionY = RolandKioskPrint.app.constants.FOIL_PRINT_PRINTABLE_SIZE - nonPrintY

                    ctx.fillStyle = RolandKioskPrint.app.constants.FOIL_NON_PRINTABLE_AREA_COLOR

                    ctx.fillRect(x, y, nonPrintX, nonPrintY)

                    ctx.fillRect(x + slideStartPositionX, y, nonPrintX, nonPrintY)

                    ctx.fillRect(x, y + slideStartPositionY, nonPrintX, nonPrintY)

                    ctx.fillRect(x + slideStartPositionX, y + slideStartPositionY, nonPrintX, nonPrintY)


                    // Draw the Non printable grid line.
                    ctx.beginPath()

                    ctx.globalAlpha = 1

                    ctx.strokeStyle = RolandKioskPrint.app.constants.FOIL_NON_PRINTABLE_AREA_GRID_COLOR


                    ctx.moveTo(x, y)

                    ctx.lineTo(x + nonPrintX, y)

                    ctx.lineTo(x + nonPrintX, y + nonPrintY)

                    ctx.lineTo(x, y + nonPrintY)

                    ctx.closePath()


                    ctx.moveTo(x + slideStartPositionX, y)

                    ctx.lineTo(x + nonPrintX + slideStartPositionX, y)

                    ctx.lineTo(x + nonPrintX + slideStartPositionX, y + nonPrintY)

                    ctx.lineTo(x + slideStartPositionX, y + nonPrintY)

                    ctx.closePath()


                    ctx.moveTo(x + slideStartPositionX, y + slideStartPositionY)

                    ctx.lineTo(x + nonPrintX + slideStartPositionX, y + slideStartPositionY)

                    ctx.lineTo(x + nonPrintX + slideStartPositionX, y + nonPrintY + slideStartPositionY)

                    ctx.lineTo(x + slideStartPositionX, y + nonPrintY + slideStartPositionY)

                    ctx.closePath()


                    ctx.moveTo(x, y + slideStartPositionY)

                    ctx.lineTo(x + nonPrintX, y + slideStartPositionY)

                    ctx.lineTo(x + nonPrintX, y + nonPrintY + slideStartPositionY)

                    ctx.lineTo(x, y + nonPrintY + slideStartPositionY)

                    ctx.closePath()


                    ctx.stroke()

                }

                // Draw the center lines thicker and in darker color.
                ctx.lineWidth = (1 / rr) * 2

                ctx.strokeStyle = RolandKioskPrint.app.constants.FOIL_PRINTABLE_AREA_GRID_CENTER_LINES_COLOR


                i = numDivisions / 2

                this._drawGridLinesPair(ctx, x, y, gap * i)


                ctx.restore()

            },
            _drawGridLinesPair: function(ctx, x, y, d) {
                var width = this.width,
                    height = this.height


                // Draw the horizontal line.
                ctx.beginPath()

                ctx.moveTo(x, y + d)

                ctx.lineTo(x + width, y + d)

                ctx.stroke()


                // And the vertical.
                ctx.beginPath()

                ctx.moveTo(x + d, y)

                ctx.lineTo(x + d, y + height)

                ctx.stroke()

            },
            toObject: function(propertiesToInclude) {
                return this.callSuper('toObject', [
                    'lockRotation',
                    'hasRotatingPoint',
                    'lockScalingX',
                    'lockScalingY',
                    'hasControls'
                ].concat(propertiesToInclude))

            }
        })


        fabric.FoilImprintArea.fromObject = function(object, callback, forceAsync) {
            return fabric.Object._fromObject('FoilImprintArea', object, callback, forceAsync)

        }

    },

    defineMetalImprintFabricClass: function() {
        // Define the metal imprint fabric area extended class.
        fabric.MetalImprintArea = fabric.util.createClass(fabric.Rect, /** @lends fabric.MetalImprintArea.prototype */ {
            type: 'metal-imprint-area',
            initialize: function(options) {
                this.callSuper('initialize', options)

                // Disallow rotation and scaling. Can be moved.
                // Disable object caching, so that we can draw fine grid lines every time.
                this.lockRotation = true

                this.hasRotatingPoint = false

                this.lockScalingX =  true

                this.lockScalingY =  true

                this.objectCaching = false

                this.strokeWidth = 0

                // Allow lock/unlock control.
                this.hasControls = true

                this.setControlsVisibility({
                    br: false,
                    mb: false,
                    ml: false,
                    mr: false,
                    mt: false,
                    tl: false,
                    tr: false,
                    mtr: false
                })

            },
            _render: function(ctx, noTransform) {
                var width = this.width,
                    height = this.height,
                    x = noTransform ? this.left : -this.width / 2,
                    y = noTransform ? this.top : -this.height / 2


                ctx.save()

                ctx.globalAlpha = 0.5


                // First draw the background.
                ctx.fillStyle = this.fill

                ctx.fillRect(x, y, width, height)


                // Now draw the grid divisions.
                var numDivisions = RolandKioskPrint.app.constants.METAL_PRINT_PRINTABLE_SIZE / RolandKioskPrint.app.constants.METAL_PRINT_TRAY_GRID_SIZE

                var gap = width / numDivisions


                var rr = this.canvas.viewportTransform[0]

                for (var i = 1
 i < numDivisions; i++) {
                    if (i == (numDivisions / 2)) {
                        // Draw the center lines at the end.
                        continue

                    } else {
                        ctx.lineWidth = 1 / rr

                        ctx.strokeStyle = this.stroke

                    }

                    this._drawGridLinesPair(ctx, x, y, gap * i)

                }

                // Draw the center lines thicker and in darker color.
                ctx.lineWidth = (1 / rr) * 2

                ctx.strokeStyle = RolandKioskPrint.app.constants.METAL_PRINTABLE_AREA_GRID_CENTER_LINES_COLOR


                i = numDivisions / 2

                this._drawGridLinesPair(ctx, x, y, gap * i)


                ctx.restore()

            },
            _drawGridLinesPair: function(ctx, x, y, d) {
                var width = this.width,
                    height = this.height


                // Draw the horizontal line.
                ctx.beginPath()

                ctx.moveTo(x, y + d)

                ctx.lineTo(x + width, y + d)

                ctx.stroke()


                // And the vertical.
                ctx.beginPath()

                ctx.moveTo(x + d, y)

                ctx.lineTo(x + d, y + height)

                ctx.stroke()

            },
            toObject: function(propertiesToInclude) {
                return this.callSuper('toObject', [
                    'lockRotation',
                    'hasRotatingPoint',
                    'lockScalingX',
                    'lockScalingY',
                    'hasControls'
                ].concat(propertiesToInclude))

            }
        })


        fabric.MetalImprintArea.fromObject = function(object, callback, forceAsync) {
            return fabric.Object._fromObject('MetalImprintArea', object, callback, forceAsync)

        }

    },

    defineBackgroundGridFabricClass: function() {
        // Define the background grid fabric class.
        fabric.Grid = fabric.util.createClass(fabric.Rect, /** @lends fabric.Grid.prototype */ {
            type: 'grid',
            dx: 5, // Division size
            dy: 5,
            xdivs: 5, // Minor divisions per major
            ydivs: 5,
            strokStyle1: '#EEEEEE',
            strokStyle2: '#D2D2D2',
            initialize: function(options) {
                this.callSuper('initialize', options)

                // Disallow any transformations.
                // Disable object caching, so that we can draw fine grid lines every time.
                this.lockMovementX = true

                this.lockMovementY = true

                this.lockRotation = true

                this.hasRotatingPoint = false

                this.lockScalingX =  true

                this.lockScalingY =  true

                this.hasControls = false

                this.objectCaching = false

                this.strokeWidth = 0

            },
            _render: function(ctx, noTransform) {
                var dx = this.dx,
                    dy = this.dy,
                    xdivs = this.xdivs,
                    ydivs = this.ydivs,
                    left = noTransform ? this.left : -this.width / 2,
                    top = noTransform ? this.top : -this.height / 2,
                    right = left + this.width,
                    bottom = top + this.height


                // Use bottom right as grid drawing origin.
                ctx.save()


                var rr = this.canvas.viewportTransform[0]

                var strokStyle1 = this.strokStyle1,
                    strokStyle2 = this.strokStyle2

                var lineWidth1 = 1 / rr,
                    lineWidth2 = (1 / rr) * 2


                // Draw the vertical minor divisions.
                ctx.strokeStyle = strokStyle1

                ctx.lineWidth = lineWidth1


                for (var i = 0, x = right
 x >= left; i++, x -= dx) {
                    if (i % xdivs === 0) {
                        continue

                    }
                    this._drawGridLine(ctx, x, top, x, bottom)

                }

                // Draw horizontal divisions.
                for (var j = 0, y = bottom
 y >= top; j++, y -= dy) {
                    if (j % ydivs === 0) {
                        ctx.strokeStyle = strokStyle2

                        ctx.lineWidth = lineWidth2

                    } else if (j % ydivs == 1) {
                        ctx.strokeStyle = strokStyle1

                        ctx.lineWidth = lineWidth1

                    }
                    this._drawGridLine(ctx, left, y, right, y)

                }

                // Draw vertical major divisions.
                ctx.strokeStyle = strokStyle2

                ctx.lineWidth = lineWidth2


                for (x = right
 x >= left; x -= xdivs * dx) {
                    this._drawGridLine(ctx, x, top, x, bottom)

                }

                ctx.restore()

            },
            _drawGridLine: function(ctx, x1, y1, x2, y2) {
                var width = this.width,
                    height = this.height


                // Draw the line.
                ctx.beginPath()

                ctx.moveTo(x1, y1)

                ctx.lineTo(x2, y2)

                ctx.stroke()

                ctx.closePath()

            },
            toObject: function(propertiesToInclude) {
                return this.callSuper('toObject', [
                    'lockMovementX',
                    'lockMovementY',
                    'lockRotation',
                    'hasRotatingPoint',
                    'lockScalingX',
                    'lockScalingY',
                    'hasControls'
                ].concat(propertiesToInclude))

            }
        })


        fabric.Grid.fromObject = function(object, callback, forceAsync) {
            return fabric.Object._fromObject('Grid', object, callback, forceAsync)

        }

    },

    getCutLines: function() {
        var cutLines = []

        this.getCutLinesInner(this.canvas, cutLines)


        return cutLines

    },

    getCutLinesInner: function(canvasOrGroup, cutLines) {
        var objects = canvasOrGroup.getObjects()


        for (var i = 0, length = objects.length
 i < length; i++) {
            var object = objects[i]


            if (object.type == 'group') {
                this.getCutLinesInner(object, cutLines)

            } else if (object.isCutPath && object.type != 'text' && object.type != 'curved-text') {
                cutLines.push(object)

            }
        }
    },

    setStrokeWidth: function(objects, strokeWidth) {
        objects.forEach(function(o) {
            o.set('strokeWidth', strokeWidth)

        })

    },

    isCanvasDirty: function() {
        var undoRedoPanel = RolandKioskPrint.AppData.getUndoRedoPanel()

        return undoRedoPanel.getController().isStackDirty()

    },

    cutContentExceedsPrintableArea: function(isProductDesigner) {
        // Get the printable area bounds.
        var data = this.productSizeData

        var productBounds = {
            top: 0,
            left: 0,
            bottom: data.heightMM,
            right: data.widthMM
        }


        if (data.leftMarginMM < 0) {
            productBounds.left += data.leftMarginMM

        }
        if (data.topMarginMM < 0) {
            productBounds.top += data.topMarginMM

        }
        if (data.rightMarginMM < 0) {
            productBounds.right += Math.abs(data.rightMarginMM)

        }
        if (data.bottomMarginMM < 0) {
            productBounds.bottom += Math.abs(data.bottomMarginMM)

        }

        var canvas = this.canvas,
            objects = canvas.getObjects()


        var exceedsPrintable = false,
            editAreaBounds = {}


        for (var i = 0, length = objects.length
 i < length && !exceedsPrintable; i++) {
            var object = objects[i]


            if (object.editAreaType) {
                // Get and store the edit area bounds.
                editAreaBounds[object.id] = this.getBoundingRect(object)

            } else if (object.editAreaId) {
                exceedsPrintable = this.cutContentExceedsPrintableAreaInner(editAreaBounds[object.editAreaId], [object], isProductDesigner)

            } else {
                exceedsPrintable = this.cutContentExceedsPrintableAreaInner(productBounds, [object], isProductDesigner)

            }
        }
        return exceedsPrintable

    },

    cutContentExceedsPrintableAreaInner: function(printableBounds, objects, isProductDesigner, isGroup) {
        // Add tolerance of 0.1mm to the comparisons below.
        var EPSILON = 1e-1


        var sourceType = (
            isProductDesigner ? RolandKioskPrint.app.constants.OBJECT_SOURCE_PD
                              : RolandKioskPrint.app.constants.OBJECT_SOURCE_PMD
        )


        for (var i = 0, length = objects.length
 i < length; i++) {
            var object = objects[i]


            if (object.get('type') == 'group' && !object.isPathGroup) {
                if (this.cutContentExceedsPrintableAreaInner(printableBounds, object.getObjects(), isProductDesigner, true)) {
                    return true

                }
            }

            // Check cut paths of the required type.
            // Check all cut paths in edit areas.
            if ((object.isCutPath && (object.sourceType == sourceType || (isProductDesigner && this.isObjectWithinEditArea(object)))) ||
                (object.editAreaType == RolandKioskPrint.app.constants.EDIT_AREA_CUT)) {

                var objectBounds

                if (object.isPathGroup) {
                    objectBounds = this.getPathGroupBoundingRect(object)

                } else {
                    if (isGroup) {
                        // fabric object.getBoundingRect does not return correct
                        // values for a group child object.
                        objectBounds = this.getGroupChildBoundingRect(object)

                    } else {
                        objectBounds = this.getBoundingRect(object)

                    }
                }

                objectBounds.right = objectBounds.left + objectBounds.width

                objectBounds.bottom = objectBounds.top + objectBounds.height


                if (objectBounds.left < printableBounds.left - EPSILON ||
                    objectBounds.top < printableBounds.top - EPSILON ||
                    objectBounds.right > printableBounds.right + EPSILON ||
                    objectBounds.bottom > printableBounds.bottom + EPSILON) {
                    return true

                }
            }
        }

        return false

    },

    getNextZoomRectBounds: function(options) {
        var canvas = this.canvas

        var panCanvas = this.panCanvas

        var zoomRect = panCanvas.getObjects()[0]


        var panCanvasWidth = Math.floor(canvas.width / this.mainToPreviewCanvasSizeRatio)

        var panCanvasHeight = Math.floor(canvas.height / this.mainToPreviewCanvasSizeRatio)


        var left = zoomRect.left

        var top = zoomRect.top


        var zoomRectNewWidth = panCanvasWidth / this.currentZoomLevel

        var zoomRectNewHeight = panCanvasHeight / this.currentZoomLevel


        if (options && options.reset) {
            left = (panCanvasWidth - zoomRectNewWidth) / 2

            top = 0

        } else if (options && options.resizing) {
            left = (left / panCanvas.width) * panCanvasWidth

            top = (top / panCanvas.height) * panCanvasHeight

        } else {
            left += (zoomRect.width - zoomRectNewWidth) / 2

            top += (zoomRect.height - zoomRectNewHeight) / 2

        }

        if (left < 0) {
            left = 0

        }

        if (top < 0) {
            top = 0

        }

        if (left + zoomRectNewWidth > panCanvasWidth) {
            left = panCanvasWidth - zoomRectNewWidth

        }

        if (top + zoomRectNewHeight > panCanvasHeight) {
            top = panCanvasHeight - zoomRectNewHeight

        }

        return {
            left: left,
            top: top,
            width: zoomRectNewWidth,
            height: zoomRectNewHeight
        }

    },

    setZoom: function(zoomLevel) {
        this.previewCanvasHidden = (zoomLevel <= 1)

        this.currentZoomLevel = zoomLevel


        // Trigger canvas re-layouting.
        this.getView().updateLayout()


        this.updatePreviewCanvasLabel()

    },

    getZoom: function() {
        return this.currentZoomLevel

    },

    setLockedProperties: function(object, applyToChildren) {
        var locked = object.isLocked

        var icon = 'resources/icons/unlocked.svg'

        if (locked) {
            icon = 'resources/icons/locked.svg'

        }

        var me = this


        var isDeviceTabOrPhone = (Ext.os.deviceType == 'Tablet' || Ext.os.deviceType == 'Phone')


        var cornerSettings = {
            cornerSize: isDeviceTabOrPhone ? 33 : 24,
            cornerStrokeColor: locked ? '' : '#CBCED0',
            cornerColor: locked ? '#0099D9' : 'white',
            cornerPadding: 10,
            cornerHitTolerance: 1
        }


        object.customiseControlsAppearance({
            bl: {
                icon: icon,
                settings: cornerSettings
            }
        }, function() {
            me.canvas.renderAll()

        })


        object.set({
            'lockMovementX': locked,
            'lockMovementY': locked,
            'lockRotation': locked,
            'lockScalingX': locked,
            'lockScalingY': locked,
            'lockSkewingX': locked,
            'lockSkewingY': locked
        })


        if (RolandKioskPrint.AppData.isImprintArea(object)) {
            return

        }

        // If locked, hide all controls except the bottom left.
        // This blocks object scaling, skewing and rotation using object controls.
        var show = !locked

        var options = {
            br: show,
            mb: show,
            ml: show,
            mr: show,
            mt: show,
            tl: show,
            tr: show,
            mtr: show
        }

        object.setControlsVisibility(options)


        var me = this

        if (applyToChildren && object.get('type') == 'activeSelection') {
            object.getObjects().forEach(function(o) {
                o.set('isLocked', locked)

                me.setLockedProperties(o)

            })

        }
    },

    updateSelectionState: function() {
        var canvas = this.canvas

        var activeObject = canvas.getActiveObject()


        // Selection group.
        if (activeObject){
            var isProductDesigner = RolandKioskPrint.AppData.isProductDesigner()

            if (activeObject.get('type') == 'activeSelection') {
                // Check if any child object is locked.
                // If yes, we set the selection group as locked.
                var objects = activeObject.getObjects(),
                    length = objects.length


                var isAnyChildLocked = false

                for (var i = 0
 i < length; i++) {
                    if (objects[i].isLocked) {
                        isAnyChildLocked = true

                        break

                    }
                }

                // Set the selection group as locked.
                activeObject.set('isLocked', isAnyChildLocked)

                this.setLockedProperties(activeObject)


                // Additional check for special objects selection, edit areas in
                // product designer, or foil imprint area in product model designer.
                // Hide controls on the selection group.

                var isSpecialSelection = false


                for (var i = 0
 i < length; i++) {
                    if (objects[i].editAreaType &&
                        (isProductDesigner || objects[i].sourceType == RolandKioskPrint.app.constants.OBJECT_SOURCE_SVG)) {
                        isSpecialSelection = true

                        break

                    }
                }

                if (!isSpecialSelection && (this.foilPrint || this.metalPrint)) {
                    var isImprintArea = RolandKioskPrint.AppData.isImprintArea

                    for (var i = 0
 i < length; i++) {
                        if (isImprintArea(objects[i])) {
                            isSpecialSelection = true

                            break

                        }
                    }
                }

                if (isSpecialSelection) {
                    activeObject.set({
                        'lockMovementX': true,
                        'lockMovementY': true,
                        'lockScalingX': true,
                        'lockScalingY': true,
                        'lockRotation': true,
                        'hasControls': false,
                        'hasRotatingPoint': false
                    })

                    activeObject.isEffectivelyLocked = true

                }

                canvas.renderAll()

            } else if (activeObject.editAreaType &&
                      (isProductDesigner ||
                      activeObject.sourceType == RolandKioskPrint.app.constants.OBJECT_SOURCE_SVG)) {
                activeObject.isEffectivelyLocked = true

            }
        }
    },

    showHidePreviewCanvas: function(show) {
        this.previewCanvasHiddenOverride = !show


        this.previewCanvasContainer.style.visibility = (!show ? 'hidden' : 'visible')


        this.updatePreviewCanvasLabel()

    },

    isPreviewCanvasShown: function() {
        return !this.previewCanvasHiddenOverride

    },

    updatePreviewCanvasLabel: function() {
        // Display the current zoom level.
        var zoomLevelLabel = RolandKioskPrint.app.getString('label.designer.zoomLevelLabel')


        this.previewCanvasLabel.textContent = zoomLevelLabel + ' ' + this.currentZoomLevel + 'x'

    },

    shouldDrawAdornment: function(instance, adornment) {
        if (instance.get('type') == 'clippingGroup') {
            // For cropped image, get the image attributes.
            instance = instance.getElement()

        }

        if (adornment.name == 'noColor') {
            return instance.noColor

        } else if (adornment.name == 'varnish') {
            var canvas = instance.canvas

            return (canvas &&
                    canvas.varnish == 'on' && // Product model allows varnish
                    instance.specialColor &&
                    instance.specialColor[2] == '1')
 // Instance has varnish applied
        }

        return false

    },

    drawAdornment: function(instance, adornment, ctx, left, top) {
        var icon


        if (instance.get('type') == 'clippingGroup') {
            // For cropped image, get the image attributes.
            instance = instance.getElement()

        }

        if (adornment.name == 'noColor') {
            icon = instance.noColorIcon

        } else if (adornment.name == 'varnish') {
            var canvas = instance.canvas

            if (canvas &&
                canvas.varnish == 'on' && // Product model allows varnish
                instance.specialColor && // Instance has varnish applied
                instance.specialColor[2] == '1') {
                if (canvas.varnishType == RolandKioskPrint.app.constants.GLOSS_VARNISH) {
                    icon = instance.glossIcon

                } else if (canvas.varnishType == RolandKioskPrint.app.constants.MATTE_VARNISH) {
                    icon = (instance.textureType ? instance.textureIcon : instance.matteIcon)

                }
            }
        }

        if (icon) {
            this.drawImageProportionally(ctx, icon,
                                         left + adornment.padding / 2,
                                         top + adornment.padding / 2,
                                         adornment.boxSize - adornment.padding,
                                         adornment.boxSize - adornment.padding)

        }

        return false

    },

    loadIcon: function(src) {
        var icon = new Image()


        icon.onload = function() {
            //console.log("Loaded " + icon.src)

        }


        icon.onerror = function() {
            //console.log("Failed to load " + icon.src)

        }


        icon.src = src
 // Triggers load
        return icon

    },

    drawImageProportionally: function(ctx, img, left, top, width, height) {

        var rx = width / img.width,
            ry = height / img.height


        if (rx < ry) {
            top += (height - img.height * rx) / 2

            height = img.height * rx

        } else {
            left += (width - img.width * ry) / 2

            width = img.width * ry

        }

        ctx.drawImage(
            img,
            left,
            top,
            width,
            height
        )

    },

    writeColorPatternsToSVG: function() {
        var canvas = this.canvas


        // Check if we are doing textures.
        if (canvas.varnish != 'on' || canvas.varnishType != RolandKioskPrint.app.constants.MATTE_VARNISH) {
            return ''

        }

        var textures = [],
            alreadyAdded = {}


        // Get the textures used on objects.
        this.getTexturesUsed(canvas.getObjects(), textures, alreadyAdded)


        // Generate the SVG pattern color markup.
        var markup = []

        textures.forEach(function(texture) {
            markup.push('<pattern id="' + texture + '" viewBox="0,0,10,10" width="10%" height="10%">')

            markup.push('<text font-family="Ubuntu" font-size="4" font-style="normal" font-weight="normal" style="fill: rgb(0,0,0)
">');
            markup.push('<tspan x="5" y="5">')

            markup.push(texture)

            markup.push('</tspan>')

            markup.push('</text>')

            markup.push('</pattern>')

            markup.push('\n')

        })


        return markup.join('')

    },

    getTexturesUsed: function(objects, textures, alreadyAdded) {
        var me = this


        // Loop over the objects for the textures being used.
        objects.forEach(function(object) {
            var objectType = object.get('type')


            if (objectType == 'group' &&
                (!object.isPathGroup || object.sourceType == RolandKioskPrint.app.constants.OBJECT_SOURCE_SVG)) {
                me.getTexturesUsed(object.getObjects(), textures, alreadyAdded)

            } else {
                if (objectType == 'clippingGroup') {
                    object = object.getElement()

                }

                var texture = object.textureType

                if (texture && !alreadyAdded[texture]) {
                    textures.push(texture)

                    alreadyAdded[texture] = true

                }
            }
        })

    },

    getShapeObject: function(shapeType) {
        var fabricShape

        var p1, p2, p3,
            p4, p5, p6


        switch(shapeType) {
            case RolandKioskPrint.app.constants.SHAPE_TYPE_TRIANGLE:
                p1 = {x: 233.4, y: 202.1}

                p2 = {x: 0, y: 202.1}

                p3 = {x: 116.7, y: 0}

                fabricShape = new fabric.Polygon([p1, p2, p3])

                break

            case RolandKioskPrint.app.constants.SHAPE_TYPE_CIRCLE:
                fabricShape = new fabric.Circle({radius: 50})

                break

            case RolandKioskPrint.app.constants.SHAPE_TYPE_HEART:
                // The path below is lifted from hearysymbol.svg.
                fabricShape = new fabric.Path(
                    'M157.7,0c-20,0-37.8,9.8-48.7,24.8C98,9.8,80.3,0,60.2,0C26.9,0,0,27,0,60.3c0,50.6,109,132.3,109,132.3s109-81.7,109-132.3C217.9,27,191,0,157.7,0z'
                )

                break

            case RolandKioskPrint.app.constants.SHAPE_TYPE_PENTAGON:
                p1 = {x: 112, y: 0}

                p2 = {x: 0, y: 81.3}

                p3 = {x: 42.8, y: 212.9}

                p4 = {x: 181.2, y: 212.9}

                p5 = {x: 224, y: 81.3}

                fabricShape = new fabric.Polygon([p1, p2, p3, p4, p5])

                break

            case RolandKioskPrint.app.constants.SHAPE_TYPE_HEXAGON:
                p1 = {x: 193.7, y: 0}

                p2 = {x: 64.6, y: 0}

                p3 = {x: 0, y: 111.9}

                p4 = {x: 64.6, y: 223.7}

                p5 = {x: 193.7, y: 223.7}

                p6 = {x: 258.3, y: 111.9}

                fabricShape = new fabric.Polygon([p1, p2, p3, p4, p5, p6])

                break

            case RolandKioskPrint.app.constants.SHAPE_TYPE_ROUNDEDRECT:
                fabricShape = new fabric.Path(
                    'M226.5,189.9H22.9C10.2,189.9,0,179.6,0,167V23C0,10.3,10.2,0,22.9,0h203.7c12.6,0,22.9,10.2,22.9,22.9v144 C249.4,179.6,239.2,189.9,226.5,189.9z'
                )

                break

            case RolandKioskPrint.app.constants.SHAPE_TYPE_SPEECHBUBBLE:
                fabricShape = new fabric.Path(
                    'M49.7,163.3c-0.6,8.7,1.5,17.9,6,26.3c5,9.4,13.1,18.3,24,26.2c0.6,0.4,1.2,0.6,1.9,0.6c0.7,0,1.4-0.2,2-0.7 c1.1-0.8,1.5-2.4,0.9-3.6c-4.8-10.9-5-24-0.7-35.4c14.1,3.7,29,5.6,44.2,5.6c70.4,0,127.7-40.8,127.7-91.1S198.2,0,127.8,0C57.3-0.1,0,40.8,0,91C0,119.6,18.1,145.8,49.7,163.3z'
                )

                break

            case RolandKioskPrint.app.constants.SHAPE_TYPE_TRAPEZIUM:
                p1 = {x: 225, y: 104.4}

                p2 = {x: 0, y: 104.4}

                p3 = {x: 41.7, y: 0}

                p4 = {x: 178.8, y: 0}

                fabricShape = new fabric.Polygon([p1, p2, p3, p4])

                break

            case RolandKioskPrint.app.constants.SHAPE_TYPE_STAR:
                fabricShape = new fabric.Path(
                    'M105.5,0L138,66L210.9,76.6L158.2,128.1L170.6,200.7L105.5,166.4L40.3,200.7L52.7,128.1L0,76.6L72.9,66Z'
                )

                break

            case RolandKioskPrint.app.constants.SHAPE_TYPE_DIAMOND:
                p1 = {x: 117.7, y: 88.2}

                p2 = {x: 58.8, y: 176.5}

                p3 = {x: 0, y: 88.2}

                p4 = {x: 58.8, y: 0}

                fabricShape = new fabric.Polygon([p1, p2, p3, p4])

                break

            default:
                fabricShape = new fabric.Rect({
                    width: 100,
                    height: 100
                })

                break

        }
        return fabricShape

    },

    onClippingStart: function(object) {
        // Entered clip mode. Mute undo/redo handling.
        var undoRedoPanel = RolandKioskPrint.AppData.getUndoRedoPanel()

        undoRedoPanel.getController().mute()


        RolandKioskPrint.AppData.setCropMode(true)


        undoRedoPanel.getController().updatePanel()

        this.canvas.fire('selection:updated')

    },

    onClippingEnd: function(object) {
        // Resume undo/redo handling. Notify once.
        var undoRedoPanel = RolandKioskPrint.AppData.getUndoRedoPanel()

        undoRedoPanel.getController().unmute()


        RolandKioskPrint.AppData.setCropMode(false)


        this.canvas.fire('object:modified', {target: object})

        this.canvas.fire('selection:updated')

    },

    endClipping: function() {
        var activeObject = this.canvas.getActiveObject()

        if (activeObject && activeObject.get('type') == 'clippingGroup' && activeObject.getClipMode()) {
            activeObject.endClipping()

        }
    },

    getLowestEditAreaIndex: function() {
        var canvas = this.canvas

        var objects = canvas.getObjects()


        var index = -1

        for (var i = 0, length = objects.length
 i < length; i++) {
            if (objects[i].editAreaType) {
                index = i

                break

            }
        }

        return index

    },

    getSharpness: function(color) {
        // Compute the sharpness (lightness perception) of the color.
        // Uses the standard grayscale conversion.
        var source = new fabric.Color(color).getSource()

        return (0.3 * source[0] + 0.59 * source[1] + 0.11 * source[2])

    },

    applySharpnessToColor: function(color, sharpness) {
        // Applies sharpness to a color.
        // A sharpness value of 0 returns the original color.
        // A sharpness value of 255 returns white.

        var rgbColor = new fabric.Color(color)

        var source = rgbColor.getSource()


        sharpness = sharpness / 255

        source[0] += Math.floor(sharpness * (255 - source[0]))

        source[1] += Math.floor(sharpness * (255 - source[1]))

        source[2] += Math.floor(sharpness * (255 - source[2]))

        return '#' + rgbColor.toHex()

    },

    getEditAreasByType: function(areaType) {
        var canvas = this.canvas

        var editAreas = []


        canvas.getObjects().forEach(function(o) {
            if (o.editAreaType == areaType) {
                editAreas.push(o)

            }
        })


        return editAreas

    },

    getImageFilterAttributes: function(image) {
        var filterAttrs = {}


        // Returns the filter attributes applied on the image.
        image.filters.forEach(function(filter) {
            if (filter) {
                if (filter.type == 'ImageAdjust') {
                    filterAttrs.brightness = filter.brightness

                    filterAttrs.contrast = filter.contrast

                    filterAttrs.gamma = filter.gamma

                } else if (filter.type == 'Invert') {
                    filterAttrs.invert = filter.invert

                } else if (filter.type == 'BlackWhite') {
                    filterAttrs.threshold = filter.threshold

                }
            }
        })


        return filterAttrs

    },

    setDeviceStrokeWidth: function(object, strokeWidth) {
        this.enumerateObjects(object, function(pathObject) {
            pathObject.set({
                'deviceStrokeWidth': strokeWidth,
                'deviceStroke': true
            })

            return true

        }, false, true)

    },

    getImageFilter: function(imageObject, filterType) {
        var appliedFilters = imageObject.filters

        for (var i = 0, length = appliedFilters.length
 i < length; i++) {
            if (appliedFilters[i].type == filterType) {
                return appliedFilters[i]

            }
        }
    },

    getClipartImages: function(printType) {
        var clipartImages = [],
            me = this


        this.canvas.getObjects().forEach(function(object) {
            if (object.printType == printType) {
                me.enumerateObjects(object, function(o) {
                    if (o.type == 'image' && o.group && o.group.isPathGroup) {
                        clipartImages.push(o)

                    }
                    return true

                }, false, true)

            }
        })

        return clipartImages

    },

    getColorSharpness: function(source) {
        var result

        if (source.toLive) {
            // Shading color. Convert the individual color stops.
            var colorStops = source.colorStops,
                dstColorStops = []

            for (var i = 0
 i < colorStops.length; i++) {
                dstColorStops.push({
                    offset: colorStops[i].offset,
                    color: this.getSharpness(colorStops[i].color)
                })

            }
            result = dstColorStops

        } else {
            result = this.getSharpness(source)

        }
        return result

    },

    createCutBoundsObject: function(bounds) {
        var canvas = this.canvas


        var cutBoundsObject = new fabric.Rect({
            id: 'cutBounds',
            left: bounds.left,
            top: bounds.top,
            width: bounds.width,
            height: bounds.height,
            strokeWidth: RolandKioskPrint.app.constants.CUT_MINIMAL_STROKE_WIDTH,
            fill: ''
        })


        canvas.add(cutBoundsObject)


        return cutBoundsObject

    },

    writeImageFilterAttributesToSVG: function(image) {
        var markup = []

        var filterAttrs = this.getImageFilterAttributes(image)


        if (filterAttrs.brightness !== undefined) {
            markup.push(
                ' data-brightness="' + filterAttrs.brightness + '"',
                ' data-contrast="' + filterAttrs.contrast + '"',
                ' data-gamma="' + filterAttrs.gamma + '" '
            )

        }

        if (filterAttrs.threshold !== undefined) {
            markup.push(' data-threshold="' + filterAttrs.threshold + '" ')

        }

        if (filterAttrs.invert !== undefined) {
            markup.push(' data-invert="' + filterAttrs.invert + '" ')

        }

        // Metal images need transparency processing regardless.
        markup.push(' data-filtered="true" ')


        return markup.join('')

    },

    replaceObject: function(object, substituteObj) {
        var canvas = object.canvas

        var layoutProps = [
            'flipX',
            'flipY',
            'skewX',
            'skewY',
            'angle',
            'sourceType',
            'editAreaId',
            'hasControls',
            'specialColor',
            'textureType',
            'noColor'
        ]


        // The simpler properties, copy as is.
        layoutProps.forEach(function(prop) {
            substituteObj.set(prop, object[prop])

        })


        function restoreProperties(destObj, sourceObj, props) {
            props.forEach(function(prop) {
                var origPropValue = sourceObj[prop + 'Orig']

                if (origPropValue === undefined && !sourceObj.uniColor) {
                    return

                }

                origPropValue = destObj[prop + 'Orig'] = (origPropValue !== undefined) ? origPropValue : sourceObj[prop]

                if (destObj.uniColor && origPropValue !== undefined) {
                    destObj.set(prop, origPropValue)

                }
            })

        }

        if (RolandKioskPrint.AppData.isActivePrintTypeColor()) {
            // For color print, retain fill color and stroke color for unicolor objects.
            restoreProperties(substituteObj, object, ['fill', 'stroke'])

        } else if (RolandKioskPrint.AppData.isActivePrintTypeMetal()) {
            // For metal print, we first copy the required properties, and then apply those.
            restoreProperties(substituteObj, object, ['fillSharpness', 'isOutlinePath'])


            if (substituteObj.uniColor) {
                var backgroundColor = this.getBackgroundColor()

                var fillColor = this.applySharpnessToColor(backgroundColor, substituteObj.fillSharpness)

                var isOutlinePath = substituteObj.isOutlinePath


                if (isOutlinePath) {
                    this.setDeviceStrokeWidth(substituteObj, RolandKioskPrint.app.constants.METAL_OUTLINE_STROKE_WIDTH)

                }
                substituteObj.set({
                    'fill': fillColor,
                    'stroke': isOutlinePath ? RolandKioskPrint.app.constants.METAL_OUTLINE_COLOR_DEFAULT : '',
                    'isOutlinePath': isOutlinePath
                })

            }
        }

        substituteObj.effectiveWidth = object.effectiveWidth ? object.effectiveWidth : (object.width * object.scaleX)

        substituteObj.effectiveHeight = object.effectiveHeight ? object.effectiveHeight : (object.height * object.scaleY)

        substituteObj.effectiveCenterPoint = object.effectiveCenterPoint ? object.effectiveCenterPoint : object.getCenterPoint()



        var scaleX = substituteObj.effectiveWidth / substituteObj.width,
            scaleY = substituteObj.effectiveHeight / substituteObj.height,
            scale = scaleX < scaleY ? scaleX : scaleY


        substituteObj.set({
            'scaleX': scale,
            'scaleY': scale
        })


        substituteObj.setPositionByOrigin(substituteObj.effectiveCenterPoint, 'center', 'center')


        var undoRedoPanel = RolandKioskPrint.AppData.getUndoRedoPanel()

        undoRedoPanel.getController().mute()

        this.setLockedProperties(substituteObj)


        var index = canvas.getObjects().indexOf(object)

        canvas.remove(object)

        canvas.insertAt(substituteObj, index)


        undoRedoPanel.getController().unmute()

        canvas.fire('object:modified', substituteObj)

    },

    getBackgroundColor: function() {
        var productModelData = RolandKioskPrint.AppData.productModelData

        var backgroundColor = productModelData.backgroundColor

        if (!backgroundColor) {
            backgroundColor = productModelData.materialColor

        }
        return backgroundColor

    },

    adjustImage: function(object) {
        var defaultAdjustData,
            printType = object.get('printType'),
            isProductDesigner = RolandKioskPrint.AppData.isProductDesigner(),
            widgetName


        if (printType == RolandKioskPrint.app.constants.PRINT_TYPE_METAL) {
            defaultAdjustData = {
                brightness: RolandKioskPrint.app.constants.DEFAULT_BRIGHTNESS,
                contrast: RolandKioskPrint.app.constants.DEFAULT_CONTRAST,
                gamma: RolandKioskPrint.app.constants.DEFAULT_GAMMA,
                threshold: 128,
                invert: false
            }

            widgetName = isProductDesigner ? 'productdesignerimageoutline' :
                                             'productmodeldesignerimageoutline'

        } else {
            defaultAdjustData = {
                threshold: 128,
                invert: false
            }

            widgetName = isProductDesigner ? 'productdesignerimageadjust' :
                                             'productmodeldesignerimageadjust'

        }

        var me = this

        this.getView().getEl().mask(RolandKioskPrint.app.getString('message.designer.openingImage'))


        this.getImageAdjustData(object, defaultAdjustData).then(
            function(imageAdjustData) {
                me.getView().getEl().unmask()

                var widget = Ext.widget({
                    xtype: widgetName,
                    clientView: isProductDesigner
                })


                widget.getViewModel().setData(imageAdjustData)

                RolandKioskPrint.app.showModalView(widget)

            },
            function() {
                me.getView().getEl().unmask()

                Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                                  RolandKioskPrint.app.getString('message.designer.openingImageFailed'))

            }
        )

    },

    getImageAdjustData: function(object, defaultAdjustData) {
        var parentFilePath,
            left,
            top,
            height,
            width,
            origHeight,
            origWidth


        var image


        if (object.type == 'image') {
            parentFilePath = object.getSrc().replace(/\?.*/,'').replace(/.*cotodesign/, '/cotodesign')

            left = 0

            top = 0

            height = 100

            width = 100

            origHeight = object.origHeight

            origWidth = object.origWidth

            image = object

        } else {
            object.startClipping()

            image = object.getElement()


            var rect = object.getClip()

            parentFilePath = image.getSrc().replace(/\?.*/,'').replace(/.*cotodesign/, '/cotodesign')

            origHeight = image.origHeight

            origWidth = image.origWidth

            left = (rect.left - image.left) / image.width * 100

            top = (rect.top - image.top) / image.height * 100

            height = (rect.height * rect.scaleY) / image.height * 100

            width = (rect.width * rect.scaleX) / image.width * 100

            object.endClipping()

        }

        // Fill in the image area being edited.
        var deferred = new Ext.Deferred(),
            adjustData = {
                parentFilePath: parentFilePath,
                left: left,
                top: top,
                height: height,
                width: width,
                origHeight: origHeight,
                origWidth: origWidth
            }


        function copyProperties(dst, src) {
            for(var prop in src) {
                dst[prop] = src[prop]

            }
        }

        function getParentFolder(url) {
            return url.substring(0, url.lastIndexOf('/'))

        }

        // Copy over the default data.
        copyProperties(adjustData, defaultAdjustData)


        // Get the filter attributes, if already applied.
        var filterData = this.getImageFilterAttributes(image)

        copyProperties(adjustData, filterData)


        // Fill in the applied filters data.
        var printType = object.get('printType')

        if (printType == RolandKioskPrint.app.constants.PRINT_TYPE_METAL || filterData.threshold !== undefined) {
            deferred.resolve(adjustData)

        } else {
            var url = parentFilePath.replace('/thumbs', '') + '.json'

            Ext.Ajax.request({
                scope: this,
                url: url,
                success: function(response, opts) {
                    this.getView().getEl().unmask()


                    var imageAdjustData = Ext.decode(response.responseText)

                    if (!imageAdjustData) {
                        return

                    }

                    var path = imageAdjustData.parentFilePath

                    path = getParentFolder(getParentFolder(url)) + '/thumbs' +
                        path.substring(path.lastIndexOf('/'))


                    adjustData.parentFilePath = path

                    var filters = imageAdjustData.filters

                    filters.forEach(function(filter) {
                        if (filter.name.toLowerCase() == 'invert') {
                            adjustData.invert = filter.invert

                        } else if (filter.name.toLowerCase() == 'blackwhite') {
                            adjustData.threshold = filter.threshold

                        }
                    })

                    deferred.resolve(adjustData)

                },
                failure: function() {
                    deferred.reject()

                }
            })

        }

        return deferred.promise

    },

    isObjectWithinEditArea: function(object) {
        var group = object

        while(group) {
            if (group.editAreaId) {
                return true

            }
            group = group.group

        }
        return false

    },

    initAligningGuidelines: function(canvas) {
        var ctx = canvas.getSelectionContext(),
            aligningLineOffset = 5,
            aligningLineMargin = 5,
            aligningLineWidth = 1,
            aligningLineColor = RolandKioskPrint.app.constants.SMART_GUIDE_LINE_COLOR,
            viewportTransform,
            zoom = 1,
            offsetX = 0,
            offsetY = 0,
            canvasPanel = RolandKioskPrint.AppData.getCanvasPanel(),
            maxZoomLevel = RolandKioskPrint.app.constants.MAX_ZOOM_LEVEL,
            currentZoom = 0,
            ratioScale = 1,
            onSmartGuide = !RolandKioskPrint.AppData.getSmartGuide(),
            corner = false,
            cropMode = RolandKioskPrint.AppData.getCropMode()


        offsetX = canvas._objects[0].oCoords.tl.x

        offsetY = canvas._objects[0].oCoords.tl.y


        function drawVerticalLine(coords) {
            drawLine(
                coords.x,
                coords.y1 > coords.y2 ? coords.y2 : coords.y1,
                coords.x,
                coords.y2 > coords.y1 ? coords.y2 : coords.y1)

        }

        function drawHorizontalLine(coords) {
            drawLine(
                coords.x1 > coords.x2 ? coords.x2 : coords.x1,
                coords.y,
                coords.x2 > coords.x1 ? coords.x2 : coords.x1,
                coords.y)

        }

        function drawLine(x1, y1, x2, y2) {
            ctx.save()

            ctx.lineWidth = aligningLineWidth

            ctx.strokeStyle = aligningLineColor

            ctx.beginPath()

            ctx.moveTo(viewportTransform[4] + (x1 * zoom), (viewportTransform[5] + (y1 * zoom)))

            ctx.lineTo(viewportTransform[4] + (x2 * zoom), (viewportTransform[5] + (y2 * zoom)))

            ctx.stroke()

            ctx.restore()

        }

        function isInRange(value1, value2) {
            value1 = Math.round(value1)

            value2 = Math.round(value2)

            for (var i = value1 - aligningLineMargin, len = value1 + aligningLineMargin
 i <= len; i++) {
                if (i === value2) {
                    return true

                }
            }
            return false

        }

        function isEqual(value1, value2) {
            value1 = Math.round(value1)

            value2 = Math.round(value2)

            if (value1 === value2) return true

            else return false

        }

        var verticalLines = [],
            horizontalLines = []


        // Register AligningGuideline to canvas.
        canvas.off(this.onAligningGuideEvents)

        this.onAligningGuideEvents = {
            'mouse:down': function (e) {
                viewportTransform = canvas.viewportTransform

                zoom = canvas.getZoom()

                onSmartGuide = !RolandKioskPrint.AppData.getSmartGuide()

                cropMode = RolandKioskPrint.AppData.getCropMode()


                //Close guideline when crop
                if(cropMode) onSmartGuide = true


                // Set value when click corner
                var eTarget = e.target

                if(eTarget){
                    ratioScale = eTarget.scaleX/eTarget.scaleY

                    if(!e.transform) corner = false

                    else{
                        switch(e.transform.corner) {
                            case 'tl':
                                corner = true

                                break

                            case 'tr':
                                corner = true

                                break

                            case 'br':
                                corner = true

                                break

                            default:
                                corner = false

                        }
                    }
                }else corner = false


                // When using zoom, Zoom max is range to 0
                currentZoom = canvasPanel.getController().getZoom()

                switch(currentZoom) {
                    case 1:
                        aligningLineMargin = 5

                        break

                    case 1.5:
                        aligningLineMargin = 4

                        break

                    case 2:
                        aligningLineMargin = 3

                        break

                    case 3:
                        aligningLineMargin = 2

                        break

                    case 4:
                        aligningLineMargin = 1

                        break

                    case 5:
                        aligningLineMargin = 0

                        break

                }
                if(corner) aligningLineMargin = 0


            },
            'object:moving': function (e) {
                if(onSmartGuide) return


                var activeObject = e.target,
                    canvasObjects = canvas.getObjects(),
                    activeObjectCenter = activeObject.getCenterPoint(),
                    activeObjectLeft = activeObjectCenter.x,
                    activeObjectTop = activeObjectCenter.y,
                    activeObjectBoundingRect = activeObject.getBoundingRect(),
                    activeObjectHeight = activeObjectBoundingRect.height / viewportTransform[3],
                    activeObjectWidth = activeObjectBoundingRect.width / viewportTransform[0],
                    horizontalInTheRange = false,
                    verticalInTheRange = false,
                    transform = canvas._currentTransform,
                    posTop = 0,
                    posLeft = 0,
                    lineLeft = false,
                    lineRight = false,
                    lineTop = false,
                    lineBottom = false


                // Check when select multi-object
                var multi = false,
                    checkObj = []

                if (activeObject._objects){
                    if (activeObject._objects.length > 1){
                        multi = true

                        for(var xx = 0
 xx < canvasObjects.length; xx++){
                            for(var yy = 0
 yy < activeObject._objects.length; yy++){
                                if(canvasObjects[xx] === activeObject._objects[yy]){
                                    checkObj.push(xx)

                                }
                            }
                        }
                    }
                }else checkObj = activeObject


                if (!transform) return

                for (var i = canvasObjects.length
 i--;) {
                    if(!multi || activeObject.get('type') === 'group' || activeObject.get('type') === 'clippingGroup'){
                        if (canvasObjects[i] === activeObject) continue

                    }else{ if((checkObj.indexOf(i) > -1)) continue
 }

                    //check imprint area
                    if(RolandKioskPrint.AppData.isProductDesigner()){
                        if(canvasObjects[i].id === "foilImprintArea" || canvasObjects[i].id === "metalImprintArea") continue

                    }

                    var objectCenter = canvasObjects[i].getCenterPoint(),
                        objectLeft = objectCenter.x,
                        objectTop = objectCenter.y,
                        objectBoundingRect = canvasObjects[i].getBoundingRect(),
                        objectHeight = objectBoundingRect.height / viewportTransform[3],
                        objectWidth = objectBoundingRect.width / viewportTransform[0],
                        snapLeft = false,
                        snapRight = false,
                        snapTop = false,
                        snapBottom = false,
                        snapHorizontal = false,
                        snapVertical = false,
                        acCoords = activeObject.calcCoords(true)


                    // snap by the left edge
                    if (isInRange(objectLeft - objectWidth / 2, activeObjectLeft - activeObjectWidth / 2)) {
                        if (!lineLeft) {
                            if(lineRight){
                                if(isEqual(objectWidth, activeObjectWidth)){
                                    lineLeft = true

                                    verticalInTheRange = true

                                }
                            }else{
                                verticalInTheRange = true

                                posLeft = (objectLeft - objectWidth / 2 + activeObjectWidth / 2)

                                snapLeft = lineLeft = true

                            }
                            if(lineLeft){
                                verticalLines.push({
                                    x: objectLeft - objectWidth / 2,
                                    y1: (objectTop - objectHeight / 2 < activeObjectTop - activeObjectHeight / 2) ? (objectTop - objectHeight / 2) : (activeObjectTop - activeObjectHeight / 2),
                                    y2: (activeObjectTop + activeObjectHeight / 2 > objectTop + objectHeight / 2) ? (activeObjectTop + activeObjectHeight / 2) : (objectTop + objectHeight / 2)
                                })

                            }
                        }
                    }

                    // snap by the right edge
                    if (isInRange(objectLeft + objectWidth / 2, activeObjectLeft + activeObjectWidth / 2)) {
                        if (!lineRight) {
                            if(lineLeft){
                                if(isEqual(objectWidth, activeObjectWidth)){
                                    lineRight = true

                                    verticalInTheRange = true

                                }
                            }else{
                                posLeft = (objectLeft + objectWidth / 2 - activeObjectWidth / 2)

                                snapRight = lineRight = true

                                verticalInTheRange = true

                            }
                            if(lineRight){
                                verticalLines.push({
                                    x: objectLeft + objectWidth / 2,
                                    y1: (objectTop - objectHeight / 2 < activeObjectTop - activeObjectHeight / 2) ? (objectTop - objectHeight / 2) : (activeObjectTop - activeObjectHeight / 2),
                                    y2: (activeObjectTop + activeObjectHeight / 2 > objectTop + objectHeight / 2) ? (activeObjectTop + activeObjectHeight / 2) : (objectTop + objectHeight / 2)
                                })

                            }
                        }
                    }

                    // snap by the top edge
                    if (isInRange(objectTop - objectHeight / 2, activeObjectTop - activeObjectHeight / 2)) {
                        if (!lineTop) {
                            if(lineBottom){
                                if(isEqual(objectHeight, activeObjectHeight)){
                                    lineTop = true

                                    horizontalInTheRange = true

                                }
                            }else{
                                posTop = (objectTop - objectHeight / 2 + activeObjectHeight / 2)

                                snapTop = lineTop = true

                                horizontalInTheRange = true

                            }
                            if(lineTop){
                                horizontalLines.push({
                                    y: objectTop - objectHeight / 2,
                                    x1: (objectLeft - objectWidth / 2 < activeObjectLeft - activeObjectWidth / 2) ? (objectLeft - objectWidth / 2) : (activeObjectLeft - activeObjectWidth / 2),
                                    x2: (activeObjectLeft + activeObjectWidth / 2 > objectLeft + objectWidth / 2) ? (activeObjectLeft + activeObjectWidth / 2) : (objectLeft + objectWidth / 2)
                                })

                            }
                        }
                    }

                    // snap by the bottom edge
                    if (isInRange(objectTop + objectHeight / 2, activeObjectTop + activeObjectHeight / 2)) {
                        //                 if (lineBottom) continue

                        if (!lineBottom) {
                            if(lineTop){
                                if(isEqual(objectHeight, activeObjectHeight)){
                                    lineBottom = true

                                    horizontalInTheRange = true

                                }
                            }else{
                                posTop = (objectTop + objectHeight / 2 - activeObjectHeight / 2)

                                snapBottom = lineBottom = true

                                horizontalInTheRange = true

                            }
                            if(lineBottom){
                                horizontalLines.push({
                                    y: objectTop + objectHeight / 2,
                                    x1: (objectLeft - objectWidth / 2 < activeObjectLeft - activeObjectWidth / 2) ? (objectLeft - objectWidth / 2) : (activeObjectLeft - activeObjectWidth / 2),
                                    x2: (activeObjectLeft + activeObjectWidth / 2 > objectLeft + objectWidth / 2) ? (activeObjectLeft + activeObjectWidth / 2) : (objectLeft + objectWidth / 2)
                                })

                            }
                        }
                    }

                    if (snapLeft || snapRight) {
                        if (snapLeft == snapRight) {
                            posLeft = (objectLeft - objectWidth / 2 + activeObjectWidth / 2)

                        }else {
                            if (snapLeft) posLeft = (objectLeft - objectWidth / 2 + activeObjectWidth / 2)

                            if (snapRight) posLeft = (objectLeft + objectWidth / 2 - activeObjectWidth / 2)

                        }
                    }

                    if (snapTop || snapBottom) {
                        if(snapTop == snapBottom) {
                            posTop = (objectTop - objectHeight / 2 + activeObjectHeight / 2)

                        }else {
                            if (snapTop) posTop = (objectTop - objectHeight / 2 + activeObjectHeight / 2)

                            if (snapBottom) posTop = (objectTop + objectHeight / 2 - activeObjectHeight / 2)

                        }
                    }
                }

                if(posTop === 0) posTop = activeObjectTop

                if(posLeft === 0) posLeft = activeObjectLeft

                activeObject.setPositionByOrigin(new fabric.Point(posLeft, posTop), 'center', 'center')


                if (!horizontalInTheRange) {
                    horizontalLines.length = 0

                }

                if (!verticalInTheRange) {
                    verticalLines.length = 0

                }
            },
            'object:scaling': function (e) {
                if(onSmartGuide) return

                //Not support pinch-to-zoom
                if(!e.pointer) return


                var activeObject = e.target,
                    canvasObjects = canvas.getObjects(),
                    activeObjectCenter = activeObject.getCenterPoint(),
                    activeObjectLeft = activeObjectCenter.x,
                    activeObjectTop = activeObjectCenter.y,
                    actDefaultWidth = activeObject.width + activeObject.strokeWidth,
                    actDefaultHeight = activeObject.height + activeObject.strokeWidth,
                    activeObjectHeight = ((actDefaultHeight) * activeObject.scaleY),
                    activeObjectWidth = ((actDefaultWidth) * activeObject.scaleX),
                    actObjH = activeObjectHeight,
                    actObjW = activeObjectWidth,
                    actObjRH = actDefaultHeight,
                    actObjRW = actDefaultWidth,
                    horizontalInTheRange = false,
                    verticalInTheRange = false,
                    leftGuide = false,
                    rightGuide = false,
                    topGuide = false,
                    bottomGuide = false,
                    posSnapLeft = 0,
                    posSnapRight = 0,
                    posSnapTop = 0,
                    posSnapBottom = 0,
                    transform = canvas._currentTransform,
                    vMoving = '',
                    hMoving = '',
                    actAngle = (activeObject.angle > -1) ? (activeObject.angle)%360 : (360 + (activeObject.angle)%360),
                    eTransform = e.transform


                // Set 360 angle to 0
                if(actAngle === 360) actAngle = 0

                // Check when select multi-object, group or single.
                var multi = false,
                    checkObj = []

                if (activeObject._objects){
                    if (activeObject._objects.length > 1){
                        multi = true

                        for(var xx = 0
 xx < canvasObjects.length; xx++){
                            for(var yy = 0
 yy < activeObject._objects.length; yy++){
                                if(canvasObjects[xx] === activeObject._objects[yy]){
                                    checkObj.push(xx)

                                }
                            }
                        }
                    }
                }else checkObj = activeObject


                if (e.pointer.x < activeObjectLeft) hMoving = 'left'

                else hMoving = 'right'

                if (e.pointer.y < activeObjectTop) vMoving = 'top'

                else vMoving = 'bottom'


                if (!transform) return

                // Support rotation 0, 90, 180 ,270
                if (actAngle%90 !== 0) return

                else{
                    if(actAngle == 90 || actAngle == 270) {
                        actObjH = activeObjectWidth

                        actObjW = activeObjectHeight

                        actObjRH = actDefaultWidth

                        actObjRW = actDefaultHeight

                    }
                    switch (actAngle) {
                        case 0:
                            posSnapLeft = 'left'

                            posSnapRight = 'right'

                            posSnapTop = 'top'

                            posSnapBottom = 'bottom'

                            break

                        case 90:
                            posSnapLeft = 'bottom'

                            posSnapRight = 'top'

                            posSnapTop = 'left'

                            posSnapBottom = 'right'

                            break

                        case 180:
                            posSnapLeft = 'right'

                            posSnapRight = 'left'

                            posSnapTop = 'bottom'

                            posSnapBottom = 'top'

                            break

                        case 270:
                            posSnapLeft = 'top'

                            posSnapRight = 'bottom'

                            posSnapTop = 'right'

                            posSnapBottom = 'left'

                            break

                    }
                }

                for (var i = canvasObjects.length
 i--;) {
                    if(!multi || activeObject.get('type') === 'group' || activeObject.get('type') === 'clippingGroup'){
                        if (canvasObjects[i] === activeObject) continue

                    }else{ if((checkObj.indexOf(i) > -1)) continue
 }

                    //check imprint area
                    if(RolandKioskPrint.AppData.isProductDesigner()){
                        if(canvasObjects[i].id === "foilImprintArea" || canvasObjects[i].id === "metalImprintArea") continue

                    }

                    var objectCenter = canvasObjects[i].getCenterPoint(),
                        objectLeft = objectCenter.x,
                        objectTop = objectCenter.y,
                        objectBoundingRect = canvasObjects[i].getBoundingRect(),
                        objectHeight = objectBoundingRect.height / viewportTransform[3],
                        objectWidth = objectBoundingRect.width / viewportTransform[0],
                        objRTop = objectTop - objectHeight / 2,
                        objRLeft = objectLeft - objectWidth / 2,
                        newWidth = 0,
                        newHeight = 0,
                        snapLeft = false,
                        snapRight = false,
                        snapTop = false,
                        snapBottom = false


                    // snap by the left edge
                    if (isInRange(objRLeft, activeObjectLeft - actObjW / 2) && hMoving == 'left') {
                        if (verticalInTheRange) continue

                        verticalLines.push({
                            x: objRLeft,
                            y1: (objRTop < activeObjectTop - actObjH / 2) ? (objRTop) : (activeObjectTop - actObjH / 2),
                            y2: (activeObjectTop + actObjH / 2 > objectTop + objectHeight / 2) ? (activeObjectTop + actObjH / 2) : (objectTop + objectHeight / 2)
                        })

                        if (hMoving == 'left'){
                            if (activeObject.compareWith != i || activeObject.verticalSnap == 'right') {
                                newWidth = ((activeObjectLeft + actObjW / 2) - (objRLeft))

                                activeObject.set({
                                    newWidth: newWidth,
                                    compareWith: i,
                                    verticalSnap: 'left'
                                })

                            }
                        }
                        verticalInTheRange = true

                        snapLeft = true

                    }

                    // snap by the right edge
                    if (isInRange(objectLeft + objectWidth / 2, activeObjectLeft + actObjW / 2) && hMoving == 'right') {
                        if (verticalInTheRange) continue

                        verticalLines.push({
                            x: objectLeft + objectWidth / 2,
                            y1: (objRTop < activeObjectTop - actObjH / 2) ? (objRTop) : (activeObjectTop - actObjH / 2),
                            y2: (activeObjectTop + actObjH / 2 > objectTop + objectHeight / 2) ? (activeObjectTop + actObjH / 2) : (objectTop + objectHeight / 2)
                        })

                        if (hMoving == 'right'){
                            if (activeObject.compareWith != i || activeObject.verticalSnap == 'left') {
                                newWidth = ((objectLeft + objectWidth / 2) - (activeObjectLeft - actObjW / 2))

                                activeObject.set({
                                    newWidth: newWidth,
                                    compareWith: i,
                                    verticalSnap: 'right'
                                })

                            }
                        }
                        verticalInTheRange = true

                        snapRight = true

                    }

                    // snap by the top edge
                    if (isInRange(objRTop, activeObjectTop - actObjH / 2) && vMoving == 'top') {
                        if (horizontalInTheRange) continue

                        horizontalLines.push({
                            y: objRTop,
                            x1: (objRLeft < activeObjectLeft - actObjW / 2) ? (objRLeft) : (activeObjectLeft - actObjW / 2),
                            x2: (activeObjectLeft + actObjW / 2 > objectLeft + objectWidth / 2) ? (activeObjectLeft + actObjW / 2) : (objectLeft + objectWidth / 2)
                        })

                        if (vMoving == 'top'){
                            if (activeObject.compareHeight != i || activeObject.horizontalSnap == 'bottom') {
                                newHeight = ((activeObjectTop + actObjH / 2) - (objRTop))

                                activeObject.set({
                                    newHeight: newHeight,
                                    compareHeight: i,
                                    horizontalSnap: 'top'
                                })

                            }
                        }
                        horizontalInTheRange = true

                        snapTop = true

                    }

                    // snap by the bottom edge
                    if (isInRange(objectTop + objectHeight / 2, activeObjectTop + actObjH / 2) && vMoving == 'bottom') {
                        if (horizontalInTheRange) continue

                        horizontalLines.push({
                            y: objectTop + objectHeight / 2,
                            x1: (objRLeft < activeObjectLeft - actObjW / 2) ? (objRLeft) : (activeObjectLeft - actObjW / 2),
                            x2: (activeObjectLeft + actObjW / 2 > objectLeft + objectWidth / 2) ? (activeObjectLeft + actObjW / 2) : (objectLeft + objectWidth / 2)
                        })

                        if (vMoving == 'bottom'){
                            if (activeObject.compareHeight != i || activeObject.horizontalSnap == 'top') {
                                newHeight = ((objectTop + objectHeight / 2) - (activeObjectTop - actObjH / 2))

                                activeObject.set({
                                    newHeight: newHeight,
                                    compareHeight: i,
                                    horizontalSnap: 'bottom'
                                })

                            }
                        }
                        horizontalInTheRange = true

                        snapBottom = true

                    }

                    if (snapLeft || snapRight || snapTop || snapBottom) {
                        var scaleXN = 1,
                            scaleYN = 1,
                            newX = 0,
                            newY = 0


                        if (snapLeft) {
                            scaleXN = activeObject.newWidth / (actObjRW)

                            if(scaleXN === 0) scaleXN = 0.000001

                            newX = (objectLeft - objectWidth / 2)

                            if(posSnapLeft === 'left' || posSnapLeft === 'right'){
                                activeObject.scaleX = scaleXN

                                activeObject.set(posSnapLeft, newX)

                            }
                            else {
                                activeObject.scaleY = scaleXN

                                if(posSnapLeft === 'bottom') activeObject.set(posSnapLeft, newX)

                                else activeObject.setPositionByOrigin(new fabric.Point((objectLeft - objectWidth / 2) + (actDefaultHeight*scaleXN/2),activeObjectTop), 'center', 'center')



                            }
                        }

                        if (snapRight) {
                            scaleXN = activeObject.newWidth / (actObjRW)

                            if(scaleXN === 0) scaleXN = 0.000001

                            newX = (objectLeft + objectWidth / 2)

                            if(scaleXN > 0.001) {
                                if(posSnapRight === 'left' || posSnapRight === 'right'){
                                    activeObject.scaleX = scaleXN

                                    activeObject.set(posSnapRight, newX)

                                }
                                else {
                                    activeObject.scaleY = scaleXN

                                    if(posSnapRight === 'bottom') activeObject.set(posSnapRight, newX)

                                    else activeObject.setPositionByOrigin(new fabric.Point((objectLeft + objectWidth / 2) - (actDefaultHeight*scaleXN/2),activeObjectTop), 'center', 'center')

                                }
                            }
                        }

                        if (snapTop) {
                            scaleYN = activeObject.newHeight / (actObjRH)

                            if(scaleYN === 0) scaleYN = 0.000001

                            newY = (objectTop - objectHeight / 2)

                            if(scaleYN > 0.001) {
                                if(posSnapTop === 'top' || posSnapTop === 'bottom'){
                                    activeObject.scaleY = scaleYN

                                    activeObject.set(posSnapTop, newY)

                                }
                                else {
                                    activeObject.scaleX = scaleYN

                                    if(posSnapTop === 'left') activeObject.set('top', newY)

                                    else activeObject.set('bottom', newY)

                                }
                            }
                        }

                        if (snapBottom) {
                            scaleYN = activeObject.newHeight / (actObjRH)

                            if(scaleYN === 0) scaleYN = 0.000001

                            newY = (objectTop + objectHeight / 2)

                            if(scaleYN > 0.001){

                                if(posSnapBottom === 'top' || posSnapBottom === 'bottom'){
                                    activeObject.scaleY = scaleYN

                                    activeObject.set(posSnapBottom, newY)

                                }
                                else {
                                    activeObject.scaleX = scaleYN

                                    if(posSnapBottom === 'left') activeObject.set('top', newY)

                                    else activeObject.set('bottom', newY)

                                }
                            }
                        }
                    }

                    if (!horizontalInTheRange) {
                        horizontalLines.length = 0

                    }

                    if (!verticalInTheRange) {
                        verticalLines.length = 0

                    }
                }
            },
            'before:render': function () {
                canvas.clearContext(canvas.contextTop)

            },
            'after:render': function () {
                for (var i = verticalLines.length
 i--;) {
                    drawVerticalLine(verticalLines[i])

                }
                for (var ii = horizontalLines.length
 ii--;) {
                    drawHorizontalLine(horizontalLines[ii])

                }
                verticalLines.length = horizontalLines.length = 0

            },
            'mouse:up': function (event) {
                // clear these values, to stop drawing guidelines once mouse is up
                verticalLines.length = horizontalLines.length = 0

                canvas.renderAll()

                for (var i = canvas._objects.length
 i--;) {
                    canvas._objects[i].set({
                        'newWidth': 0,
                        'newHeight': 0,
                        'compareWith': 999,
                        'compareHeight': 999,
                        'verticalSnap': '',
                        'horizontalSnap': ''
                    })

                }
            }
        }

        canvas.on(this.onAligningGuideEvents)

    },

    onCanvasPanelAfterRender: function(component, eOpts) {
        // Get hold of the html canvas element.
        var canvasContainer = this.getView().down('#canvasContainer')

        var containerElement = canvasContainer.getEl().dom


        var canvasElement = containerElement.getElementsByClassName('mainCanvas')[0]

        var previewCanvasContainer = containerElement.getElementsByClassName('previewCanvasContainer')[0]


        var previewCanvasElement = previewCanvasContainer.getElementsByClassName('previewCanvas')[0]

        var panCanvasElement = previewCanvasContainer.getElementsByClassName('panCanvas')[0]

        var previewCanvasLabel = previewCanvasContainer.getElementsByClassName('previewCanvasLabel')[0]


        // Create the fabric.js canvas object.
        var canvas = new fabric.Canvas(canvasElement)

        var previewCanvas = new fabric.StaticCanvas(previewCanvasElement)

        var panCanvas = new fabric.Canvas(panCanvasElement)


        this.setCanvasAttributes(canvas, previewCanvas, panCanvas)


        // Stash the fabric canvas off the controller.
        this.canvas = canvas

        this.previewCanvas = previewCanvas

        this.panCanvas = panCanvas

        this.previewCanvasContainer = previewCanvasContainer

        this.previewCanvasLabel = previewCanvasLabel


        this.mainToPreviewCanvasSizeRatio =
        (1 / RolandKioskPrint.app.constants.PREVIEW_CANVAS_SIZE_FACTOR)

        this.currentZoomLevel = RolandKioskPrint.app.constants.INITIAL_ZOOM_LEVEL

        this.previewCanvasHidden = (this.currentZoomLevel <= 1)

    },

    onCanvasPanelAfterLayout: function(container, layout, eOpts) {
        if (!this.initialized) {
            return
 // Not initialized.
        }

        this.recalcCanvasLayout()


        var canvas = this.canvas

        var data = this.productSizeData


        var objects = canvas.getObjects()

        if (objects.length === 0) {
            // Compute the corner radius value to use.
            var minMargin = Math.min(data.leftMarginMM, data.topMarginMM, data.rightMarginMM, data.bottomMarginMM)

            var cornerRadius = data.cornerRadiusMM - minMargin

            if (cornerRadius < 0 || data.cornerRadiusMM === 0) {
                cornerRadius = 0

            }

            // Generate the default margin area.
            var marginArea = new fabric.Rect({
                left: data.leftMarginMM,
                top: data.topMarginMM,
                width: data.widthMM - data.leftMarginMM - data.rightMarginMM,
                height: data.heightMM - data.topMarginMM - data.bottomMarginMM,
                rx: cornerRadius,
                ry: cornerRadius,
                visible: false,
                id: 'margin',
                excludeFromExport: true, // gets re-created from product size data
                fill: false,
                stroke: false,
                objectCaching: false
            })

            canvas.add(marginArea)

            canvas.lowestFgObjectIndex = 1

        }

        if (this.isProductModelDesigner) {
            if (this.foilPrint) {
                // Create the default foil imprint area if none exists.
                var foilImprintArea = this.getImprintArea(RolandKioskPrint.app.constants.PRINT_TYPE_FOIL)


                if (!foilImprintArea) {
                    this.createImprintArea(RolandKioskPrint.app.constants.PRINT_TYPE_FOIL,
                    RolandKioskPrint.app.constants.OBJECT_SOURCE_PMD)

                }
            }

            if (this.metalPrint) {
                // Create the default metal imprint area if none exists.
                var metalImprintArea = this.getImprintArea(RolandKioskPrint.app.constants.PRINT_TYPE_METAL)


                if (!metalImprintArea) {
                    this.createImprintArea(RolandKioskPrint.app.constants.PRINT_TYPE_METAL,
                    RolandKioskPrint.app.constants.OBJECT_SOURCE_PMD)

                }
            }
        }

        if (!this.designLoaded && !this.designLoading) {
            this.designLoading = true


            if (this.productDesignPath) {
                this.parentView.getEl().mask(RolandKioskPrint.app.getString('message.designer.loadingProductModelDesign'))


                var promise = this.loadProductDesignJSON()


                // Fire the custom canvas ready event.
                promise.then(
                function() {
                    canvas.fire('canvas:x-ready')

                },
                function() {
                    canvas.fire('canvas:x-ready')

                }
                ).always(function() {
                    if (this.foilPrint || this.metalPrint) {
                        this.transformCanvasViewport()
 // Handles case where imprint area may be outside the product bounds.
                    }
                    this.parentView.getEl().unmask()

                }, this)

            } else if (this.productDesignSVG) {
                this.parentView.getEl().mask(RolandKioskPrint.app.getString('message.designer.loadingProductModelDesign'))


                var promise = this.loadProductDesignSVG()


                // Fire the custom canvas ready event.
                promise.then(function() {
                    canvas.fire('canvas:x-ready')

                }).always(function() {
                    // No transformCanvasViewport needed for SVG.
                    this.parentView.getEl().unmask()

                }, this)

            } else {
                // Nothing to pre-load, fire the custom canvas ready event.
                canvas.fire('canvas:x-ready')

            }

            this.designLoaded = true

            this.designLoading = false

        }

        canvas.renderAll()

        this.initAligningGuidelines(canvas)

    }

})

