/*
 * File: app/view/panel/GroupPanelViewController.js
 *
 * This file was generated by Sencha Architect version 4.2.4.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 6.6.x Classic library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 6.6.x Classic. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RolandKioskPrint.view.panel.GroupPanelViewController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.panel.grouppanel',

    parentShown: function() {
        // Update the panel.
        this.updatePanel()


        // Register for further selection change notifications.
        var canvas = RolandKioskPrint.AppData.getCanvas()

        var me = this


        if (!this.onCanvasSelectionChange) {
            this.onCanvasSelectionChange = {
                'selection:created': function() {
                    me.updatePanel()

                },
                'selection:updated': function() {
                    me.updatePanel()

                },
                'selection:cleared': function() {
                    me.updatePanel()

                }
            }

        }
        canvas.on(this.onCanvasSelectionChange)

    },

    parentHidden: function() {
        // Unregister for canvas notifications.
        if (this.onCanvasSelectionChange) {
            var canvas = RolandKioskPrint.AppData.getCanvas()

            canvas.off(this.onCanvasSelectionChange)

        }
    },

    updatePanel: function() {
        var canGroup = false,
            canUngroup = false


        var canvas = RolandKioskPrint.AppData.getCanvas()

        var activeObject = canvas.getActiveObject()


        var cropMode = RolandKioskPrint.AppData.getCropMode()

        if (!cropMode) {
            // Enable grouping if we have multiple items selected
            // ie. we have an active group selection.
            canGroup = (activeObject  && !activeObject.isEffectivelyLocked &&
                        !activeObject.isLocked && activeObject.get('type') == 'activeSelection') ? true : false


            // Enable ungrouping if we have a group selected.
            // Exclude fabric 2.x cliparts which are now group objects.
            canUngroup = (activeObject && !activeObject.isEffectivelyLocked &&
                          !activeObject.isLocked && activeObject.get('type') == 'group' && !activeObject.isPathGroup) ? true : false

        }

        // Do not allow edit areas or foil imprint area to be grouped.
        if (canGroup) {
            var objects = activeObject.getObjects()

            for (var i = 0, length = objects.length
 i < length; i++) {
                if (objects[i].editAreaType || RolandKioskPrint.AppData.isImprintArea(objects[i])) {
                    canGroup = false

                    break

                }
            }
        }

        // Do not allow objects clipped by different edit areas to be grouped together.
        if (canGroup) {
            var objects = activeObject.getObjects()


            var firstEditAreaId = (objects[0].clipTo !== null) ? objects[0].editAreaId : ''

            for (var i = 1, length = objects.length
 i < length; i++) {
                var editAreaId = (objects[i].clipTo !== null) ? objects[i].editAreaId : ''

                if (editAreaId != firstEditAreaId) {
                    canGroup = false

                    break

                }
            }
        }

        // Do not allow objects of diff print type to be grouped together.
        // Cut and color can go together.
        if (canGroup) {
            var objects = activeObject.getObjects()

            for (var i = 1, length = objects.length
 i < length; i++) {
                if (!this.isPrintTypeCompatible(objects[0].printType, objects[i].printType)) {
                    canGroup = false

                    break

                }
            }
        }

        var isProductModelDesigner = RolandKioskPrint.AppData.isProductModelDesigner()


        // Do not allow background objects to be grouped with others.
        if (canGroup && isProductModelDesigner) {
            var objects = activeObject.getObjects()

            var hasBGObjects = false

            var onlyBGObjects = true


            for (var i = 0, length = objects.length
 i < length; i++) {
                if (hasBGObjects && !onlyBGObjects) {
                    canGroup = false

                    break

                }
                else if (objects[i].id == 'background') {
                    hasBGObjects = true

                } else {
                    onlyBGObjects = false

                }
            }
            if (hasBGObjects && !onlyBGObjects) {
                canGroup = false

            }
        }

        // Doing away with view-model bindings.
        // These were not functioning correctly with ExtJS 6.6
        // Now enabling/disabling buttons directly.

        this.getView().down('#btnGroup').setDisabled(!canGroup)

        this.getView().down('#btnUngroup').setDisabled(!canUngroup)

    },

    isPrintTypeCompatible: function(type1, type2) {
        var constants = RolandKioskPrint.app.constants

        if (type1 == constants.PRINT_TYPE_COLOR && type2 == constants.PRINT_TYPE_CUT ||
            type1 == constants.PRINT_TYPE_CUT && type2 == constants.PRINT_TYPE_COLOR) {
            return true

        }

        return (type1 == type2)

    },

    onGroupButtonClick: function(button, e, eOpts) {
        var canvas = RolandKioskPrint.AppData.getCanvas()

        var canvasPanel = RolandKioskPrint.AppData.getCanvasPanel()

        var isProductModelDesigner = RolandKioskPrint.AppData.isProductModelDesigner()


        // If we have a selection group, remove its objects from canvas, and add
        // those to a new group. Set the new group as the active object.

        var activeObject = canvas.getActiveObject()

        if (activeObject  && !activeObject.isLocked && activeObject.get('type') == 'activeSelection') {
            var undoRedoPanel = RolandKioskPrint.AppData.getUndoRedoPanel()

            undoRedoPanel.getController().mute()
 // Mute undo/redo handling. We notify once at end.

            var objectsInGroup = activeObject.getObjects()

            canvas.discardActiveObject()


            var objectCaching = true

            objectsInGroup.forEach(function(o) {
                if (!o.objectCaching) {
                    objectCaching = false

                }
                canvas.remove(o)

            })


            var newGroup = new fabric.Group(objectsInGroup)

            newGroup.set('objectCaching', objectCaching)


            // Set group editAreaId and clipTo if the objects were clipped.
            // Remove editAreaId and clipTo from objects.
            if (objectsInGroup[0].clipTo !== null) {
                newGroup.editAreaId = objectsInGroup[0].editAreaId


                objectsInGroup.forEach(function(o) {
                    o.clipTo = null

                    delete o.editAreaId

                })

            }

            if (newGroup.editAreaId) {
                var canvasPanel = RolandKioskPrint.AppData.getCanvasPanel()

                newGroup.set({
                    printType: RolandKioskPrint.AppData.getActivePrintType()
                })

                canvasPanel.getController().addObjectToEditAreaById(newGroup, newGroup.editAreaId)

            } else if (objectsInGroup[0].id == 'background') {
                var sourceType = isProductModelDesigner ? RolandKioskPrint.app.constants.OBJECT_SOURCE_PMD :
                RolandKioskPrint.app.constants.OBJECT_SOURCE_PD

                newGroup.set({
                    id: 'background',
                    sourceType: sourceType,
                    skipDrawing: true
                })

                canvas.insertAt(newGroup, canvasPanel.getController().getNextBGObjectIndex())

            } else {
                newGroup.set({
                    printType: RolandKioskPrint.AppData.getActivePrintType()
                })

                canvas.add(newGroup)

            }

            // Set the group object as active.
            canvas.setActiveObject(newGroup)


            undoRedoPanel.getController().unmute()

            canvas.fire('object:added', {target: newGroup})


            canvas.renderAll()

        }
    },

    onUngroupButtonClick: function(button, e, eOpts) {
        var canvas = RolandKioskPrint.AppData.getCanvas()

        var canvasController = RolandKioskPrint.AppData.getCanvasPanel().getController()


        // If the selected object is a group, add its objects back to canvas.
        // Create a new group from these objects and set as active.
        var activeObject = canvas.getActiveObject()

        if (activeObject && !activeObject.isLocked && activeObject.get('type') == 'group' && !activeObject.isPathGroup) {
            var undoRedoPanel = RolandKioskPrint.AppData.getUndoRedoPanel()

            undoRedoPanel.getController().mute()
 // Mute undo/redo handling. We notify once at end.

            var objectsInGroup = activeObject.getObjects()

            var isBGObject = (activeObject.id == 'background')

            activeObject._restoreObjectsState()

            canvas.remove(activeObject)


            var editAreaId

            if (activeObject.clipTo !== null) {
                editAreaId = activeObject.editAreaId

            }

            canvas.discardActiveObject()


            // If the group was clipped to edit area, add the individual objects back to edit area.
            if (editAreaId) {
                var canvasPanel = RolandKioskPrint.AppData.getCanvasPanel()

                objectsInGroup.forEach(function(o) {
                    canvasPanel.getController().addObjectToEditAreaById(o, editAreaId)

                })

            } else if (isBGObject) {
                var temp = canvas.renderOnAddRemove

                canvas.renderOnAddRemove = false


                var nextBGObjectIndex = canvasController.getNextBGObjectIndex()

                objectsInGroup.forEach(function(o) {
                    canvas.insertAt(o, nextBGObjectIndex++)

                })

                canvas.renderOnAddRemove = temp

            } else {
                objectsInGroup.forEach(function(o) {
                    canvas.add(o)

                })

            }

            var selectionGroup = new fabric.ActiveSelection(objectsInGroup, {
                canvas: canvas
            })

            canvas.setActiveObject(selectionGroup)


            undoRedoPanel.getController().unmute()

            canvas.fire('object:removed')


            canvas.renderAll()

        }
    }

})

