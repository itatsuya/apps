/*
 * File: app/view/UnpaidMainViewController.js
 *
 * This file was generated by Sencha Architect version 4.2.4.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 6.6.x Classic library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 6.6.x Classic. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RolandKioskPrint.view.UnpaidMainViewController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.unpaidmain',

    refreshOrderLists: function(showMask, getPaymentStatus) {
        var unpaidView = this.getView()


        // Get the currently selected row
        var itemIdArray = [
            '#unpaidOrdersList',
            '#printingWaitingOrdersList',
            '#readyToReceiveOrdersList',
            '#deliveredOrdersList'
        ]


        var selectedStoreIndex = -1,
            selectedRecordIndex = -1


        for (var i = 0
 i < 4; i++) {
            var ordersList = unpaidView.down(itemIdArray[i])

            if (ordersList.getSelectionModel().hasSelection()) {
               selectedStoreIndex = i

               break

            }
        }

        if (selectedStoreIndex >= 0) {
            var ordersList = unpaidView.down(itemIdArray[selectedStoreIndex])

            var selectedRecord = ordersList.getSelectionModel().getSelection()[0]

            selectedRecordIndex = ordersList.getStore().indexOf(selectedRecord)

        }

        // Get the list of orders, and populate the lists.
        if (showMask) {
            unpaidView.getEl().mask(RolandKioskPrint.app.getString('message.unpaid.fetchingOrders'))

        }

        var serverUrl = RolandKioskPrint.app.constants.ALL_ORDERS_URL

        if (getPaymentStatus) {
            serverUrl += '?paymentStatus=true'

        }

        //var now = new Date()


        Ext.Ajax.request({
            scope: this,
            url: serverUrl,
            success: function(response, opts) {
                if (showMask) {
                    unpaidView.getEl().unmask()

                }

                //console.log('Time taken to load orders = ' + (new Date() - now))


                var ordersObj = Ext.decode(response.responseText)

                if (!ordersObj) {
                    return

                }

                if (getPaymentStatus) {
                    this.updateLayout(ordersObj.paymentConfirmBeforePrinting,
                                      ordersObj.skipPaymentConfirmation)

                }

                var unpaidOrdersPanel = unpaidView.down('#pnlUnpaidOrders')

                if (!unpaidOrdersPanel.isVisible()) {
                    ordersObj.unpaidOrders = []

                }

                if (ordersObj.unpaidOrders) {
                    var unpaidOrdersList = unpaidView.down('#unpaidOrdersList')

                    unpaidOrdersList.getStore().setData(ordersObj.unpaidOrders)

                }

                if (ordersObj.printingWaitingOrders) {
                    var printingWaitingOrdersList = unpaidView.down('#printingWaitingOrdersList')

                    printingWaitingOrdersList.getStore().setData(ordersObj.printingWaitingOrders)

                }

                if (ordersObj.readyToReceiveOrders) {
                    var readyToReceiveOrdersList = unpaidView.down('#readyToReceiveOrdersList')

                    readyToReceiveOrdersList.getStore().setData(ordersObj.readyToReceiveOrders)

                }

                if (ordersObj.deliveredOrders) {
                    var deliveredOrdersList = unpaidView.down('#deliveredOrdersList')

                    deliveredOrdersList.getStore().setData(ordersObj.deliveredOrders)

                }

                var rowSelected = false

                if (selectedStoreIndex >= 0 && selectedRecordIndex >= 0) {
                    var selectedGridPanel = unpaidView.down(itemIdArray[selectedStoreIndex])

                    if (selectedRecordIndex < selectedGridPanel.getStore().getCount()) {
                        selectedGridPanel.getSelectionModel().select(selectedRecordIndex)

                        rowSelected = true

                    }
                }

                if (!rowSelected) {
                    for (var i = 0
 i < 4; i++) {
                        var gridPanel = unpaidView.down(itemIdArray[i])

                        if (gridPanel.getStore().getCount() > 0) {
                            gridPanel.getSelectionModel().select(0)

                            break

                        }
                    }
                }
            },
            failure: function() {
                if (showMask) {
                    unpaidView.getEl().unmask()

                }
            }
        })

    },

    displayOrderDetails: function(record) {
        this.getViewModel().setData(record.data)


        var imgProductDesign = this.getView().down('#imgProductDesign')

        var url = "url('" + record.data.thumbPath + "')"


        imgProductDesign.setStyle({
            backgroundImage: url,
            backgroundRepeat: 'no-repeat',
            backgroundSize: 'contain',
            backgroundPosition: 'center center'
        })

    },

    clearSelectionInOtherLists: function(selectedListItemId) {
        var itemIdArray = ['#unpaidOrdersList', '#printingWaitingOrdersList',
                          '#readyToReceiveOrdersList', '#deliveredOrdersList']

        var unpaidView = this.getView()


        for (var i = 0
 i < 4; i++) {
            if (itemIdArray[i] !== selectedListItemId) {
                var ordersList = unpaidView.down(itemIdArray[i])

                ordersList.getSelectionModel().deselectAll()

            }
        }
    },

    updateLayout: function(paymentConfirmBeforePrinting, skipPaymentConfirmation) {
        var view = this.getView(),
            paymentBeforePrinting = (!skipPaymentConfirmation && paymentConfirmBeforePrinting),
            paymentAfterPrinting = (!skipPaymentConfirmation && !paymentConfirmBeforePrinting),
            i = 1


        if (paymentBeforePrinting) {
            var unpaidOrderListHeader = RolandKioskPrint.app.getString('label.unpaid.unpaidOrderListHeader')

            view.down('#lblUnpaidOrders').setText(i++ + '. ' + unpaidOrderListHeader)

        } else {
            view.down('#pnlUnpaidOrders').hide()

        }

        var waitingForPrintingOrderListHeader = RolandKioskPrint.app.getString('label.unpaid.waitingForPrintingOrderListHeader'),
            receivingPossibilityOrderListHeader = RolandKioskPrint.app.getString('label.unpaid.receivingPossibilityOrderListHeader'),
            deliveredOrderListHeader = RolandKioskPrint.app.getString('label.unpaid.deliveredOrderListHeader'),
            deliveredOrderListHeader2 = RolandKioskPrint.app.getString('label.unpaid.deliveredOrderListHeader2')


        view.down('#lblPrintingWaiting').setText(i++ + '. ' + waitingForPrintingOrderListHeader)

        view.down('#lblReceivingPossibility').setText(i++ + '. ' + receivingPossibilityOrderListHeader)

        view.down('#lblDelivered').setText(i++ + '. ' + (paymentAfterPrinting ? deliveredOrderListHeader2 : deliveredOrderListHeader))

    },

    searchOrders: function(searchFieldValue) {
        var itemIdArray = [
            '#unpaidOrdersList',
            '#printingWaitingOrdersList',
            '#readyToReceiveOrdersList',
            '#deliveredOrdersList'
        ]


        var unpaidView = this.getView()

        var selectedStoreIndex = 0, nextSearchStartIndex = 0

        for (var i = 0
 i < 4; i++) {
            var ordersList = unpaidView.down(itemIdArray[i])

            if (ordersList.getSelectionModel().hasSelection()) {
               selectedStoreIndex = i

               break

            }
        }

        var ordersList = unpaidView.down(itemIdArray[selectedStoreIndex])

        if (ordersList.getSelectionModel().hasSelection()) {
            var selectedRecord = ordersList.getSelectionModel().getSelection()[0]

            nextSearchStartIndex = ordersList.getStore().indexOf(selectedRecord) + 1

        }

        // Search next within the current store.
        var matchIndex = ordersList.getStore().find('orderId', searchFieldValue,
                                                    nextSearchStartIndex, true)

        if (matchIndex >= 0) {
            ordersList.getSelectionModel().select(matchIndex)

            return

        }

        // Not found in current store. Start searching from next store.
        nextSearchStartIndex = 0

        selectedStoreIndex = (selectedStoreIndex + 1) % 4


        var found = false

        for (var i = 0
 i < 4; i++) {
            var ordersList = unpaidView.down(itemIdArray[selectedStoreIndex])

            var matchIndex = ordersList.getStore().find('orderId', searchFieldValue,
                                                        nextSearchStartIndex, true)

            if (matchIndex >= 0) {
                found = true

                ordersList.getSelectionModel().select(matchIndex)


                this.clearSelectionInOtherLists(itemIdArray[selectedStoreIndex])

                break

            }

            selectedStoreIndex = (selectedStoreIndex + 1) % 4

        }

        if (!found) {
            Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.alert'),
                          RolandKioskPrint.app.getString('message.unpaid.noResultsFound'))

        }
    },

    setOrderListUpdateInterval: function() {
        var controller = this

        var intervalHandle = setInterval(function() {
            controller.refreshOrderLists()

        }, 10*1000)


        this.getViewModel().set('intervalHandle', intervalHandle)

        this.getViewModel().set('intervalEnabled', true)

    },

    clearOrderListUpdateInterval: function() {
        var intervalEnabled = this.getViewModel().get('intervalEnabled')

        if(intervalEnabled){
            var intervalHandle = this.getViewModel().get('intervalHandle')

            clearInterval(intervalHandle)

            this.getViewModel().set('intervalEnabled', false)

        }
    },

    addOrdersSorter: function(orderListId, sortDirection) {
        var orderList = this.getView().down(orderListId),
            ordersStore = orderList.getStore()


        var sorters = ordersStore.getSorters()

        sorters.add({
            sorterFn: this.compareOrdersByOrderId,
            direction: sortDirection
        })

    },

    compareOrdersByOrderId: function(a, b) {
        // The order id is formatted as mmYnnnnn
        //    mm - month the order is created in, 01-12
        //     Y - year code of the order, A - 2017, B - 2018, C - 2019 etc.
        // nnnnn - order number in the month

        var aid = a.data.orderId,
            bid = b.data.orderId


        // Sort the orders chronologically.
        var ay = aid.slice(2, 3),
            by = bid.slice(2, 3)


        var result

        if (ay != by) {
            // Sort by year.
            result = ay.localeCompare(by)

        } else {
            // Same year. Sort by month.
            var am = Number(aid.slice(0, 2)),
                bm = Number(bid.slice(0, 2))


            if (am != bm) {
                result = am - bm

            } else {
                // Same month of year. Sort by order number.
                var an = Number(aid.slice(3)),
                    bn = Number(bid.slice(3))

                result = an - bn

            }
        }
        return result

    },

    onSearchButtonClick: function(field, trigger, e) {
        var searchFieldValue = field.getValue()

        this.searchOrders(searchFieldValue)


        // iPad specific fix.
        // Stop the event propagation, otherwise textfield will be on focus.
        // (see text field click event registration). Cancel blur to hide visible keypad.
        e.stopPropagation()

        document.activeElement.blur()

    },

    onSearchFieldSpecialkey: function(field, e, eOpts) {
        if (e.getKey() == e.ENTER) {
            var searchFieldValue = field.getValue()

            this.searchOrders(searchFieldValue)

        }
    },

    onTextfieldAfterRender: function(component, eOpts) {
        component.getEl().on({
            click : function (e) {
                // iPad specific fix.
                // Focus the textfield when clicked. Otherwsie keypad doesn't come up.
                if (e.target && e.target.tagName.toUpperCase() == 'INPUT') {
                    component.focus()

                }
            }
        })

    },

    onRefreshButtonClick: function(button, e, eOpts) {
        this.refreshOrderLists()

    },

    onHelpButtonClick: function(button, e, eOpts) {
        var curPrefLang = RolandKioskPrint.app.getPrefLanguage()

        var helpSrc = 'resources/help/' + curPrefLang + '/cotodesignOrderViewer/ov.html'

        RolandKioskPrint.view.window.HelpWindowViewController.showHelp(
        helpSrc, 'pmd-mld-help-window', 300)

    },

    onUnpaidOrdersListSelect: function(rowmodel, record, index, eOpts) {
        this.displayOrderDetails(record)

        this.clearSelectionInOtherLists('#unpaidOrdersList')

    },

    confirmPayment: function(view, rowIndex, colIndex, item, e, record, row) {
        var printingWaitingOrdersList = this.getView().down('#printingWaitingOrdersList')

        var unpaidOrdersListView = view


        var selectedRecords = unpaidOrdersListView.getSelectionModel().getSelection()


        if (selectedRecords.length === 0 || selectedRecords[0].data.orderId !== record.data.orderId){
            //Allow payment confirmation only for selected items.
            return

        }

        var paidOrders = [{
            orderId: record.data.orderId,
            paid : "TRUE"
        }]


        var paidOrdersData = {
            orders : paidOrders
        }


        unpaidOrdersListView.getEl().mask(RolandKioskPrint.app.getString('message.unpaid.confirmingPayment'))

        Ext.Ajax.request({
            scope: this,
            method: 'PUT',
            url: RolandKioskPrint.app.constants.ORDERS_PAYMENT_URL,
            jsonData: paidOrdersData,
            success: function(response, opts) {
                unpaidOrdersListView.getEl().unmask()


                var responseData = Ext.decode(response.responseText)

                if (!responseData || !responseData.success) {
                    Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                    RolandKioskPrint.app.getString('message.unpaid.paymentConfirmationFailed'))

                    return

                }

                unpaidOrdersListView.getStore().remove(record)

                unpaidOrdersListView.refresh()


                var nextSelectedRowIndex = rowIndex

                if ((nextSelectedRowIndex + 1) > unpaidOrdersListView.getStore().getCount()){
                    nextSelectedRowIndex = unpaidOrdersListView.getStore().getCount() - 1

                }

                if (nextSelectedRowIndex >= 0) {
                    unpaidOrdersListView.getSelectionModel().select(nextSelectedRowIndex)

                }

                printingWaitingOrdersList.getStore().add(record)

                printingWaitingOrdersList.getView().refresh()

            },
            failure: function() {
                unpaidOrdersListView.getEl().unmask()

                Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                RolandKioskPrint.app.getString('message.unpaid.paymentConfirmationFailed'))

            }
        })

    },

    onPrintingWaitingOrdersListSelect: function(rowmodel, record, index, eOpts) {
        this.displayOrderDetails(record)

        this.clearSelectionInOtherLists('#printingWaitingOrdersList')

    },

    onReadyToReceiveOrdersListSelect: function(rowmodel, record, index, eOpts) {
        this.displayOrderDetails(record)

        this.clearSelectionInOtherLists('#readyToReceiveOrdersList')

    },

    confirmDelivery: function(view, rowIndex, colIndex, item, e, record, row) {
        var deliveredOrdersList = this.getView().down('#deliveredOrdersList')

        var readyToReceiveOrdersListView = view


        var selectedRecords = readyToReceiveOrdersListView.getSelectionModel().getSelection()


        if (selectedRecords.length === 0 || (selectedRecords[0].data.orderId !== record.data.orderId)) {
            // Allow delivery confirmation only for selected items.
            return

        }

        var deliveredOrders = [{
            orderId: record.data.orderId,
            delivered : "TRUE"
        }]


        var deliveredOrdersData = {
            orders : deliveredOrders
        }


        readyToReceiveOrdersListView.getEl().mask(RolandKioskPrint.app.getString('message.unpaid.confirmingDelivery'))

        Ext.Ajax.request({
            scope: this,
            method: 'PUT',
            url: RolandKioskPrint.app.constants.ORDERS_DELIVERY_URL,
            jsonData: deliveredOrdersData,
            success: function(response, opts) {
                readyToReceiveOrdersListView.getEl().unmask()


                var responseData = Ext.decode(response.responseText)

                if (!responseData || !responseData.success) {
                    Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                    RolandKioskPrint.app.getString('message.unpaid.deliveryConfirmationFailed'))

                    return

                }

                readyToReceiveOrdersListView.getStore().remove(record)

                readyToReceiveOrdersListView.refresh()


                var nextSelectedRowIndex = rowIndex

                if ((nextSelectedRowIndex + 1) > readyToReceiveOrdersListView.getStore().getCount()){
                    nextSelectedRowIndex = readyToReceiveOrdersListView.getStore().getCount() - 1

                }

                if (nextSelectedRowIndex >= 0) {
                    readyToReceiveOrdersListView.getSelectionModel().select(nextSelectedRowIndex)

                }

                deliveredOrdersList.getStore().add(record)

                deliveredOrdersList.getView().refresh()

            },
            failure: function() {
                readyToReceiveOrdersListView.getEl().unmask()

                Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                RolandKioskPrint.app.getString('message.unpaid.deliveryConfirmationFailed'))

            }
        })

    },

    onDeliveredOrdersListSelect: function(rowmodel, record, index, eOpts) {
        this.displayOrderDetails(record)

        this.clearSelectionInOtherLists('#deliveredOrdersList')

    },

    onPanelShow: function(component, eOpts) {
        this.setOrderListUpdateInterval()

    },

    onPanelHide: function(component, eOpts) {
        this.clearOrderListUpdateInterval()

    },

    onPanelAfterRender: function(component, eOpts) {
        // Set custom sorters on the various order lists.
        this.addOrdersSorter('#unpaidOrdersList', 'ASC')

        this.addOrdersSorter('#printingWaitingOrdersList', 'ASC')

        this.addOrdersSorter('#readyToReceiveOrdersList', 'ASC')

        this.addOrdersSorter('#deliveredOrdersList', 'DESC')


        this.refreshOrderLists(true, true)

    }

})

