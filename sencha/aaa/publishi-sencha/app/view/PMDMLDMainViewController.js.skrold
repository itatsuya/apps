/*
 * File: app/view/PMDMLDMainViewController.js
 *
 * This file was generated by Sencha Architect version 4.2.4.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 6.6.x Classic library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 6.6.x Classic. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RolandKioskPrint.view.PMDMLDMainViewController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.pmdmldmain',

    listen: {
        controller: {
            productmodeldesignersave: {
                productModelSaved: 'onProductModelSaved'
            },
            modellayoutdesignersave: {
                modelLayoutSaved: 'onModelLayoutSaved'
            }
        }
    },

    getSelectedModelLayoutRecord: function() {
        var modelLayoutList = this.getView().down('#modelLayoutList');

        var selectedRecords = modelLayoutList.getSelectionModel().getSelection();
        if (!selectedRecords.length) {
            return; // undefined
        }

        return selectedRecords[0];
    },

    getSVGDocument: function(svgStr) {
        var svgDoc;

        if (!svgStr || typeof svgStr !== 'string') {
            return false;
        }

        // Parse the svg data, treating as generic xml.
        try {
            var parser = new DOMParser();
            svgDoc = parser.parseFromString(svgStr, "text/xml");
        } catch(e) {
            svgDoc = undefined;
        }

        // Error handling for any parsing errors.
        if (!svgDoc || !svgDoc.documentElement ||
            svgDoc.getElementsByTagName('parsererror').length) {
            return false;
        }

        return svgDoc;
    },

    parseModelLayoutSVG: function(svgStr) {
        var svgDoc = this.getSVGDocument(svgStr);
        if (!svgDoc) {
            return false;
        }

        // Read in the width, height, and viewbox to establish the
        // svg coordinate space.
        var viewBox;

        var svgElem = svgDoc.documentElement;
        if (svgElem.hasAttribute('viewBox')) {
            var viewBoxAttr = svgElem.getAttribute('viewBox');
            viewBox = viewBoxAttr.split(' ').map(function(v) {
                return Number(v);
            });
        } else {
            return false; // viewBox is required
        }

        var svgWidth, svgHeight;
        var widthUnits = 'px';
        var heightUnits = 'px';

        var expr  = /(\d*\.?\d*)(.*)/;

        if (svgElem.hasAttribute('width')) {
            var widthAttr = svgElem.getAttribute('width');
            var widthAttrSplit = widthAttr.match(expr);

            // match(expr) yields ['11.1px', '11.1', 'px'] for '11.1px'
            svgWidth = Number(widthAttrSplit[1]);
            widthUnits = widthAttrSplit[2];
        } else {
            svgWidth = viewBox[2];
        }

        if (svgElem.hasAttribute('height')) {
            var heightAttr = svgElem.getAttribute('height');
            var heightAttrSplit = heightAttr.match(expr);

            svgHeight = Number(heightAttrSplit[1]);
            heightUnits = heightAttrSplit[2];
        } else {
            svgHeight = viewBox[3];
        }

        // Get the rotation angle.
        var rotationAngle = 0,
            printType = RolandKioskPrint.app.constants.PRINT_TYPE_COLOR;
        if (svgElem.hasAttribute('id')) {
            // Illustrator SVG emits the main layer id as root element attribute.
            var idAttr = svgElem.getAttribute('id');
            var idAttrSplit = idAttr.split(':');

            if (idAttrSplit.length > 2) {
                rotationAngle = this.parseRotationAngle(idAttrSplit[2]);
            }
            if (idAttrSplit.length > 3 && idAttrSplit[3] == '3') {
                printType = RolandKioskPrint.app.constants.PRINT_TYPE_CUT;
            }
        } else {
            // Likely CorelDRAW SVG.
            // Get the first group element, and get its id attribute.
            var groupElemList = svgElem.getElementsByTagName('g'); // get all root level groups
            if (groupElemList.length > 0) {
                var groupElem = groupElemList[0];

                if (groupElem.hasAttribute('id')) {
                    var idAttr = groupElem.getAttribute('id');
                    var idAttrSplit = idAttr.split(':');

                    if (idAttrSplit.length > 2) {
                        rotationAngle = this.parseRotationAngle(idAttrSplit[2]);
                    }
                }
            }
        }

        var modelLayoutData = {};

        var layoutWidth = this.convertUnitsValueToMM(svgWidth, widthUnits);
        var layoutHeight = this.convertUnitsValueToMM(svgHeight, heightUnits);

        // Set the layout width, height and rotation.
        modelLayoutData.layoutWidth = layoutWidth;
        modelLayoutData.layoutHeight = layoutHeight;
        modelLayoutData.rotationAngle = rotationAngle;
        modelLayoutData.printType = printType;

        // Read in the slot rects.
        var slots = [];
        var elemList = [];

        var supportedShapes = ['rect', 'circle', 'polygon', 'ellipse', 'path'];
        var hasUnsupportedShapes = false;

        var elems = svgDoc.getElementsByTagName('*'); // Get all elements
        for (var i = 0, length = elems.length; i < length; i++) {
            var elemName = elems[i].nodeName;
            if (elemName == 'line'  || elemName == 'polyline') {
                hasUnsupportedShapes = true;
            } else if (supportedShapes.indexOf(elemName) !== -1) {
                elemList.push(elems[i]);
            }
        }

        var EPSILON = 1e-3;

        var scaleX = this.convertUnitsValueToMM(svgWidth / viewBox[2], widthUnits),
            scaleY = this.convertUnitsValueToMM(svgHeight / viewBox[3], heightUnits);

        for (var i = 0, length = elemList.length; i < length; i++) {
            var elem = elemList[i];

            // Check if its a slot.
            if (!elem.hasAttribute('id')) {
                continue;
            }

            // Slot rect has an id of type ':n' where n is the slot order.
            var idAttr = elem.getAttribute('id');
            if (idAttr[0] != ':') {
                return false;
            }

            var idAttrSplit = idAttr.split(':');
            var slotNum = Number(idAttrSplit[1]);
            if (isNaN(slotNum)) {
                return false;
            }

            var slot = this.parseSVGShape(elem, scaleX, scaleY);

            if (slot.type == 'path' && slot.hasOpenSubpaths) {
                // If path is open, we skip over it.
                hasUnsupportedShapes = true;
                continue;
            }

            // Check that the slot is contained within the model layout bounds.
            if (slot.left < -EPSILON ||
                slot.top < -EPSILON ||
                slot.right > layoutWidth + EPSILON ||
                slot.bottom > layoutHeight + EPSILON) {
                return false; // failed
            }

            slot.order = slotNum;

            slots.push(slot);
        }

        slots.sort(function(a, b) {
            return a.order - b.order;
        });

        slots.forEach(function(slot) {
            delete slot.order;
        });

        modelLayoutData.slots = slots;

        // Before we return, check if the SVG has unsupported shapes which we
        // ignored. If yes, show a warning message to the user.

        if (hasUnsupportedShapes) {
            Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.warning'),
                          RolandKioskPrint.app.getString('message.pmd_mld.mlUnsupportedShapes'));
        }

        return modelLayoutData;
    },

    parseSVGShape: function(elem, scaleX, scaleY) {
        var shape = {},
            type = elem.nodeName,
            left, top, width, height;

        if (type == 'rect') {
            left = Number(elem.getAttribute('x'));
            top = Number(elem.getAttribute('y'));
            width = Number(elem.getAttribute('width'));
            height = Number(elem.getAttribute('height'));
            var transform = elem.getAttribute('transform');

            if (transform) {
                var matrix = fabric.parseTransformAttribute(transform);
                var points = [
                    {x: left, y: top},
                    {x: left + width, y: top},
                    {x: left + width, y: top + height},
                    {x: left, y: top + height},
                ];

                points.forEach(function(point) {
                    var x = matrix[0] * point.x + matrix[2] * point.y + matrix[4],
                        y = matrix[1] * point.x + matrix[3] * point.y + matrix[5];
                    point.x = x;
                    point.y = y;
                });

                var pathData = this.createPathFromPoints(points, scaleX, scaleY);

                shape.path = pathData.path;

                left = pathData.left;
                top = pathData.top;
                width = pathData.right - left;
                height = pathData.bottom - top;

                type = 'path';
            }
        } else if (type == 'circle') {
            var cx = Number(elem.getAttribute('cx')),
                cy = Number(elem.getAttribute('cy')),
                r = Number(elem.getAttribute('r'));

            shape.cx = cx * scaleX;
            shape.cy = cy * scaleY;
            shape.r = r * scaleX;

            left = cx - r;
            top = cy - r;
            width = 2 * r;
            height = 2 * r;
        } else if (type == 'ellipse') {
            var cx = Number(elem.getAttribute('cx')),
                cy = Number(elem.getAttribute('cy')),
                rx = Number(elem.getAttribute('rx')),
                ry = Number(elem.getAttribute('ry'));

            shape.cx = cx * scaleX;
            shape.cy = cy * scaleY;
            shape.rx = rx * scaleX;
            shape.ry = ry * scaleY;

            left = cx - rx;
            top = cy - ry;
            width = 2 * rx;
            height = 2 * ry;
        } else if (type == 'polygon') {
            var points = fabric.parsePointsAttribute(elem.getAttribute('points')),
                pathData = this.createPathFromPoints(points, scaleX, scaleY);

            shape.path = pathData.path;

            left = pathData.left;
            top = pathData.top;
            width = pathData.right - left;
            height = pathData.bottom - top;

            type = 'path';
        } else if (type == 'path') {
            var path = elem.getAttribute('d').match(/[mzlhvcsqta][^mzlhvcsqta]*/gi),
                dim;

            path = fabric.util.parsePath(path);
            dim = fabric.util.parseDimensions(path);

            var subpathClosed = true,
                hasOpenSubpaths = false;

            for (var i = 0, numCommand = path.length; i < numCommand; i++) {
                var currentPath = path[i];

                // Check if any of the subpaths is open.
                if (!hasOpenSubpaths) {
                    if (currentPath[0] == 'm' || currentPath[0] == 'M') {
                        // Starts a sub path.
                        if (!subpathClosed) {
                            // Previous sub path is not closed.
                            hasOpenSubpaths = true;
                        }
                        subpathClosed = false;
                    } else if (currentPath[0] == 'z' || currentPath[0] == 'Z') {
                        // Closes a sub path.
                        subpathClosed = true;
                    }
                }

                if (currentPath[0] != 'v' && currentPath[0] != 'V') {
                    for (var j = 1, length = currentPath.length; j < length; j++){
                        currentPath[j] *= (j % 2 === 0) ? scaleY : scaleX;
                    }
                } else {
                    currentPath[1] *= scaleY;
                }
            }

            if (!subpathClosed) {
                hasOpenSubpaths = true;
            }

            shape.path = path;
            shape.hasOpenSubpaths = hasOpenSubpaths;

            left = dim.left;
            top = dim.top;
            width = dim.width;
            height = dim.height;
        }

        shape.left = left * scaleX;
        shape.top = top * scaleY;
        shape.right = shape.left + width * scaleX;
        shape.bottom = shape.top + height * scaleY;
        shape.type = type;

        return shape;
    },

    createPathFromPoints: function(points, scaleX, scaleY) {
        var min = fabric.util.array.min,
            max = fabric.util.array.max;

        var path = [],
            aX = [],
            aY = [];

        for (var i = 0, length = points.length; i < length; i++) {
            var px = points[i].x,
                py = points[i].y;

            if (i === 0) {
                path.push(['M', px * scaleX, py * scaleY]);
            } else {
                path.push(['L', px * scaleX, py * scaleY]);
            }

            aX.push(px);
            aY.push(py);
        }
        path.push(['Z']); // close the path

        return {
            path: path,
            left:  min(aX) || 0,
            top:  min(aY) || 0,
            right:  max(aX) || 0,
            bottom:  max(aY) || 0
        };
    },

    parseRotationAngle: function(s) {
        var rotationAngle = Number(s);
        if (isNaN(rotationAngle)) {
            rotationAngle = 0;
        } else {
            rotationAngle = rotationAngle % 360;
            if (rotationAngle < 0) {
                rotationAngle += 360;
            }
            if ((rotationAngle % 90) !== 0) {
                rotationAngle = 0; // Only orthogonal rotations
            }
        }

        return rotationAngle;
    },

    parseProductModelSVG: function(svgStr) {
        var svgDoc = this.getSVGDocument(svgStr);
        if (!svgDoc) {
            return false;
        }

        // Read in the width, height, and viewbox to establish the
        // svg coordinate space.
        var viewBox;

        var svgElem = svgDoc.documentElement;
        if (svgElem.hasAttribute('viewBox')) {
            var viewBoxAttr = svgElem.getAttribute('viewBox');
            viewBox = viewBoxAttr.split(' ').map(function(v) {
                return Number(v);
            });
        } else {
            return false; // viewBox is required
        }

        var svgWidth, svgHeight;
        var widthUnits = 'px';
        var heightUnits = 'px';

        var expr  = /(\d*\.?\d*)(.*)/;

        if (svgElem.hasAttribute('width')) {
            var widthAttr = svgElem.getAttribute('width');
            var widthAttrSplit = widthAttr.match(expr);

            // match(expr) yields ['11.1px', '11.1', 'px'] for '11.1px'
            svgWidth = Number(widthAttrSplit[1]);
            widthUnits = widthAttrSplit[2];
        } else {
            svgWidth = viewBox[2];
        }

        if (svgElem.hasAttribute('height')) {
            var heightAttr = svgElem.getAttribute('height');
            var heightAttrSplit = heightAttr.match(expr);

            svgHeight = Number(heightAttrSplit[1]);
            heightUnits = heightAttrSplit[2];
        } else {
            svgHeight = viewBox[3];
        }

        // Get the root special color settings.
        var specialColor = '000000';
        if (svgElem.hasAttribute('id')) {
            // Illustrator SVG emits the main layer id as root element attribute.
            var idAttr = svgElem.getAttribute('id');
            var idAttrSplit = idAttr.split(':');

            if (idAttrSplit.length > 2) {
                specialColor = idAttrSplit[2];
                specialColor = this.padString('000000', specialColor, false);
            }
        } else {
            // Likely CorelDRAW SVG.
            // Get the first group element, and get its id attribute.
            var groupElemList = svgElem.getElementsByTagName('g'); // get all root level groups
            if (groupElemList.length > 0) {
                var groupElem = groupElemList[0];

                if (groupElem.hasAttribute('id')) {
                    var idAttr = groupElem.getAttribute('id');
                    var idAttrSplit = idAttr.split(':');

                    if (idAttrSplit.length > 2) {
                        specialColor = idAttrSplit[2];
                        specialColor = this.padString('000000', specialColor, false);
                    }
                }
            }
        }

        var productModelData = {};

        // Set the layout width and height.
        productModelData.productWidth = this.convertUnitsValueToMM(svgWidth, widthUnits);
        productModelData.productHeight = this.convertUnitsValueToMM(svgHeight, heightUnits);
        productModelData.leftMargin = 0;
        productModelData.rightMargin = 0;
        productModelData.topMargin = 0;
        productModelData.bottomMargin = 0;
        productModelData.cornerRadius = 0;

        // id is of the form :1:abcdef
        // a,b,c,d,e,f can be 0,1
        // a - primer
        // b - white
        // c - varnish
        // d - varnish type (0 - gloss, 1 - matte)
        // e - back print
        // f - print type (1 - foil print, 2 - metal print)

        // For now foil and color are mutually exclusive.
        // Giving precedence to foil.
        productModelData.printType = RolandKioskPrint.app.constants.PRINT_TYPE_COLOR;
        if (specialColor[5] == '1') {
            productModelData.printType = RolandKioskPrint.app.constants.PRINT_TYPE_FOIL;
            specialColor = '000001';
        } else if (specialColor[5] == '2') {
            productModelData.printType = RolandKioskPrint.app.constants.PRINT_TYPE_METAL;
            specialColor = '000002';
        } else if (specialColor[5] == '3') {
            productModelData.printType = RolandKioskPrint.app.constants.PRINT_TYPE_CUT;
            specialColor = '000003';
        }

        productModelData.defaultSpecialColor = specialColor.substring(0, 3);
        productModelData.primer = (specialColor[0] == '1') ? 'on' : 'off';
        productModelData.white = (specialColor[1] == '1') ? 'on' : 'off';
        productModelData.varnish = (specialColor[2] == '1') ? 'on' : 'off';
        productModelData.varnishType = (specialColor[3] == '0') ? RolandKioskPrint.app.constants.GLOSS_VARNISH
                                                                : RolandKioskPrint.app.constants.MATTE_VARNISH;
        productModelData.backPrint = (specialColor[4] == '1') ? 'on' : 'off';

        return productModelData;
    },

    convertUnitsValueToMM: function(value, units) {
        switch (units) {
            case 'px':
            case 'pt':
            case '':
                return value / 72.0 * 25.4;

            case 'cm':
                return value * 10;

            case 'mm':
                return value;

            case 'in':
                return value * 25.4;
        }

        return value;
    },

    getFileBaseName: function(str) {
        var index = str.lastIndexOf('.');
        if (index != -1) {
            return str.substring(0, index);
        }

        return str;
    },

    getSelectedProductModelRecord: function() {
        var productModeList = this.getView().down('#productModelList');

        var selectedRecords = productModeList.getSelectionModel().getSelection();
        if (!selectedRecords.length) {
            return; // undefined
        }

        return selectedRecords[0];
    },

    refreshModelLayoutList: function() {
        var modelLayoutList = this.getView().down('#modelLayoutList');
        var modelLayoutListView = modelLayoutList.getView();
        var features = RolandKioskPrint.AppData.getFeatures();

        modelLayoutListView.getEl().mask(RolandKioskPrint.app.getString('message.generic.loading'));
        // var now = new Date();

        var deferred = new Ext.Deferred();
        Ext.Ajax.request({
            scope: this,
            url: RolandKioskPrint.app.constants.MODEL_LAYOUT_URL,
            timeout: RolandKioskPrint.app.constants.SERVER_REQUEST_TIMEOUT,
            success: function(response, opts) {
                modelLayoutListView.getEl().unmask();
                // console.log('Time taken to load layout list = ' + (new Date() - now));

                var layoutData = Ext.decode(response.responseText);
                if (!layoutData) {
                    deferred.reject();
                    return;
                }

                var modelLayouts = layoutData.modelLayouts;
                if (!features.allowFoilPrint || !features.allowMetalPrint) {
                    modelLayouts = modelLayouts.filter(function(modelLayout) {
                        var allowed = true;
                        if (!features.allowFoilPrint && RolandKioskPrint.app.isFoilPrintLayout(modelLayout)) {
                            allowed = false;
                        } else if (!features.allowMetalPrint && RolandKioskPrint.app.isMetalPrintLayout(modelLayout)) {
                            allowed = false;
                        }
                        return allowed;
                    });
                }

                modelLayoutList.getStore().setData(modelLayouts);
                deferred.resolve();
            },
            failure: function() {
                modelLayoutListView.getEl().unmask();
                modelLayoutList.getStore().removeAll();
                deferred.reject();
            }
        });

        return deferred.promise;
    },

    refreshProductModelList: function() {
        var productModelList = this.getView().down('#productModelList');
        var productModelListView = productModelList.getView();
        var features = RolandKioskPrint.AppData.getFeatures();

        productModelListView.getEl().mask(RolandKioskPrint.app.getString('message.generic.loading'));
        // var now = new Date();

        var deferred = new Ext.Deferred();
        Ext.Ajax.request({
            scope: this,
            url: RolandKioskPrint.app.constants.PRODUCT_MODEL_URL,
            timeout: RolandKioskPrint.app.constants.SERVER_REQUEST_TIMEOUT,
            success: function(response, opts) {
                productModelListView.getEl().unmask();
                // console.log('Time taken to load template list = ' + (new Date() - now));

                var modelData = Ext.decode(response.responseText);
                if (!modelData) {
                    deferred.reject();
                    return;
                }

                var productModels = modelData.productModels;
                if (!features.allowFoilPrint || !features.allowMetalPrint) {
                    productModels = productModels.filter(function(productModel) {
                        var allowed = true;
                        if (!features.allowFoilPrint && RolandKioskPrint.app.isFoilPrintModel(productModel)) {
                            allowed = false;
                        }
                        if (allowed && !features.allowMetalPrint && RolandKioskPrint.app.isMetalPrintModel(productModel)) {
                            allowed = false;
                        }
                        return allowed;
                    });
                }

                productModelList.getStore().setData(productModels);
                deferred.resolve();
            },
            failure: function() {
                productModelListView.getEl().unmask();
                productModelList.getStore().removeAll();
                deferred.reject();
            }
        });

        return deferred.promise;
    },

    refreshLists: function() {
        // Clear the active product model and model layout.
        RolandKioskPrint.AppData.productModelData = null;
        RolandKioskPrint.AppData.modelLayoutData = null;

        var promises = [];

        // Refresh the model layouts list.
        if (this.shouldRefreshModelLayouts) {
            promises.push(this.refreshModelLayoutList());
        }

        // Refresh the product models list.
        if (this.shouldRefreshProductModels) {
            promises.push(this.refreshProductModelList());
        }

        if (promises.length === 0) {
            return; // Nothing to refresh
        }

        var me = this; // Ext.Promise.then gets window scope by default

        Ext.Promise.all(promises).then(function() {
            // Select the appropriate model layout.
            if (me.shouldRefreshModelLayouts) {
                var modelLayoutList = me.getView().down('#modelLayoutList');
                var modelLayoutListView = modelLayoutList.getView();

                var layoutIndex = 0;
                if (me.selectModelLayoutName) {
                    layoutIndex = modelLayoutList.getStore().findExact('layoutName', me.selectModelLayoutName);
                    if (layoutIndex == -1) {
                        layoutIndex = 0; // Select the first one
                    }
                }

                if (modelLayoutList.getStore().getCount() !== 0) {
                    modelLayoutListView.select(layoutIndex);
                    modelLayoutList.ensureVisible(layoutIndex);
                }

                me.shouldRefreshModelLayouts = false;

                if (!me.shouldRefreshProductModels) {
                    // If product models are not being refreshed, update the connections right here.
                    me.updateConnections();
                }
            }

            // Select the appropriate product model.
            if (me.shouldRefreshProductModels) {
                var productModelList = me.getView().down('#productModelList');
                var productModelListView = productModelList.getView();

                productModelList.getSelectionModel().deselectAll(true);

                var modelIndex = 0;
                if (me.selectProductModelName) {
                    modelIndex = productModelList.getStore().findExact('modelName', me.selectProductModelName);
                    if (modelIndex == -1) {
                        modelIndex = 0; // Select the first one
                    }
                }

                if (productModelList.getStore().getCount() !== 0) {
                    productModelListView.select(modelIndex);
                    productModelList.ensureVisible(modelIndex);
                }

                me.shouldRefreshProductModels = false;
            }
        });
    },

    init: function() {
        // Tracks whether we need to refresh the list of model layouts and product
        // models when the view is shown.
        this.shouldRefreshModelLayouts = true;
        this.selectModelLayoutName = null;

        this.shouldRefreshProductModels = true;
        this.selectProductModelName = null;

        this.setConnectionsDirty(false);
    },

    onProductModelSaved: function(modelName) {
        // Mark that we need to refresh the list of product models.
        this.shouldRefreshProductModels = true;
        this.selectProductModelName = modelName;
    },

    onModelLayoutSaved: function(layoutData) {
        // Mark that we need to refresh the list of model layouts.
        this.shouldRefreshModelLayouts = true;
        this.selectModelLayoutName = layoutData.layoutName;
        if (layoutData.updateMapping){
            this.removeModelLayoutFromMappings(layoutData.layoutName);
        }
    },

    deleteModelLayout: function(modelLayoutRecord) {
        // Send delete request to server.
        var mainView = this.getView();
        mainView.getEl().mask(RolandKioskPrint.app.getString('message.pmd_mld.deletingML'));

        var deleteData = {
            layoutName: modelLayoutRecord.data.layoutName
        };

        var modelLayoutList = this.getView().down('#modelLayoutList');

        Ext.Ajax.request({
            scope: this,
            method: 'DELETE',
            url: RolandKioskPrint.app.constants.MODEL_LAYOUT_URL,
            jsonData: deleteData,
            success: function(response, opts) {
                mainView.getEl().unmask();

                var responseData = Ext.decode(response.responseText);
                if (!responseData || !responseData.success) {
                    Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                                  RolandKioskPrint.app.getString('message.pmd_mld.mlDeletionFailed'));
                    return;
                }

                // Remove from store.
                modelLayoutList.getStore().remove(modelLayoutRecord);

                if (modelLayoutList.getStore().getCount() !== 0) {
                    modelLayoutList.getView().select(0);
                }

                // Remove from product model mappings.
                this.removeModelLayoutFromMappings(deleteData.layoutName);
            },
            failure: function() {
                mainView.getEl().unmask();
                Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                              RolandKioskPrint.app.getString('message.pmd_mld.mlDeletionFailed'));
            }
        });
    },

    deleteProductModel: function(productModelRecord) {
        // Send delete request to server.
        var mainView = this.getView();
        mainView.getEl().mask(RolandKioskPrint.app.getString('message.pmd_mld.deletingPM'));

        var deleteData = {
            modelName: productModelRecord.data.modelName
        };

        var productModelList = this.getView().down('#productModelList');

        Ext.Ajax.request({
            scope: this,
            method: 'DELETE',
            url: RolandKioskPrint.app.constants.PRODUCT_MODEL_URL,
            jsonData: deleteData,
            success: function(response, opts) {
                mainView.getEl().unmask();

                var responseData = Ext.decode(response.responseText);
                if (!responseData || !responseData.success) {
                    Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                                  RolandKioskPrint.app.getString('message.pmd_mld.pmDeletionFailed'));
                    return;
                }

                // Remove from store.
                // This also triggers a deselect event for the removed record. To avoid
                // any user confirmation to save changes, we mark the connections as clean.
                this.setConnectionsDirty(false);
                productModelList.getStore().remove(productModelRecord);

                if (productModelList.getStore().getCount() !== 0) {
                    productModelList.getView().select(0);
                }
            },
            failure: function() {
                mainView.getEl().unmask();
                Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                              RolandKioskPrint.app.getString('message.pmd_mld.pmDeletionFailed'));
            }
        });
    },

    forceFontsDownload: function() {
        // The need to force download fonts.
        // In order to show fabric text objects with the correct applied font, the font files are
        // required to be available before we get into the designer and load those text objects.
        // While some browsers, like IE, download the font files on encountering the @font-face
        // declarations in stylesheet and do not have this problem, others like Chrome and Safari
        // do not request the font file unless it is used in the html document.
        // Here we generate markup which is styled with these fonts, which in turn causes the browser
        // to request downloading of the font files.

        // First, get the list of fonts to force download.
        var fontsStore = Ext.StoreManager.lookup('Fonts');

        fontsStore.load({
            scope: this,
            callback: function(records, operation, success) {
                // Create dummy div elements styled with these fonts. This in turn forces
                // the browser to download these fonts.
                var parentElement = this.getView().getEl().dom;

                var html = '<div style="font-family:\'{familyName}\'; font-weight: normal; font-style: normal; height:0px;">&nbsp;</div>' +
                    '<div style="font-family:\'{familyName}\'; font-weight: normal; font-style: italic; height:0px;">&nbsp;</div>' +
                    '<div style="font-family:\'{familyName}\'; font-weight: bold; font-style: normal; height:0px;">&nbsp;</div>' +
                    '<div style="font-family:\'{familyName}\'; font-weight: bold; font-style: italic; height:0px;">&nbsp;</div>';
                var tpl = Ext.DomHelper.createTemplate(html);
                tpl.compile();

                fontsStore.each(function(record) {
                    tpl.append(parentElement, {
                        familyName: record.data.familyName
                    });
                });

                // Add the fallback notdef font.
                tpl.append(parentElement, {
                    familyName: 'Notdef'
                });
            }
        });
    },

    removeModelLayoutFromMappings: function(layoutName) {
        var productModelList = this.getView().down('#productModelList');
        var store = productModelList.getStore();

        store.each(function(record, idx) {
            var connectedLayouts = record.get('connectedLayouts');
            if (!connectedLayouts || connectedLayouts.length === 0) {
                return;
            }

            // Remove layout name if mapped to.
            var index = connectedLayouts.indexOf(layoutName);
            if (index == -1) {
                return; // Not mapped
            }

            var newConnections = [];
            for (var i = 0, length = connectedLayouts.length; i < length; i++) {
                if (i != index) {
                    newConnections.push(connectedLayouts[i]);
                }
            }

            record.set('connectedLayouts', newConnections);
        });
    },

    editModelLayout: function(modelLayoutRecord) {
        // Get model layout data from server.
        var mainView = this.getView();
        mainView.getEl().mask(RolandKioskPrint.app.getString('message.pmd_mld.openingML'));

        var modelLayout = modelLayoutRecord.data;

        Ext.Ajax.request({
            scope: this,
            url: modelLayout.layoutTemplatePath,
            success: function(response, opts) {
                mainView.getEl().unmask();

                var modelLayoutData = Ext.decode(response.responseText);
                if (!modelLayoutData) {
                    Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                                  RolandKioskPrint.app.getString('message.pmd_mld.mlOpeningFailed'));
                    return;
                }

                // Set model layout designer mode to 'EDIT' and redirect.
                RolandKioskPrint.AppData.modelLayoutDesignerMode =
                    RolandKioskPrint.app.constants.MODEL_LAYOUT_EDIT;

                modelLayoutData.layoutName = modelLayout.layoutName;
                modelLayoutData.printType = modelLayout.printType;

                RolandKioskPrint.AppData.modelLayoutData =
                    new RolandKioskPrint.app.ModelLayout(modelLayoutData);

                this.redirectTo('#print-layout/edit', true);
            },
            failure: function() {
                mainView.getEl().unmask();
                Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                              RolandKioskPrint.app.getString('message.pmd_mld.mlOpeningFailed'));
            }
        });
    },

    editProductModel: function(productModelRecord) {
        // Get product model data from server.
        var mainView = this.getView();
        mainView.getEl().mask(RolandKioskPrint.app.getString('message.pmd_mld.openingPM'));

        var productModel = productModelRecord.data;

        Ext.Ajax.request({
            scope: this,
            url: productModel.modelTemplatePath,
            success: function(response, opts) {
                mainView.getEl().unmask();

                var productModelData = Ext.decode(response.responseText);
                if (!productModelData) {
                    Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                                  RolandKioskPrint.app.getString('message.pmd_mld.pmOpeningFailed'));
                    return;
                }

                // Set product model designer mode to 'EDIT' and redirect.
                RolandKioskPrint.AppData.productModelDesignerMode =
                    RolandKioskPrint.app.constants.PRODUCT_MODEL_EDIT;

                productModelData.modelName = productModel.modelName;
                productModelData.printType = productModel.printType;
                productModelData.modelDesignPath = productModel.modelDesignPath;
                productModelData.modelThumbPath = productModel.modelThumbPath;

                if (productModelData.customSize === undefined) {
                    productModelData.customSize = false;
                }

                // OTHER foil color changed to COPPER.
                if (RolandKioskPrint.app.isFoilPrintModel(productModelData) &&
                    productModelData.foilColorName == "OTHER" &&
                    Number(productModelData.version) < 2.7) {
                    productModelData.foilColorName = "COPPER";
                }

                RolandKioskPrint.AppData.productModelData =
                    new RolandKioskPrint.app.ProductModel(productModelData);

                // For templates created from SVG, head to content editing directly.
                // For foil, metal and cut print, we allow the material and other settings to be edited first.
                if (productModelData.source != 'SVG' ||
                    (RolandKioskPrint.app.isFoilPrintModel(productModelData) ||
                     RolandKioskPrint.app.isMetalPrintModel(productModelData) ||
                     RolandKioskPrint.app.isCutPrintModel(productModelData))) {
                    this.redirectTo('#template/edit', true);
                } else {
                    this.redirectTo('#template/content', true);
                }
            },
            failure: function() {
                mainView.getEl().unmask();
                Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                              RolandKioskPrint.app.getString('message.pmd_mld.pmOpeningFailed'));
            }
        });
    },

    setConnectionsDirty: function(dirty) {
        // Storing off the view model. Helps manage Save button disabled state.
        this.getViewModel().set('connectionsDirty', dirty);
    },

    areConnectionsDirty: function() {
        return this.getViewModel().get('connectionsDirty');
    },

    checkSaveConnections: function(productModelRecord) {
        var deferred = new Ext.Deferred();

        if (!productModelRecord) {
            productModelRecord = this.getSelectedProductModelRecord();
        }

        if (productModelRecord && this.areConnectionsDirty()) {
            // Unsaved connections.
            // Confirm with user if he wishes to save the connections.
            var connectedLayoutRecords = this.getConnectedModelLayoutRecords();
            var connectedLayouts = this.getConnections();
            Ext.Msg.confirm(RolandKioskPrint.app.getString('message.generic.confirmation'),
                RolandKioskPrint.app.getString('message.pmd_mld.saveConnections'),
                function(btnText) {
                    if (btnText == 'yes') {
                        if (!this.areConnectionsValid(productModelRecord, connectedLayoutRecords)) {
                            if (productModelRecord.data.printType == RolandKioskPrint.app.constants.PRINT_TYPE_FOIL) {
                                Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                                              RolandKioskPrint.app.getString('message.pmd_mld.invalidConnectionsFoilToNonFoil'));
                            } else if (productModelRecord.data.printType == RolandKioskPrint.app.constants.PRINT_TYPE_METAL) {
                                Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                                              RolandKioskPrint.app.getString('message.pmd_mld.invalidConnectionsMetalToNonMetal'));
                            } else if (productModelRecord.data.printType == RolandKioskPrint.app.constants.PRINT_TYPE_CUT) {
                                Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                                              RolandKioskPrint.app.getString('message.pmd_mld.invalidConnectionsCutToNonCut'));
                            } else {
                                Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                                              RolandKioskPrint.app.getString('message.pmd_mld.invalidConnectionsColorToNonColor'));
                            }
                            deferred.reject();
                            return;
                        }

                        var promise = this.saveConnections(productModelRecord, connectedLayouts, true);
                        promise.then(function() {
                            deferred.resolve();
                        },
                        function() {
                            deferred.reject();
                        });
                    } else {
                        this.updateConnections();
                        deferred.resolve();
                    }
                },
                this
            );
        } else {
            // Nothing to save.
            deferred.resolve();
        }

        return deferred.promise;
    },

    areConnectionsValid: function(selectedProductModel, connectedLayouts) {
        if (!selectedProductModel) {
            selectedProductModel = this.getSelectedProductModelRecord();
        }

        if (!connectedLayouts) {
            connectedLayouts = this.getConnectedModelLayoutRecords();
        }

        var valid = true;
        var printType = selectedProductModel.data.printType;

        if (Array.isArray(printType)) {
            // Validate the connected layouts are of the correct print types.
            for (i = 0; i < connectedLayouts.length; i++) {
                if (printType.indexOf(connectedLayouts[i].data.printType) == -1) {
                    valid = false;
                    break;
                }
            }
        } else {
            // All connected layouts must be the same type as the product model.
            for (i = 0; i < connectedLayouts.length; i++) {
                if (printType != connectedLayouts[i].data.printType) {
                    valid = false;
                    break;
                }
            }
        }

        return valid;
    },

    getConnectedModelLayoutRecords: function() {
        var connectedLayouts = [];

        var view = this.getView().down('#modelLayoutList');
        var store = view.getStore();

        store.each(function(record, idx) {
            if (!record.get('isConnected')) {
                return;
            }
            connectedLayouts.push(record);
        });

        return connectedLayouts;
    },

    saveConnections: function(productModelRecord, connections, skipSuccessAlert) {
        var connectedLayoutsData = {
            modelName: productModelRecord.data.modelName,
            connectedLayouts: connections
        };

        var mainView = this.getView();
        mainView.getEl().mask(RolandKioskPrint.app.getString('message.pmd_mld.savingMLConnection'));

        var deferred = new Ext.Deferred();

        // Send request to server.
        Ext.Ajax.request({
            scope: this,
            method: 'POST',
            url: RolandKioskPrint.app.constants.MODEL_LAYOUT_MAPPING,
            jsonData: connectedLayoutsData,
            success: function(response, opts) {
                mainView.getEl().unmask();

                var responseData = Ext.decode(response.responseText);
                if (!responseData || !responseData.success) {
                    Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                                  RolandKioskPrint.app.getString('message.pmd_mld.mlConnectionSaveFailed'));
                    deferred.reject();
                    return;
                }

                productModelRecord.set('connectedLayouts', connections);
                if (!skipSuccessAlert) {
                    Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.success'),
                                  RolandKioskPrint.app.getString('message.pmd_mld.mlConnectionSaved'));
                }
                this.setConnectionsDirty(false);
                deferred.resolve();
            },
            failure: function() {
                mainView.getEl().unmask();
                Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                              RolandKioskPrint.app.getString('message.pmd_mld.mlConnectionSaveFailed'));
                deferred.reject();
            }
        });

        return deferred.promise;
    },

    updateConnections: function() {
        // Selected product model changed, update the list of model layouts.
        var productModelList = this.getView().down('#productModelList');
        var selectedRecords = productModelList.getSelectionModel().getSelection();

        var connectedLayouts = [];
        if (selectedRecords.length !== 0) {
            connectedLayouts = selectedRecords[0].data.connectedLayouts || [];
        }

        var modelLayoutList = this.getView().down('#modelLayoutList');
        var store = modelLayoutList.getStore();
        var defaultIndex = -1;
        modelLayoutList.getSelectionModel().deselectAll();

        store.each(function(record, idx) {
            var layoutName = record.get('layoutName');
            var index = connectedLayouts.indexOf(layoutName);

            var prevDefault = record.get('isDefault'),
                newDefault = false,
                newConnected = false;

            if (index != -1) {
                newConnected = true;
                newDefault = (index === 0);

                if (newDefault) {
                    defaultIndex = idx;
                }
            }

            record.set('isConnected', newConnected);
            record.set('isDefault', newDefault);

            // Update the radio button. The renderer runs only when the node is created.
            // We need to update without re-creating the node here.
            if (newDefault != prevDefault) {
                var node = modelLayoutList.getView().getNodeByRecord(record);
                if (node) {
                    // Node is in buffer.
                    var input = node.querySelector('input.x-grid-radiocolumn');
                    if (input) {
                        input.checked = newDefault;
                    }
                }
            }
        });

        if (defaultIndex != -1) {
            modelLayoutList.getView().select(defaultIndex);
            modelLayoutList.ensureVisible(defaultIndex);
        }

        // Mark connections as clean.
        this.setConnectionsDirty(false);
    },

    getConnections: function() {
        // Create the list of connected model layouts.
        var connectedLayouts = [];

        var modelLayoutList = this.getView().down('#modelLayoutList');
        var store = modelLayoutList.getStore();

        store.each(function(record, idx) {
            if (!record.get('isConnected')) {
                return;
            }

            var layoutName = record.get('layoutName');
            if (record.get('isDefault')) {
                // Default. Add to start of list.
                connectedLayouts.unshift(layoutName);
            } else {
                connectedLayouts.push(layoutName);
            }
        });

        return connectedLayouts;
    },

    importModelLayout: function(file) {
        var reader = new FileReader();
        reader.onload = (function(theFile, me) { // Closure so that theFile can be used in callback
            return function(e) {
                // Parse the SVG file contents.
                var svgStr = e.target.result;
                var modelLayoutData = me.parseModelLayoutSVG(svgStr);

                if (!modelLayoutData) {
                    Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                                  RolandKioskPrint.app.getString('message.pmd_mld.incorrectMLFile'));
                    return;
                }

                // Set model layout designer mode to 'IMPORT' and redirect.
                RolandKioskPrint.AppData.modelLayoutDesignerMode =
                    RolandKioskPrint.app.constants.MODEL_LAYOUT_IMPORT;

                modelLayoutData.layoutName = me.getFileBaseName(theFile.name);
                RolandKioskPrint.AppData.modelLayoutData =
                    new RolandKioskPrint.app.ModelLayout(modelLayoutData);

                me.redirectTo('#print-layout/import', true);
            };
        })(file, this);

        reader.onerror = function(e) {
            Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                          RolandKioskPrint.app.getString('message.pmd_mld.mlReadFailed'));
        };

        reader.readAsText(file); // UTF-8 by default
    },

    importProductModel: function(file, isSVG) {
        var svgFilePath = '';

        var mainView = this.getView();
        mainView.getEl().mask(RolandKioskPrint.app.getString('message.pmd_mld.importingPM'));

        var deferred = new Ext.Deferred();
        if (isSVG) {
            // If an SVG file is selected, read in the file contents.
            var reader = new FileReader();
            reader.onload = (function(theFile, me) { // Closure so that theFile can be used in callback
                return function(e) {
                    deferred.resolve(e.target.result);
                };
            })(file, this);

            reader.onerror = function(e) {
                deferred.reject(RolandKioskPrint.app.getString('message.pmd_mld.pmReadFailed'));
            };

            reader.readAsText(file); // UTF-8 by default
        } else {
            var formData = new FormData();
            formData.append('file', file);

            Ext.Ajax.request({
                scope: this,
                method: 'POST',
                url: RolandKioskPrint.app.constants.IMPORT_PRODUCT_MODEL_URL,
                rawData: formData,
                headers: {
                    'Content-Type': null // To use content type of FormData
                },
                success: function(response, opts) {
                    var responseData = Ext.decode(response.responseText);
                    if (!responseData || !responseData.success) {
                        deferred.reject(RolandKioskPrint.app.getString('message.pmd_mld.pmImportFailed'));
                        return;
                    }

                    svgFilePath = responseData.svgFilePath;

                    // Request for the SVG file.
                    Ext.Ajax.request({
                        scope: this,
                        url: svgFilePath,
                        success: function(response, opts) {
                            deferred.resolve(response.responseText);
                        },
                        failure: function() {
                            deferred.reject(RolandKioskPrint.app.getString('message.pmd_mld.pmImportFailed'));
                        }
                    });
                },
                failure: function() {
                    deferred.reject(RolandKioskPrint.app.getString('message.pmd_mld.pmImportFailed'));
                }
            });
        }

        var me = this; // Ext.Promise.then gets window scope by default

        deferred.promise.then(
            function(svgStr) {
                // Fulfilled.
                // Parse the SVG contents.
                var productModelData = me.parseProductModelSVG(svgStr);

                if (!productModelData) {
                    Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                                  RolandKioskPrint.app.getString('message.pmd_mld.incorrectPMFile'));
                    return;
                }

                // Set product model designer mode to 'IMPORT' and redirect.
                RolandKioskPrint.AppData.productModelDesignerMode =
                    RolandKioskPrint.app.constants.PRODUCT_MODEL_IMPORT;

                productModelData.source = 'SVG';
                productModelData.modelName = me.getFileBaseName(file.name);
                productModelData.modelDesignSVG = svgStr;
                productModelData.modelDesignSVGPath = svgFilePath;
                RolandKioskPrint.AppData.productModelData =
                    new RolandKioskPrint.app.ProductModel(productModelData);

                me.redirectTo('#template/import', true);
            },
            function(errorMsg) {
                // Rejected.
                Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'), errorMsg);
            }
        ).always(function() {
            mainView.getEl().unmask();
        });
    },

    padString: function(pad, str, padLeft) {
        if (typeof str == 'undefined') {
            return pad;
        }

        if (padLeft) {
            return (pad + str).slice(-pad.length);
        } else {
            return (str + pad).substring(0, pad.length);
        }
    },

    getInputFileName: function(value) {
        // Returns the file base name.
        // For example, returns 200x100 for C:\fakepath\200x100.layout
        return value.substring(value.lastIndexOf('\\') + 1, value.lastIndexOf('.'));
    },

    containsIgnoreCase: function(store, column, value) {
        // Do a full case insensitive match.
        return store.find(column, value, 0, false, false, true) >= 0;
    },

    uploadModelLayout: function(layoutName, file, overwrite) {
        var mainView = this.getView();
        mainView.getEl().mask(RolandKioskPrint.app.getString('message.pmd_mld.uploadingML'));

        var formData = new FormData();
        formData.append('file', file);

        var me = this;
        Ext.Ajax.request({
            scope: this,
            method: 'POST',
            url: RolandKioskPrint.app.constants.MODEL_LAYOUT_URL + '?upload&update-mapping=' + (overwrite || false),
            rawData: formData,
            headers: {
                'Content-Type': null // To use content type of FormData
            },
            success: function(response, opts) {
                mainView.getEl().unmask();

                var responseData = Ext.decode(response.responseText);
                if (responseData.success) {
                    me.onModelLayoutSaved({
                        layoutName: layoutName,
                        updateMapping: overwrite
                    });
                    me.refreshLists();
                } else if (responseData.uploadStatus == 1) {
                    Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                                  RolandKioskPrint.app.getString('message.pmd_mld.mlUploadFailed') + ' ' +
                                  RolandKioskPrint.app.getString('message.designer.requestSizeExceeds'));
                } else if (responseData.uploadStatus == 2) {
                    Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                                  RolandKioskPrint.app.getString('message.pmd_mld.mlUploadFailed') + ' ' +
                                  RolandKioskPrint.app.getString('message.designer.fileSizeExceeds'));
                } else if (responseData.uploadStatus == 4) {
                    Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                                  RolandKioskPrint.app.getString('message.pmd_mld.mlUploadFailed') + ' ' +
                                  RolandKioskPrint.app.getString('message.pmd_mld.unsupportedFormat'));
                } else {
                    Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                                  RolandKioskPrint.app.getString('message.pmd_mld.mlUploadFailed'));
                }
            },
            failure: function() {
                mainView.getEl().unmask();
                Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                              RolandKioskPrint.app.getString('message.pmd_mld.mlUploadFailed'));
            }
        });
    },

    uploadProductModel: function(modelName, file, overwrite) {
        var mainView = this.getView();
        mainView.getEl().mask(RolandKioskPrint.app.getString('message.pmd_mld.uploadingPM'));

        var formData = new FormData();
        formData.append('file', file);

        var me = this;
        Ext.Ajax.request({
            scope: this,
            method: 'POST',
            url: RolandKioskPrint.app.constants.PRODUCT_MODEL_URL + '?upload&delete-mapping=' + (overwrite || false),
            rawData: formData,
            headers: {
                'Content-Type': null // To use content type of FormData
            },
            success: function(response, opts) {
                mainView.getEl().unmask();

                var responseData = Ext.decode(response.responseText);
                if (responseData.success) {
                    me.onProductModelSaved(modelName);
                    me.refreshLists();
                } else if (responseData.uploadStatus == 1) {
                    Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                                  RolandKioskPrint.app.getString('message.pmd_mld.pmUploadFailed') + ' ' +
                                  RolandKioskPrint.app.getString('message.designer.requestSizeExceeds'));
                } else if (responseData.uploadStatus == 2) {
                    Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                                  RolandKioskPrint.app.getString('message.pmd_mld.pmUploadFailed') + ' ' +
                                  RolandKioskPrint.app.getString('message.designer.fileSizeExceeds'));
                } else if (responseData.uploadStatus == 4) {
                    Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                                  RolandKioskPrint.app.getString('message.pmd_mld.pmUploadFailed') + ' ' +
                                  RolandKioskPrint.app.getString('message.pmd_mld.unsupportedFormat'));
                } else {
                    Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                                  RolandKioskPrint.app.getString('message.pmd_mld.pmUploadFailed'));
                }
            },
            failure: function() {
                mainView.getEl().unmask();
                Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                              RolandKioskPrint.app.getString('message.pmd_mld.pmUploadFailed'));
            }
        });
    },

    validateModelName: function(value) {
        value = value.trim();

        // Verify that the model file name does not contain invalid chars.
        // It is okay to check just for comma here, as other chars are anyways not allowed by Windows for
        // its file names.
        if (value.indexOf(',') != -1) {
            return RolandKioskPrint.app.getString('message.pmd_mld.nameInvalidChars');
        }

        // Product model name must be of the form w.x.y.z, where w, x and y are
        // category and sub-category names, and are optional. z is the product name.
        // There can not be more than 4 parts, and each part if present, must be non-blank.
        var partNames = value.split('.').map(function(partName) {
            return partName.trim();
        });

        if (partNames.length > 4) {
            return RolandKioskPrint.app.getString('message.pmd_mld.pmNameTooManySections');
        } else {
            for (var i = 0, length = partNames.length; i < length; i++) {
                if (!partNames[i]) {
                    return RolandKioskPrint.app.getString('message.pmd_mld.pmNameInvalid');
                }
            }
        }

        // Create the product model name back with the part names trimmed.
        if (partNames.length > 1) {
            value = partNames.join('.');
        }

        // Product model name must not be an existing category/sub-category name.
        // Nor, should it try to use an existing product model name as a category.
        var productModelList = this.getView().down('#productModelList');

        var store = productModelList.getStore();
        var names = [];

        store.each(function(record) {
            names.push(record.data.modelName);
        });

        for (var i = 0, length = names.length; i < length; i++) {
            if (value.lastIndexOf(names[i] + '.', 0) === 0 ||
                names[i].lastIndexOf(value + '.', 0) === 0 ) {
                return Ext.String.format(
                    RolandKioskPrint.app.getString('message.pmd_mld.pmNameConflict'),
                    value, names[i]);
            }
        }

        return false;
    },

    initializePrintTypeFilter: function(component, filterFn) {
        var menu = component.headerCt.getMenu();
        var features = RolandKioskPrint.AppData.getFeatures();

        function filterByPrintType(item, printType) {
            var filters = menu.appliedFilters;

            if (item.checked && filters.indexOf(printType) == -1) {
                filters.push(printType);
            } else if (!item.checked) {
                var index = filters.indexOf(printType);
                if (index != -1) {
                    filters.splice(index, 1);
                }
            }

            if (filterFn) {
                filterFn(filters);
            }
        }

        if (features.allowFoilPrint || features.allowMetalPrint || features.allowCutPrint) {
            // Need filter only when we have more than one print types.
            var colorPrint = RolandKioskPrint.app.getString('label.pmd_mld_pd.colorPrint'),
                foilPrint = RolandKioskPrint.app.getString('label.pmd_mld_pd.foilPrint'),
                metalPrint = RolandKioskPrint.app.getString('label.pmd_mld_pd.metalPrint'),
                cutPrint = RolandKioskPrint.app.getString('label.pmd_mld_pd.cutPrint');

            menu.appliedFilters = [];

            var allowedFilters = [];
            allowedFilters.push(colorPrint); // Color is always there

            var colorMenuItem = Ext.create('Ext.menu.CheckItem', {
                text: colorPrint,
                checked: true,
                hideOnClick: false,
                handler: function() {
                    filterByPrintType(this, RolandKioskPrint.app.constants.PRINT_TYPE_COLOR);
                }
            });
            menu.add(colorMenuItem);
            menu.appliedFilters.push(RolandKioskPrint.app.constants.PRINT_TYPE_COLOR);

            if (features.allowFoilPrint) {
                allowedFilters.push(foilPrint);

                var foilMenuItem = Ext.create('Ext.menu.CheckItem', {
                    text: foilPrint,
                    checked: true,
                    hideOnClick: false,
                    handler: function() {
                        filterByPrintType(this, RolandKioskPrint.app.constants.PRINT_TYPE_FOIL);
                    }
                });
                menu.add(foilMenuItem);
                menu.appliedFilters.push(RolandKioskPrint.app.constants.PRINT_TYPE_FOIL);
            }

            if (features.allowMetalPrint) {
                allowedFilters.push(metalPrint);

                var metalMenuItem = Ext.create('Ext.menu.CheckItem', {
                    text: metalPrint,
                    checked: true,
                    hideOnClick: false,
                    handler: function() {
                        filterByPrintType(this, RolandKioskPrint.app.constants.PRINT_TYPE_METAL);
                    }
                });
                menu.add(metalMenuItem);
                menu.appliedFilters.push(RolandKioskPrint.app.constants.PRINT_TYPE_METAL);
            }

            if (features.allowCutPrint) {
                allowedFilters.push(cutPrint);

                var cutMenuItem = Ext.create('Ext.menu.CheckItem', {
                    text: cutPrint,
                    checked: true,
                    hideOnClick: false,
                    handler: function() {
                        filterByPrintType(this, RolandKioskPrint.app.constants.PRINT_TYPE_CUT);
                    }
                });
                menu.add(cutMenuItem);
                menu.appliedFilters.push(RolandKioskPrint.app.constants.PRINT_TYPE_CUT);
            }


            component.headerCt.addCls('show-trigger');

            menu.on('beforeshow', function() {
                if (!this.removedUnwantedItems) {
                    // Remove the default menu items added by the framework.
                    var items = menu.items.items;
                    for (var i = items.length - 1; i >= 0; --i) {
                        var text = items[i].text;
                        if (allowedFilters.indexOf(text) == -1) {
                            menu.items.remove(items[i]);
                        }
                    }
                    this.removedUnwantedItems = true;
                }
            });
        } else {
            // Hide the filter.
            component.headerCt.addCls('hide-trigger');
        }
    },

    filterModelLayoutsByPrintType: function(printType) {
        var modelLayoutList = this.getView().down('#modelLayoutList');
        var store = modelLayoutList.getStore();

        var printTypeFilter = store.printTypeFilter;
        if (!printTypeFilter) {
            // Create the filter.
            printTypeFilter = new Ext.util.Filter({
                value: printType,
                filterFn: function(record) {
                    return (this.getValue().indexOf(record.get('printType')) != -1);
                }
            });
            store.printTypeFilter = printTypeFilter;
        } else {
            printTypeFilter.setValue(printType);
        }

        // Remember the selection.
        var selectedRecord = this.getSelectedModelLayoutRecord();

        // Need to remove and re-add for filter to run.
        store.getFilters().add(printTypeFilter);

        setTimeout(function() {
            // Removing filter and re-adding causes list to go blank in some cases.
            // Below is a workaround to refresh the list contents.
            modelLayoutList.scrollBy(0, 0, false);

            // Preserve the selection, if visible.
            if (selectedRecord) {
                var filterFn = printTypeFilter.getFilterFn().bind(printTypeFilter);
                if (filterFn(selectedRecord)) {
                    modelLayoutList.ensureVisible(selectedRecord);
                }
            }
        }, 10);
    },

    filterProductModelsByPrintType: function(printType) {
        var productModelList = this.getView().down('#productModelList');
        var store = productModelList.getStore();

        var printTypeFilter = store.printTypeFilter;
        if (!printTypeFilter) {
            // Create the filter.
            printTypeFilter = new Ext.util.Filter({
                value: printType,
                filterFn: function(record) {
                    var recPrintType = record.get('printType');
                    if (Array.isArray(recPrintType)) {
                        var hasPrintType = false;
                        for (var i = 0; !hasPrintType && i < recPrintType.length; ++i) {
                            hasPrintType = (this.getValue().indexOf(recPrintType[i]) != -1);
                        }
                        return hasPrintType;
                    }
                    return (this.getValue().indexOf(recPrintType) != -1);
                }
            });
            store.printTypeFilter = printTypeFilter;
        } else {
            printTypeFilter.setValue(printType);
        }

        // Remember the selection.
        var selectedRecord = this.getSelectedProductModelRecord();

        // Need to remove and re-add for filter to run.
        store.getFilters().add(printTypeFilter);

        setTimeout(function() {
            // Removing filter and re-adding causes list to go blank in some cases.
            // Below is a workaround to refresh the list contents.
            productModelList.scrollBy(0, 0, false);

            // Preserve the selection, if visible.
            if (selectedRecord) {
                var filterFn = printTypeFilter.getFilterFn().bind(printTypeFilter);
                if (filterFn(selectedRecord)) {
                    productModelList.ensureVisible(selectedRecord);
                }
            }
        }, 10);
    },

    onSearchTextfieldChange: function(textfield, e, eOpts) {
        var productModelList = this.getView().down('#productModelList');
        var store = productModelList.getStore();

        var searchValue = textfield.getValue().trim();
        if (searchValue === '') {
            store.removeFilter(store.modelNameFilter);
            return;
        }

        var modelNameFilter = store.modelNameFilter;
        if (!modelNameFilter) {
            // Create the filter.
            modelNameFilter = new Ext.util.Filter({
                value: searchValue.toLowerCase(),
                filterFn: function(record) {
                    var recModelName = record.get('modelName');
                    return (recModelName.toLowerCase().indexOf(this.getValue()) != -1);
                }
            });
            store.modelNameFilter = modelNameFilter;
        } else {
            modelNameFilter.setValue(searchValue.toLowerCase());
        }

        // Need to remove and re-add for filter to run.
        store.getFilters().add(modelNameFilter);
    },

    onNewProductModelButtonClick: function(button, e, eOpts) {
        var promise = this.checkSaveConnections();

        var me = this;
        promise.then(function() {
            // Set product model designer mode to 'NEW' and redirect.
            RolandKioskPrint.AppData.productModelDesignerMode = RolandKioskPrint.app.constants.PRODUCT_MODEL_NEW;
            RolandKioskPrint.AppData.productModelData = new RolandKioskPrint.app.ProductModel();

            me.redirectTo('#template/new', true);
        });
    },

    onEditProductModelButtonClick: function(button, e, eOpts) {
        // Get the selected product model.
        var productModelRecord = this.getSelectedProductModelRecord();
        if (!productModelRecord) {
            return;
        }

        var promise = this.checkSaveConnections();

        var me = this;
        promise.then(function() {
            me.editProductModel(productModelRecord);
        });
    },

    onImportProductModel: function(filefield, value, eOpts) {
        var fileInputEl = filefield.getEl().down('input[type=file]');

        if (!value) {
            // Clearing fileInputEl fires fileFieldChange again on IE.
            // We do a early return in that case.
            return;
        }

        // Verify that .svg file or .zip package is selected.
        var isSVG = /\.svg$/i.test(value);
        var isZip = /\.zip$/i.test(value);

        if (!isSVG && !isZip) {
            Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
            RolandKioskPrint.app.getString('message.pmd_mld.notSVGOrZIPFile'));
            fileInputEl.dom.value = '';
            return;
        }

        var promise = this.checkSaveConnections();

        var me = this;
        promise.then(function() {
            var file = fileInputEl.dom.files[0];
            me.importProductModel(file, isSVG);
        }).always(function() {
            // Reset so that change fires even when the same file is selected again.
            fileInputEl.dom.value = '';
        });
    },

    onPreviewProductModelButtonClick: function(button, e, eOpts) {
        // Get the selected product model.
        var productModelRecord = this.getSelectedProductModelRecord();
        if (!productModelRecord) {
            return;
        }

        var promise = this.checkSaveConnections();

        var me = this;
        promise.then(function() {
            // Set product model designer mode to 'PREVIEW' and redirect.
            RolandKioskPrint.AppData.productModelDesignerMode =
            RolandKioskPrint.app.constants.PRODUCT_MODEL_PREVIEW;

            var productModel = productModelRecord.data;

            var productModelData = new RolandKioskPrint.app.ProductModel({
                modelName: productModel.modelName,
                modelThumbPath: productModel.modelThumbPath
            });

            RolandKioskPrint.AppData.productModelData = productModelData;

            me.redirectTo('#template/preview', true);
        });
    },

    onDeleteProductModelButtonClick: function(button, e, eOpts) {
        // Get the selected product model.
        var productModelRecord = this.getSelectedProductModelRecord();
        if (!productModelRecord) {
            return;
        }

        // Confirm with the user.
        var msg = Ext.String.format(RolandKioskPrint.app.getString('message.pmd_mld.pmDeletionConfirmation'),
            productModelRecord.data.modelName);

        Ext.Msg.confirm(RolandKioskPrint.app.getString('message.generic.confirmation'), msg, function(btnText) {
            if (btnText == 'yes') {
                this.deleteProductModel(productModelRecord);
            }
        }, this);
    },

    onUploadProductModel: function(filefield, value, eOpts) {
        var fileInputEl = filefield.getEl().down('input[type=file]');

        if (!value) {
            // Clearing fileInputEl fires fileFieldChange again on IE.
            // We do a early return in that case.
            return;
        }

        // Verify that .template file is selected.
        if (!/\.template$/i.test(value)) {
            Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
            RolandKioskPrint.app.getString('message.pmd_mld.pmNotTemplateFile'));
            fileInputEl.dom.value = '';
            return;
        }

        // Validate the model name.
        var modelName = this.getInputFileName(value);
        var validationMsg = this.validateModelName(modelName);

        if (validationMsg) {
            Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
            validationMsg);
            fileInputEl.dom.value = '';
            return;
        }

        // Check if a product model with the same name exists.
        var productModelstore = this.getView().down('#productModelList');
        var store = productModelstore.getStore();

        var deferred = new Ext.Deferred();
        if (this.containsIgnoreCase(store, 'modelName', modelName)) {
            // Get user confirmation.
            Ext.Msg.confirm(RolandKioskPrint.app.getString('message.generic.confirmation'),
            RolandKioskPrint.app.getString('message.pmd_mld.pmOverwriteConfirmation'),
            function(btnText) {
                if (btnText == 'yes') {
                    deferred.resolve({
                        modelName: modelName,
                        overwrite: true
                    });
                } else {
                    deferred.reject();
                }
            }, this);
        } else {
            deferred.resolve({
                modelName: modelName,
                overwrite: false
            });
        }

        var me = this;
        deferred.promise.then(function(modelData) {
            // Fulfilled.
            var promise = me.checkSaveConnections();

            promise.then(function() {
                var file = fileInputEl.dom.files[0];
                me.uploadProductModel(modelData.modelName, file, modelData.overwrite);
            }).always(function() {
                // Reset so that change fires even when the same file is selected again.
                fileInputEl.dom.value = '';
            });
        }, function() {
            // Rejected.
            // Reset so that change fires even when the same file is selected again.
            fileInputEl.dom.value = '';
        });
    },

    onSaveProductModelButtonClick: function(button, e, eOpts) {
        // Get the selected product model.
        var productModelRecord = this.getSelectedProductModelRecord();
        if (!productModelRecord) {
            return;
        }

        var promise = this.checkSaveConnections();
        var me = this;

        promise.then(function() {
            var url = RolandKioskPrint.app.constants.PRODUCT_MODEL_URL +
            '?name=' + encodeURIComponent(productModelRecord.data.modelName) + '&download';
            Ext.Ajax.request({
                scope: me,
                url: url,
                responseType: 'blob',
                success: function(response, opts) {
                    var contentType = response.getResponseHeader('content-type');
                    if (contentType == 'application/zip') {
                        var a = document.createElement('a');
                        var url = window.URL.createObjectURL(response.responseBlob);
                        a.href = url;
                        a.download = productModelRecord.data.modelName + '.template';
                        a.click();
                        window.URL.revokeObjectURL(url);
                    } else {
                        Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                        RolandKioskPrint.app.getString('message.pmd_mld.pmDownloadFailed'));
                    }
                },
                failure: function(response, opts) {
                    Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                    RolandKioskPrint.app.getString('message.pmd_mld.pmDownloadFailed'));
                }
            });
        });
    },

    onProductModelListHeaderTriggerClick: function(ct, column, e, t, eOpts) {
        ct.showMenuBy(e, column.el, column);
        return false;
    },

    onProductModelListSelectionChange: function(model, selected, eOpts) {
        this.updateConnections();
    },

    onProductModelListItemDblClick: function(dataview, record, item, index, e, eOpts) {
        var promise = this.checkSaveConnections();

        var me = this;
        promise.then(function() {
            me.editProductModel(record);
        });
    },

    onProductModelListBeforeDeselect: function(rowmodel, record, index, eOpts) {
        this.checkSaveConnections(record);
        return true; // Allow deselection
    },

    onProductModelListAfterRender: function(component, eOpts) {
        this.initializePrintTypeFilter(component, this.filterProductModelsByPrintType.bind(this));
    },

    onNewModelLayoutButtonClick: function(button, e, eOpts) {
        var promise = this.checkSaveConnections();

        var me = this;
        promise.then(function() {
            // Set model layout designer mode to 'NEW' and redirect.
            RolandKioskPrint.AppData.modelLayoutDesignerMode = RolandKioskPrint.app.constants.MODEL_LAYOUT_NEW;
            RolandKioskPrint.AppData.modelLayoutData = new RolandKioskPrint.app.ModelLayout();

            me.redirectTo('#print-layout/new', true);
        });
    },

    onEditModelLayoutButtonClick: function(button, e, eOpts) {
        // Get the selected model layout.
        var modelLayoutRecord = this.getSelectedModelLayoutRecord();
        if (!modelLayoutRecord) {
            return;
        }

        var promise = this.checkSaveConnections();

        var me = this;
        promise.then(function() {
            me.editModelLayout(modelLayoutRecord);
        });
    },

    onImportModelLayout: function(filefield, value, eOpts) {
        var fileInputEl = filefield.getEl().down('input[type=file]');

        if (!value) {
            // Clearing fileInputEl fires fileFieldChange again on IE.
            // We do a early return in that case.
            return;
        }

        // Verify that .svg file is selected.
        if (!/\.svg$/i.test(value)) {
            Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
            RolandKioskPrint.app.getString('message.pmd_mld.notSVGFile'));
            fileInputEl.dom.value = '';
            return;
        }

        var promise = this.checkSaveConnections();

        var me = this;
        promise.then(function() {
            var file = fileInputEl.dom.files[0];
            me.importModelLayout(file);
        }).always(function() {
            // Reset so that change fires even when the same file is selected again.
            fileInputEl.dom.value = '';
        });
    },

    onPreviewModelLayoutButtonClick: function(button, e, eOpts) {
        // Get the selected model layout.
        var modelLayoutRecord = this.getSelectedModelLayoutRecord();
        if (!modelLayoutRecord) {
            return;
        }

        var modelLayout = modelLayoutRecord.data;

        var promise = this.checkSaveConnections();

        var me = this;
        promise.then(function() {
            // Get model layout data from server.
            var mainView = me.getView();
            mainView.getEl().mask(RolandKioskPrint.app.getString('message.pmd_mld.openingML'));

            Ext.Ajax.request({
                scope: me,
                url: modelLayout.layoutTemplatePath,
                success: function(response, opts) {
                    mainView.getEl().unmask();

                    var modelLayoutData = Ext.decode(response.responseText);
                    if (!modelLayoutData) {
                        Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                        RolandKioskPrint.app.getString('message.pmd_mld.mlOpeningFailed'));
                        return;
                    }

                    // Set model layout designer mode to 'PREVIEW' and redirect.
                    RolandKioskPrint.AppData.modelLayoutDesignerMode =
                    RolandKioskPrint.app.constants.MODEL_LAYOUT_PREVIEW;

                    modelLayoutData.layoutName = modelLayout.layoutName;
                    modelLayoutData.printType = modelLayout.printType;

                    RolandKioskPrint.AppData.modelLayoutData =
                    new RolandKioskPrint.app.ModelLayout(modelLayoutData);

                    this.redirectTo('#print-layout/preview', true);
                },
                failure: function() {
                    mainView.getEl().unmask();
                    Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                    RolandKioskPrint.app.getString('message.pmd_mld.mlOpeningFailed'));
                }
            });
        });
    },

    onDeleteModelLayoutButtonClick: function(button, e, eOpts) {
        // Get the selected model layout.
        var modelLayoutRecord = this.getSelectedModelLayoutRecord();
        if (!modelLayoutRecord) {
            return;
        }

        // Confirm with the user.
        var msg = Ext.String.format(RolandKioskPrint.app.getString('message.pmd_mld.mlDeletionConfirmation'),
            modelLayoutRecord.data.layoutName);

        Ext.Msg.confirm(RolandKioskPrint.app.getString('message.generic.confirmation'), msg, function(btnText) {
            if (btnText == 'yes') {
                this.deleteModelLayout(modelLayoutRecord);
            }
        }, this);
    },

    onUploadModelLayout: function(filefield, value, eOpts) {
        var fileInputEl = filefield.getEl().down('input[type=file]');

        if (!value) {
            // Clearing fileInputEl fires fileFieldChange again on IE.
            // We do a early return in that case.
            return;
        }

        // Verify that .layout file is selected.
        if (!/\.layout$/i.test(value)) {
            Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
            RolandKioskPrint.app.getString('message.pmd_mld.mlNotLayoutFile'));
            fileInputEl.dom.value = '';
            return;
        }

        // Verify that the layout file name does not contain invalid chars.
        // It is okay to check just for comma here, as other chars are anyways not allowed by Windows for
        // its file names.
        if (value.indexOf(',') != -1) {
            Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
            RolandKioskPrint.app.getString('message.pmd_mld.nameInvalidChars'));
            fileInputEl.dom.value = '';
            return;
        }

        // Check if a model layout with the same name exists.
        var layoutName = this.getInputFileName(value);
        var modelLayoutList = this.getView().down('#modelLayoutList');
        var store = modelLayoutList.getStore();

        var deferred = new Ext.Deferred();
        if (this.containsIgnoreCase(store, 'layoutName', layoutName)) {
            // Get user confirmation.
            Ext.Msg.confirm(RolandKioskPrint.app.getString('message.generic.confirmation'),
            RolandKioskPrint.app.getString('message.pmd_mld.mlOverwriteConfirmation'),
            function(btnText) {
                if (btnText == 'yes') {
                    deferred.resolve({
                        layoutName: layoutName,
                        overwrite: true
                    });
                } else {
                    deferred.reject();
                }
            }, this);
        } else {
            deferred.resolve({
                layoutName: layoutName,
                overwrite: false
            });
        }

        var me = this;
        deferred.promise.then(function(layoutData) {
            // Fulfilled.
            var promise = me.checkSaveConnections();

            promise.then(function() {
                var file = fileInputEl.dom.files[0];
                me.uploadModelLayout(layoutData.layoutName, file, layoutData.overwrite);
            }).always(function() {
                // Reset so that change fires even when the same file is selected again.
                fileInputEl.dom.value = '';
            });
        }, function() {
            // Rejected.
            // Reset so that change fires even when the same file is selected again.
            fileInputEl.dom.value = '';
        });
    },

    onSaveModelLayoutButtonClick: function(button, e, eOpts) {
        // Get the selected model layout.
        var modelLayoutRecord = this.getSelectedModelLayoutRecord();
        if (!modelLayoutRecord) {
            return;
        }

        var promise = this.checkSaveConnections();
        var me = this;

        promise.then(function() {
            var url = RolandKioskPrint.app.constants.MODEL_LAYOUT_URL +
            '?name=' + encodeURIComponent(modelLayoutRecord.data.layoutName) + '&download';

            Ext.Ajax.request({
                scope: me,
                url: url,
                responseType: 'blob',
                success: function(response, opts) {
                    var contentType = response.getResponseHeader('content-type');
                    if (contentType == 'application/zip') {
                        var a = document.createElement('a');
                        var url = window.URL.createObjectURL(response.responseBlob);
                        a.href = url;
                        a.download = modelLayoutRecord.data.layoutName + '.layout';
                        a.click();
                        window.URL.revokeObjectURL(url);
                    } else {
                        Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                        RolandKioskPrint.app.getString('message.pmd_mld.mlDownloadFailed'));
                    }
                },
                failure: function(response, opts) {
                    Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                    RolandKioskPrint.app.getString('message.pmd_mld.mlDownloadFailed'));
                }
            });
        });
    },

    onModelLayoutListHeaderTriggerClick: function(ct, column, e, t, eOpts) {
        ct.showMenuBy(e, column.el, column);
        return false;
    },

    onModelLayoutListItemDblClick: function(dataview, record, item, index, e, eOpts) {
        var promise = this.checkSaveConnections();

        var me = this;
        promise.then(function() {
            me.editModelLayout(record);
        });
    },

    onModelLayoutListAfterRender: function(component, eOpts) {
        this.initializePrintTypeFilter(component, this.filterModelLayoutsByPrintType.bind(this));
    },

    onSaveConnectionsButtonClick: function(button, e, eOpts) {
        // Save the model layout connections for the selected product model.
        var productModelRecord = this.getSelectedProductModelRecord();
        if (!productModelRecord) {
            return;
        }

        if (!this.areConnectionsValid()) {
            if (productModelRecord.data.printType == RolandKioskPrint.app.constants.PRINT_TYPE_FOIL) {
                Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                RolandKioskPrint.app.getString('message.pmd_mld.invalidConnectionsFoilToNonFoil'));
            } else if (productModelRecord.data.printType == RolandKioskPrint.app.constants.PRINT_TYPE_METAL) {
                Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                RolandKioskPrint.app.getString('message.pmd_mld.invalidConnectionsMetalToNonMetal'));
            } else if (productModelRecord.data.printType == RolandKioskPrint.app.constants.PRINT_TYPE_CUT) {
                Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                RolandKioskPrint.app.getString('message.pmd_mld.invalidConnectionsCutToNonCut'));
            } else {
                Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                RolandKioskPrint.app.getString('message.pmd_mld.invalidConnectionsColorToNonColor'));
            }
            return;
        }

        this.saveConnections(productModelRecord, this.getConnections());
    },

    onMainViewShow: function(component, eOpts) {
        if (!this.fontsDownloaded) {
            // Force font downloading by the browser.
            this.forceFontsDownload();
            this.fontsDownloaded = true;
        }

        this.refreshLists();

        if (!this.loadImagesDataOnce) {
            this.loadImagesDataOnce = true;
            RolandKioskPrint.app.fetchProductModelImages(RolandKioskPrint.app.constants.PRINT_TYPE_FOIL);
            RolandKioskPrint.app.fetchProductModelImages(RolandKioskPrint.app.constants.PRINT_TYPE_METAL);
            RolandKioskPrint.app.fetchProductModelImages(RolandKioskPrint.app.constants.PRINT_TYPE_COLOR);
            RolandKioskPrint.app.fetchBundledImages();
        }
    },

    showChangePasswordScreen: function(owner, tool, event) {
        this.redirectTo('#change-password', true);
    },

    onMainViewHide: function(component, eOpts) {
        RolandKioskPrint.view.window.HelpWindowViewController.closeHelp();
    },

    showHelp: function(owner, tool, event) {
        var curPrefLang = RolandKioskPrint.app.getPrefLanguage();
        var helpSrc = 'resources/help/' + curPrefLang + '/cotodesignTemplate/tp_pl_list.html';
        RolandKioskPrint.view.window.HelpWindowViewController.showHelp(
        helpSrc, 'pmd-mld-help-window', 300);
    }

});
