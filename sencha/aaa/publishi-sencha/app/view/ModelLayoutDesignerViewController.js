/*
 * File: app/view/ModelLayoutDesignerViewController.js
 *
 * This file was generated by Sencha Architect version 4.2.4.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 6.6.x Classic library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 6.6.x Classic. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RolandKioskPrint.view.ModelLayoutDesignerViewController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.modellayoutdesigner',

    validateUserInput: function() {
        // Validate in the order these controls appear in the UI.
        var inputItemIds = [
            'txtSlotHeight',
            'txtSlotWidth',
            'txtMarginTop',
            'txtMarginBottom',
            'txtMarginLeft',
            'txtMarginRight',
            'txtPrintOffsetY',
            'txtPrintOffsetX',
            'txtNumRows',
            'txtNumColumns',
            'txtSpacingVert',
            'txtSpacingHorz'
        ]


        var layoutData = this.getViewModel().getData()

        if (layoutData.sizeRestriction) {
            inputItemIds.push('txtMaxLayoutHeight', 'txtMaxLayoutWidth')

        }

        var invalidItem
 // undefined
        var view = this.getView()


        for (var i = 0
 i < inputItemIds.length; i++) {
            var inputItem = view.down('#' + inputItemIds[i])

            if (!inputItem.isValid()) {
                invalidItem = inputItem

                break

            }
        }

        if (!invalidItem) {
            var validationResult = this.validateNumRowsCols()

            if (validationResult.status) {
                return true

            }

            invalidItem = validationResult.invalidItem

        }

        invalidItem.focus()

        return false

    },

    updateModelLayoutView: function(drawingThumbnail) {
        var view = this.getView().down('#modelLayoutView')


        var surface = view.getSurface()


        if (this.updatingLayoutView) {
            // Return if we are already updating.
            return

        }

        // Mark we are updating the view.
        this.updatingLayoutView = true


        // Set surface size.
        surface.setWidth(view.getWidth())

        surface.setHeight(view.getHeight())


        // Clear all to start with.
        surface.removeAll(true)


        // Background.
        this.drawBackground(surface)


        // Horizontal and vertical bars.
        this.drawAxisBars(surface)


        // Draw the model layout.
        this.drawModelLayout(surface, drawingThumbnail)


        // Finally, render the frame.
        surface.renderFrame()


        // Done with updation.
        this.updatingLayoutView = false

    },

    validateLayoutHeight: function(skipAction) {
        var layoutData = this.getViewModel().getData()

        if (!layoutData.sizeRestriction) {
            // Size restriction doesn't apply.
            return true

        }

        var view = this.getView()

        var inputItem = view.down('#txtMaxLayoutHeight')

        if (!inputItem.isValid()) {
            return true
 // Can't validate as the size limit is not known
        }

        if (!layoutData.layoutHeightMM) {
            return true
 // Can't validate as the layout size is not known
        }

        var isValidHeight = (layoutData.layoutHeightMM <= layoutData.maxLayoutHeightMM)


        if (!skipAction) {
            var txtSlotHeight = view.down('#txtSlotHeight'),
                txtNumRows = view.down('#txtNumRows'),
                txtMarginTop = view.down('#txtMarginTop'),
                txtMarginBottom = view.down('#txtMarginBottom'),
                txtSpacingVert = view.down('#txtSpacingVert')


            var lengthExceededMsg = this.heightExceededMsg


            if (!isValidHeight) {
                txtMarginTop.markInvalid(lengthExceededMsg)

                txtMarginBottom.markInvalid(lengthExceededMsg)

                txtSlotHeight.markInvalid(lengthExceededMsg)

                txtNumRows.markInvalid(lengthExceededMsg)

                txtSpacingVert.markInvalid(lengthExceededMsg)

            } else {
                txtMarginTop.clearInvalid()

                txtMarginBottom.clearInvalid()

                txtSlotHeight.clearInvalid()

                txtNumRows.clearInvalid()

                txtSpacingVert.clearInvalid()

            }
        }

        return isValidHeight

    },

    validateLayoutWidth: function(skipAction) {
        var layoutData = this.getViewModel().getData()

        if (!layoutData.sizeRestriction) {
            // Size restriction doesn't apply.
            return true

        }

        var view = this.getView()

        var inputItem = view.down('#txtMaxLayoutWidth')

        if (!inputItem.isValid()) {
             return true
 // Can't validate as the size limit is not known
        }

        if (!layoutData.layoutWidthMM) {
            return true
 // Can't validate as the layout size is not known
        }

        var isValidWidth = (layoutData.layoutWidthMM <= layoutData.maxLayoutWidthMM)


        if (!skipAction) {
            var txtSlotWidth = view.down('#txtSlotWidth'),
                txtNumColumns = view.down('#txtNumColumns'),
                txtMarginLeft = view.down('#txtMarginLeft'),
                txtMarginRight = view.down('#txtMarginRight'),
                txtSpacingHorz = view.down('#txtSpacingHorz')


            var widthExceededMsg = this.widthExceededMsg


            if (!isValidWidth) {
                txtMarginLeft.markInvalid(widthExceededMsg)

                txtMarginRight.markInvalid(widthExceededMsg)

                txtSlotWidth.markInvalid(widthExceededMsg)

                txtNumColumns.markInvalid(widthExceededMsg)

                txtSpacingHorz.markInvalid(widthExceededMsg)

            } else {
                txtMarginLeft.clearInvalid()

                txtMarginRight.clearInvalid()

                txtSlotWidth.clearInvalid()

                txtNumColumns.clearInvalid()

                txtSpacingHorz.clearInvalid()

            }
        }

        return isValidWidth

    },

    clearSizeConstraints: function() {
        var view = this.getView()

        var txtSlotWidth = view.down('#txtSlotWidth'),
            txtNumColumns = view.down('#txtNumColumns'),
            txtMarginLeft = view.down('#txtMarginLeft'),
            txtMarginRight = view.down('#txtMarginRight'),
            txtSpacingHorz = view.down('#txtSpacingHorz'),
            txtSlotHeight = view.down('#txtSlotHeight'),
            txtNumRows = view.down('#txtNumRows'),
            txtMarginTop = view.down('#txtMarginTop'),
            txtMarginBottom = view.down('#txtMarginBottom'),
            txtSpacingVert = view.down('#txtSpacingVert')



        txtMarginLeft.clearInvalid()

        txtMarginRight.clearInvalid()

        txtSlotWidth.clearInvalid()

        txtNumColumns.clearInvalid()

        txtSpacingHorz.clearInvalid()

        txtMarginTop.clearInvalid()

        txtMarginBottom.clearInvalid()

        txtSlotHeight.clearInvalid()

        txtNumRows.clearInvalid()

        txtSpacingVert.clearInvalid()


        txtMarginLeft.validate()

        txtMarginRight.validate()

        txtSlotWidth.validate()

        txtNumColumns.validate()

        txtSpacingHorz.validate()

        txtMarginTop.validate()

        txtMarginBottom.validate()

        txtSlotHeight.validate()

        txtNumRows.validate()

        txtSpacingVert.validate()

    },

    getModelLayoutThumb: function() {
        // Skip drawing origin from canvas.
        this.updateModelLayoutView(true)


        var view = this.getView().down('#modelLayoutView')

        var container = view.getEl().dom


        var canvas = container.getElementsByTagName('canvas')[0]

        var dummyCanvas = this.canvasElement


        var ctx = canvas.getContext('2d')

        var dummyCtx = dummyCanvas.getContext('2d')


        var items = view.getSurface().getItems()

        var rect

        for (var i = 0, length = items.length
 i < length; i++) {
            if (items[i].isBoundingRect) {
                rect = items[i]

                break

            }
        }

        var lineWidth = rect.config.lineWidth


        var devicePixelRatio = view.getSurface().devicePixelRatio

        dummyCanvas.width = Math.ceil((rect.width + lineWidth) * devicePixelRatio)

        dummyCanvas.height = Math.ceil((rect.height + lineWidth) * devicePixelRatio)


        var imageData = ctx.getImageData(Math.floor((rect.x - lineWidth / 2) * devicePixelRatio),
                                         Math.floor((rect.y - lineWidth / 2) * devicePixelRatio),
                                         dummyCanvas.width, dummyCanvas.height)

        dummyCtx.putImageData(imageData, 0, 0)


        // Restore - draw with origin.
        this.updateModelLayoutView()


        return dummyCanvas.toDataURL('image/png')

    },

    drawBackground: function(surface) {
        surface.add({
            type: 'rect',
            x: 0,
            y: 0,
            width: surface.getWidth(),
            height: surface.getHeight(),
            fillStyle: '#E6E7E8',
        })

    },

    drawAxisBars: function(surface) {
        var surfaceWidth = surface.getWidth()

        var surfaceHeight = surface.getHeight()


        var barSize = this.barSize

        var barTextSize = this.barTextSize


        // Corner.
        surface.add({
            type: 'rect',
            x: 0,
            y: 0,
            width: barSize,
            height: barSize,
            fillStyle: '#FFFFFF'
        })


        // Horizontal and vertical bars.
        surface.add({
            type: 'rect',
            x: barSize + 1,
            y: 0,
            width: surfaceWidth - barSize - 2,
            height: barSize,
            fillStyle: '#FFFFFF'
        })


        surface.add({
            type: 'rect',
            x: 0,
            y: barSize + 1,
            width: barSize,
            height: surfaceHeight - barSize - 1,
            fillStyle: '#FFFFFF'
        })


        surface.add({
            type: 'line',
            fromX: 0,
            fromY: barSize + 0.5,
            toX: surfaceWidth - 1,
            toY: barSize + 0.5,
            strokeStyle: '#B5B7BB',
            lineWidth: 1
        })


        surface.add({
            type: 'line',
            fromX: barSize + 0.5,
            fromY: 0,
            toX:  barSize + 0.5,
            toY: surfaceHeight,
            strokeStyle: '#B5B7BB',
            lineWidth: 1
        })


        surface.add({
            type: 'line',
            fromX: surfaceWidth - 0.5,
            fromY: 0,
            toX:  surfaceWidth - 0.5,
            toY: surfaceHeight,
            strokeStyle: '#B5B7BB',
            lineWidth: 1
        })


        // Draw the axis labels.
        surface.add({
            type: 'text',
            x: (surfaceWidth - barSize) / 2,
            y: barSize - 3,
            text: RolandKioskPrint.app.getString('label.pmd_mld.xPosition'),
            fontSize: barTextSize,
            fillStyle: '#000000'
        })


        var curPrefLang = RolandKioskPrint.app.getPrefLanguage()

        var isCJK = RolandKioskPrint.AppData.isCJK(curPrefLang)

        var dx = 1


        if (isCJK) {
            dx = 10

        } else if (curPrefLang == 'it') {
            dx = -4

        }

        surface.add({
            type: 'text',
            x: -barSize + dx,
            y: (surfaceHeight - barSize) / 2,
            text: RolandKioskPrint.app.getString('label.pmd_mld.yPosition'),
            fontSize: barTextSize,
            fillStyle: '#000000',
            rotation: 270
        })

    },

    drawModelLayout: function(surface, drawingThumbnail) {
        var surfaceWidth = surface.getWidth()

        var surfaceHeight = surface.getHeight()


        var gapSize = this.gapSize

        var barSize = this.barSize

        var originMarkRadius = this.originMarkRadius


        var view = this.getView()

        var layoutData = this.getViewModel().getData()


        if (layoutData.editable) {
            this.getViewModel().setData({
                layoutWidthMM: null,
                layoutHeightMM: null
            })


            // If any of the required fields is in error, we do not draw the model layout.
            var inputItemIds = [
                'txtSlotHeight',
                'txtSlotWidth',
                'txtMarginTop',
                'txtMarginBottom',
                'txtMarginLeft',
                'txtMarginRight',
                'txtNumRows',
                'txtNumColumns',
                'txtSpacingVert',
                'txtSpacingHorz'
            ]


            var invalidItem
 // undefined

            for (var i = 0
 i < inputItemIds.length; i++) {
                var inputItem = view.down('#' + inputItemIds[i])

                if (!inputItem.isValid()) {
                    invalidItem = inputItem

                    break

                }
            }

            if (invalidItem) {
                return
 // No further drawing
            }

            if (!this.validateNumRowsCols().status) {
                return
 // No further drawing
            }

            this.updateModelLayoutData()

        }

        var layoutWidthMM = layoutData.layoutWidthMM

        var layoutHeightMM = layoutData.layoutHeightMM


        var usableWidth = surfaceWidth - barSize - gapSize * 2

        var usableHeight = surfaceHeight - barSize - gapSize * 2


        var largeWidthMM = layoutWidthMM

        var largeHeightMM = layoutHeightMM


        // Check if size restrictions apply.
        var sizeRestriction = layoutData.sizeRestriction && !layoutData.fixedSize

        var maxLayoutWidthMM = layoutData.maxLayoutWidthMM

        var maxLayoutHeightMM = layoutData.maxLayoutHeightMM


        if (sizeRestriction && !drawingThumbnail) {
            var txtMaxLayoutHeight = view.down('#txtMaxLayoutHeight')

            var txtMaxLayoutWidth = view.down('#txtMaxLayoutWidth')


            if (txtMaxLayoutHeight.isValid() && txtMaxLayoutWidth.isValid()) {
                largeWidthMM = layoutWidthMM > maxLayoutWidthMM ? layoutWidthMM : maxLayoutWidthMM

                largeHeightMM = layoutHeightMM > maxLayoutHeightMM ? layoutHeightMM : maxLayoutHeightMM

            } else {
                sizeRestriction = false

            }
        }

        var rx = usableWidth / largeWidthMM

        var ry = usableHeight / largeHeightMM


        var rr,
            tx,
            ty


        if (rx < ry) {
            rr = rx

            tx = usableWidth  - layoutWidthMM * rr

            ty = (usableHeight - largeHeightMM * rr) / 2 + (largeHeightMM - layoutHeightMM)* rr

        } else {
            rr = ry

            ty = usableHeight - layoutHeightMM * rr

            tx = (usableWidth - largeWidthMM * rr) / 2 + (largeWidthMM - layoutWidthMM)* rr

        }

        var startX = barSize + gapSize

        var startY = startX


        // The transform matrix.
        var m = [rr, 0, 0, rr, startX + tx, startY + ty]


        // Draw the model layout background.
        surface.add({
            type: 'rect',
            x: startX + tx,
            y: startY + ty,
            width: layoutWidthMM * rr,
            height: layoutHeightMM * rr,
            fillStyle: '#FFFFFF',
            strokeStyle: '#000000',
            lineWidth: 2,
            isBoundingRect: true
        })


        var me = this

        var prevTextSize = 0,
            prevTextLen = 0,
            prevTextBounds


        var EPSILON = 1e-3

        function measureText(textSize, text, degrees) {
            if (text.length != prevTextLen ||
                Math.abs(textSize - prevTextSize) > EPSILON ||
                !prevTextBounds) {
                var sprite = Ext.create({
                    xtype: 'draw',
                    downloadServerUrl: 'none',
                    sprites: [{
                        type: 'text',
                        fontSize: textSize,
                        fontWeight: 'normal',
                        fontFamily: 'Arial',
                        text: text,
                        rotation: degrees
                    }]
                })


                prevTextSize = textSize

                prevTextLen = text.length

                prevTextBounds = {
                    width: sprite.sprites[0].getBBox().width,
                    height: sprite.sprites[0].getBBox().height
                }

            }
            return prevTextBounds

        }

        // Draw the slots.
        layoutData.slots.forEach(function(slot, index) {
            var slotWidth = slot.right - slot.left,
                slotHeight = slot.bottom - slot.top


            var type = slot.type

            var slotShape


            if (type == 'circle') {
                slotShape = {
                    type: 'circle',
                    cx: slot.cx,
                    cy: slot.cy,
                    r: slot.r
                }

            } else if (type == 'ellipse') {
                slotShape = {
                    type: 'ellipse',
                    cx: slot.cx,
                    cy: slot.cy,
                    rx: slot.rx,
                    ry: slot.ry
                }

            } else if (type == 'path') { // SVG polygon and path shapes
                slotShape = {
                    type: 'path',
                    path: me.toSVGPath(slot.path)
                }

            } else {
                slotShape = {
                    type: 'rect',
                    x: slot.left,
                    y: slot.top,
                    width: slotWidth,
                    height: slotHeight
                }

            }

            slotShape.fillStyle = '#B4DEF7'

            surface.add(slotShape).setTransform(m)


            var degrees = layoutData.rotationAngle

            if (degrees == 270 || degrees == 90) {
                degrees += 180

            }

            var textSize = slotWidth < slotHeight ? slotWidth : slotHeight

            textSize *= rr / 3

            textSize = Math.floor(textSize)


            var textBounds = measureText(textSize, (index + 1).toString(), degrees)

            surface.add({
                type: 'text',
                fontSize: textSize,
                fontWeight: 'normal',
                fontFamily: 'Arial',
                text: index + 1,
                x: slot.left * rr + startX + tx + (slotWidth * rr / 2) - (textBounds.width / 2),
                y: slot.top * rr + startY + ty + (slotHeight * rr / 2) + (textBounds.height / 2),
                width: textBounds.width,
                height: textBounds.height,
                rotation: degrees
            })

        })


        if (sizeRestriction && !drawingThumbnail) {
            surface.add({
                type: 'rect',
                x: layoutWidthMM - maxLayoutWidthMM,
                y: layoutHeightMM - maxLayoutHeightMM,
                width: maxLayoutWidthMM,
                height: maxLayoutHeightMM,
                strokeStyle: 'red',
                lineWidth: 2,
                lineDash: [5,5]
            }).setTransform(m)

        }

        if (!drawingThumbnail &&
            layoutData.source == 'Designer' &&
            layoutData.printType == RolandKioskPrint.app.constants.PRINT_TYPE_COLOR) {
            // Draw the origin. Skip for non color templates.
            var marginRight = layoutWidthMM - layoutData.rightMarginMM

            var marginBottom = layoutHeightMM - layoutData.bottomMarginMM


            surface.add({
                type: 'circle',
                cx: marginRight,
                cy: marginBottom,
                r: originMarkRadius / rr,
                fillStyle: '#D83532'
            }).setTransform(m)

        }
    },

    updateModelLayoutData: function() {
        // Computes the model layout size and the slots based on other
        // user configurable attributes of the model layout.
        var layoutData = this.getViewModel().getData()


        if (layoutData.source != 'Designer') {
            return
 // Layout size and slots must already be in place. Not computable.
        }

        // Layout width.
        var layoutWidthMM = layoutData.leftMarginMM + layoutData.rightMarginMM +
                            layoutData.slotWidthMM * layoutData.columnCount +
                            layoutData.horzSpacingMM * (layoutData.columnCount - 1)


        layoutData.layoutWidthMM = layoutWidthMM


        // Layout height.
        var layoutHeightMM = layoutData.topMarginMM + layoutData.bottomMarginMM +
                              layoutData.slotHeightMM * layoutData.rowCount +
                             layoutData.vertSpacingMM * (layoutData.rowCount - 1)


        layoutData.layoutHeightMM = layoutHeightMM


        // Compute the slot bounds.
        var slotCount = layoutData.rowCount * layoutData.columnCount

        layoutData.slots = new Array(slotCount)


        var i = 0

        for (var r = layoutData.rowCount - 1
 r >= 0; --r) {
            var slotTop = layoutData.topMarginMM + (layoutData.slotHeightMM + layoutData.vertSpacingMM) * r

            for (var c = layoutData.columnCount - 1
 c >= 0; --c) {
                var slot = {
                    left: layoutData.leftMarginMM + (layoutData.slotWidthMM + layoutData.horzSpacingMM) * c,
                    top: slotTop
                }


                slot.right = slot.left + layoutData.slotWidthMM

                slot.bottom = slot.top + layoutData.slotHeightMM


                layoutData.slots[i] = slot

                i++

            }
        }
    },

    initInputs: function() {
        // Clear and initialize all input fields.
        var inputItemIds = this.getInputItemIds()

        var inputItemValues = this.getInputItemValues()


        var viewModel = this.getViewModel()

        var units = viewModel.get('units')


        for (var i = 0
 i < inputItemIds.length; i++) {
            var inputItem = this.getView().down('#' + inputItemIds[i])

            inputItem.reset()


            var dataProp = inputItemValues[i]

            var itemValue = viewModel.get(dataProp)


            if (dataProp != 'rowCount' && dataProp != 'columnCount') {
                // Requires units conversion.
                if (itemValue !== null) {
                    itemValue = viewModel.convertMMToUnit(units, itemValue)

                }
            }
            inputItem.setValue(itemValue)

        }
    },

    init: function() {
        this.barSize = 18
 // Height/width of axis bars
        this.barTextSize = 12
 // Font size for axis bar labels
        this.gapSize = 40
 // Minimum gap to leave on all sides
        this.originMarkRadius = 7
 // Radius of the origin mark
        this.canvasElement = document.createElement('canvas')

    },

    setSizeLimits: function(units) {
        var layoutSizeMax = this.getLayoutSizeMax()


        var txtMaxLayoutHeight = this.getView().down('#txtMaxLayoutHeight')

        this.setSizeMinMax(
            txtMaxLayoutHeight,
            units,
            0,
            layoutSizeMax.h
        )


        var txtMaxLayoutWidth = this.getView().down('#txtMaxLayoutWidth')

        this.setSizeMinMax(
            txtMaxLayoutWidth,
            units,
            0,
            layoutSizeMax.w
        )


        var txtSlotHeight = this.getView().down('#txtSlotHeight')

        this.setSizeMinMax(
            txtSlotHeight,
            units,
            RolandKioskPrint.app.constants.SLOT_HEIGHT_MIN,
            RolandKioskPrint.app.constants.SLOT_HEIGHT_MAX
        )


        var txtSlotWidth = this.getView().down('#txtSlotWidth')

        this.setSizeMinMax(
            txtSlotWidth,
            units,
            RolandKioskPrint.app.constants.SLOT_WIDTH_MIN,
            RolandKioskPrint.app.constants.SLOT_WIDTH_MAX
        )


        var txtMarginTop = this.getView().down('#txtMarginTop')

        this.setSizeMinMax(
            txtMarginTop,
            units,
            RolandKioskPrint.app.constants.ORIGIN_POSITION_MIN,
            RolandKioskPrint.app.constants.ORIGIN_POSITION_MAX
        )


        var txtMarginBottom = this.getView().down('#txtMarginBottom')

        this.setSizeMinMax(
            txtMarginBottom,
            units,
            RolandKioskPrint.app.constants.ORIGIN_POSITION_MIN,
            RolandKioskPrint.app.constants.ORIGIN_POSITION_MAX
        )


        var txtMarginLeft = this.getView().down('#txtMarginLeft')

        this.setSizeMinMax(
            txtMarginLeft,
            units,
            RolandKioskPrint.app.constants.ORIGIN_POSITION_MIN,
            RolandKioskPrint.app.constants.ORIGIN_POSITION_MAX
        )


        var txtMarginRight = this.getView().down('#txtMarginRight')

        this.setSizeMinMax(
            txtMarginRight,
            units,
            RolandKioskPrint.app.constants.ORIGIN_POSITION_MIN,
            RolandKioskPrint.app.constants.ORIGIN_POSITION_MAX
        )


        var txtPrintOffsetY = this.getView().down('#txtPrintOffsetY')

        this.setSizeMinMax(
            txtPrintOffsetY,
            units,
            RolandKioskPrint.app.constants.PRINTING_POSITION_MIN,
            RolandKioskPrint.app.constants.PRINTING_POSITION_MAX
        )


        var txtPrintOffsetX = this.getView().down('#txtPrintOffsetX')

        this.setSizeMinMax(
            txtPrintOffsetX,
            units,
            RolandKioskPrint.app.constants.PRINTING_POSITION_MIN,
            RolandKioskPrint.app.constants.PRINTING_POSITION_MAX
        )


        var txtSpacingVert = this.getView().down('#txtSpacingVert')

        this.setSizeMinMax(
            txtSpacingVert,
            units,
            RolandKioskPrint.app.constants.SPACING_MIN,
            RolandKioskPrint.app.constants.SPACING_MAX
        )


        var txtSpacingHorz = this.getView().down('#txtSpacingHorz')

        this.setSizeMinMax(
            txtSpacingHorz,
            units,
            RolandKioskPrint.app.constants.SPACING_MIN,
            RolandKioskPrint.app.constants.SPACING_MAX
        )

    },

    setSizeMinMax: function(txtfield, units, minValueMM, maxValueMM) {
        if (units == 'mm') {
            txtfield.minValue = minValueMM

            txtfield.maxValue = maxValueMM

        } else {
            var value = this.getViewModel().convertMMToUnit(units, minValueMM)

            txtfield.minValue = parseFloat(value.toFixed(4))


            value = this.getViewModel().convertMMToUnit(units, maxValueMM)

            txtfield.maxValue = parseFloat(value.toFixed(4))

        }
    },

    validateInputs: function() {
        // Validate all input fields.
        var inputItemIds = this.getInputItemIds()


        for (var i = 0
 i < inputItemIds.length; i++) {
            var inputItem = this.getView().down('#' + inputItemIds[i])

            inputItem.validate()

        }
    },

    suppressChangeEvents: function(suppress) {
        var inputItemIds = this.getInputItemIds().concat(), // Make a copy
            inputItem


        inputItemIds.push('txtMaxLayoutHeight', 'txtMaxLayoutWidth')


        for (var i = 0
 i < inputItemIds.length; i++) {
            inputItem = this.getView().down('#' + inputItemIds[i])

            if (suppress) {
                inputItem.suspendEvent('change')

            } else {
                inputItem.resumeEvent('change')

            }
        }
    },

    getInputItemIds: function() {
        var inputItemIds = [
            'txtSlotHeight',
            'txtSlotWidth',
            'txtMarginTop',
            'txtMarginBottom',
            'txtMarginLeft',
            'txtMarginRight',
            'txtPrintOffsetY',
            'txtPrintOffsetX',
            'txtNumRows',
            'txtNumColumns',
            'txtSpacingVert',
            'txtSpacingHorz'
        ]


        return inputItemIds

    },

    getInputItemValues: function() {
        var inputItemValues = [
            'slotHeightMM',
            'slotWidthMM',
            'topMarginMM',
            'bottomMarginMM',
            'leftMarginMM',
            'rightMarginMM',
            'yPrintOffsetMM',
            'xPrintOffsetMM',
            'rowCount',
            'columnCount',
            'vertSpacingMM',
            'horzSpacingMM'
        ]


        return inputItemValues

    },

    fillZeroValueFields: function() {
        var inputItemIds = this.getInputItemIds()

        var inputItemValues = this.getInputItemValues()


        var viewModel = this.getViewModel()


        for (var i = 0
 i < inputItemIds.length; i++) {
            var itemValue = viewModel.get(inputItemValues[i])

            if (itemValue === 0) {
                var inputItem = this.getView().down('#' + inputItemIds[i])

                inputItem.setValue(itemValue)

            }
        }
    },

    getLayoutSizeDefault: function() {
        var slotHeightDefault = RolandKioskPrint.app.constants.SLOT_HEIGHT_DEFAULT,
            slotWidthDefault = RolandKioskPrint.app.constants.SLOT_WIDTH_DEFAULT,
            originPositionDefault = RolandKioskPrint.app.constants.ORIGIN_POSITION_DEFAULT,
            spacingDefault = RolandKioskPrint.app.constants.SPACING_DEFAULT,
            numRowsDefault = RolandKioskPrint.app.constants.NUM_ROWS_DEFAULT,
            numColumnsDefault= RolandKioskPrint.app.constants.NUM_COLUMNS_DEFAULT


        var defaultLayoutHeight = 2 * originPositionDefault +
            slotHeightDefault * numRowsDefault +
            spacingDefault * (numRowsDefault - 1)


        var defaultLayoutWidth = 2 * originPositionDefault +
            slotWidthDefault * numColumnsDefault +
            spacingDefault * (numColumnsDefault - 1)


        return {
            h: defaultLayoutHeight,
            w: defaultLayoutWidth
        }

    },

    getLayoutSizeMax: function() {
        var slotHeightMax = RolandKioskPrint.app.constants.SLOT_HEIGHT_MAX,
            slotWidthMax = RolandKioskPrint.app.constants.SLOT_WIDTH_MAX,
            originPositionMax = RolandKioskPrint.app.constants.ORIGIN_POSITION_MAX,
            spacingMax = RolandKioskPrint.app.constants.SPACING_MAX,
            numRowsMax = this.numRowsMax,
            numColumnsMax= this.numColsMax


        var maxLayoutHeight = 2 * originPositionMax +
            slotHeightMax * numRowsMax +
            spacingMax * (numRowsMax - 1)


        var maxLayoutWidth = 2 * originPositionMax +
            slotWidthMax * numColumnsMax +
            spacingMax * (numColumnsMax - 1)


        return {
            h: maxLayoutHeight,
            w: maxLayoutWidth
        }

    },

    toSVGPath: function(path) {
        var svgPath = []


        for (var i = 0, numCommand = path.length
 i < numCommand; i++) {
            var currentPath = path[i],
                numArg = currentPath.length - 1


            var currSVGPath = currentPath[0],
                j = 1

            while (j <= numArg) {
                currSVGPath += currentPath[j]

                if (j++ != numArg) {
                    currSVGPath += ','

                }
            }
            svgPath.push(currSVGPath)

        }

        return svgPath.join('')

    },

    onPrintTypeChange: function(type) {
        var viewModel = this.getViewModel()

        var viewData = viewModel.getData()


        if (viewData.designerMode != RolandKioskPrint.app.constants.MODEL_LAYOUT_NEW) {
            return

        }

        var inputIDs = [
            '#txtSlotWidth',
            '#txtSlotHeight',
            '#txtMarginLeft',
            '#txtMarginRight',
            '#txtMarginTop',
            '#txtMarginBottom',
            '#txtNumRows',
            '#txtNumColumns',
            '#txtSpacingVert',
            '#txtSpacingHorz'
        ]


        var values = [
            viewModel.convertMMToUnit(viewData.units, RolandKioskPrint.app.constants.SLOT_WIDTH_DEFAULT),
            viewModel.convertMMToUnit(viewData.units, RolandKioskPrint.app.constants.SLOT_HEIGHT_DEFAULT),
            viewModel.convertMMToUnit(viewData.units, RolandKioskPrint.app.constants.ORIGIN_POSITION_DEFAULT),
            viewModel.convertMMToUnit(viewData.units, RolandKioskPrint.app.constants.ORIGIN_POSITION_DEFAULT),
            viewModel.convertMMToUnit(viewData.units, RolandKioskPrint.app.constants.ORIGIN_POSITION_DEFAULT),
            viewModel.convertMMToUnit(viewData.units, RolandKioskPrint.app.constants.ORIGIN_POSITION_DEFAULT),
            RolandKioskPrint.app.constants.NUM_ROWS_DEFAULT,
            RolandKioskPrint.app.constants.NUM_COLUMNS_DEFAULT,
            viewModel.convertMMToUnit(viewData.units, RolandKioskPrint.app.constants.SPACING_DEFAULT),
            viewModel.convertMMToUnit(viewData.units, RolandKioskPrint.app.constants.SPACING_DEFAULT)
        ]


        var foilOrMetalPrint = (type == RolandKioskPrint.app.constants.PRINT_TYPE_FOIL ||
                                type == RolandKioskPrint.app.constants.PRINT_TYPE_METAL)


        viewModel.setData({
            fixedSize: foilOrMetalPrint,
            printType: type
        })


        if (foilOrMetalPrint) {
            var traySize = type == (RolandKioskPrint.app.constants.PRINT_TYPE_FOIL) ? RolandKioskPrint.app.constants.FOIL_PRINT_TRAY_SIZE :
                                                                                      RolandKioskPrint.app.constants.METAL_PRINT_TRAY_SIZE

            var convertedTraySize = viewModel.convertMMToUnit(viewData.units, traySize)


            values = [
                convertedTraySize,
                convertedTraySize,
                0, 0, 0, 0,
                1, 1, // 1x1 always
                0, 0
            ]


            this.sizeRestriction = viewModel.get('sizeRestriction')

            this.clearSizeConstraints()

        }

        for (i = 0
 i < inputIDs.length; i++) {
            var element = this.getView().down(inputIDs[i])

            element.setValue(values[i])

        }

        this.updateModelLayoutView()

    },

    validateNumRowsCols: function() {
        // Validate the total number of slots are below the maximum allowed limit.
        var data = this.getViewModel().getData(),
            numSlots = data.rowCount * data.columnCount


        if (numSlots <= RolandKioskPrint.app.constants.MAX_SLOT_COUNT) {
            return {
                status: true
            }

        }

        var invalidItem

        var msg = Ext.String.format(RolandKioskPrint.app.getString('message.pmd_mld.slotsTooMany'),
                                    RolandKioskPrint.app.constants.MAX_SLOT_COUNT)


        if (data.columnCount > 1) {
            invalidItem = this.getView().down('#txtNumColumns')

            invalidItem.markInvalid(msg)

        }

        if (data.rowCount > 1) {
            invalidItem = this.getView().down('#txtNumRows')

            invalidItem.markInvalid(msg)

        }

        return {
            status: false,
            invalidItem: invalidItem
        }

    },

    onDrawAfterLayout: function(container, layout, eOpts) {
        this.updateModelLayoutView()

    },

    onPrintTypeRadiogroupChange: function(field, newValue, oldValue, eOpts) {
        this.onPrintTypeChange(newValue)

    },

    onUnitsRadiogroupChange: function(field, newValue, oldValue, eOpts) {
        this.suppressChangeEvents(true)

        this.setSizeLimits(newValue)
 // Update the limits as per the selected unts.

        // Fill in the zero value fields.
        this.fillZeroValueFields()


        // Validate as limits changed.
        // Do validation in deferred mode, giving view model a chance to update itself.
        var me = this

        setTimeout(function() {
            me.suppressChangeEvents(false)

            me.validateInputs()

            me.validateLayoutWidth()

            me.validateLayoutHeight()

        }, 150)

    },

    onChkSizeRestrictionCheckboxChange: function(field, newValue, oldValue, eOpts) {
        this.updateModelLayoutView()

        if (newValue) {
            this.validateLayoutWidth()

            this.validateLayoutHeight()

        } else {
            this.clearSizeConstraints()

        }
    },

    onMaxLayoutHeightTextChange: function(field, newValue, oldValue, eOpts) {
        this.updateModelLayoutView()

        this.validateLayoutHeight()

        this.validateLayoutWidth()

    },

    onMaxLayoutWidthTextChange: function(field, newValue, oldValue, eOpts) {
        this.updateModelLayoutView()

        this.validateLayoutHeight()

        this.validateLayoutWidth()

    },

    onSlotHeightTextChange: function(field, newValue, oldValue, eOpts) {
        // Update the model layout view when the slot height changes.
        // This listener has a buffer of 100ms which serves two purposes.
        // First, we are not updating at every key stroke, and second, it
        // gives ample time for the view model to get updated. If there is
        // no buffer, the view model data would not be updated yet.
        // The same applies to all textfield 'change' handlers below.

        this.updateModelLayoutView()

        if (!this.validateLayoutHeight(true)) {
            field.markInvalid(this.heightExceededMsg)

        }
    },

    onSlotHeightTextFocusleave: function(component, event, eOpts) {
        if (!this.validateLayoutHeight(true)) {
            component.markInvalid(this.heightExceededMsg)

        }
    },

    onSlotWidthTextChange: function(field, newValue, oldValue, eOpts) {
        this.updateModelLayoutView()

        if (!this.validateLayoutWidth(true)) {
            field.markInvalid(this.widthExceededMsg)

        }
    },

    onSlotWidthTextFocusleave: function(component, event, eOpts) {
        if (!this.validateLayoutWidth(true)) {
            component.markInvalid(this.widthExceededMsg)

        }
    },

    onRotateNoneButtonToggle: function(button, pressed, eOpts) {
        if (pressed) {
            this.updateModelLayoutView()

        }
    },

    onRotateLeft90ButtonToggle: function(button, pressed, eOpts) {
        if (pressed) {
            this.updateModelLayoutView()

        }
    },

    onRotate180ButtonToggle: function(button, pressed, eOpts) {
        if (pressed) {
            this.updateModelLayoutView()

        }
    },

    onRotate90ButtonToggle: function(button, pressed, eOpts) {
        if (pressed) {
            this.updateModelLayoutView()

        }
    },

    onMarginTopTextChange: function(field, newValue, oldValue, eOpts) {
        this.updateModelLayoutView()

        if (!this.validateLayoutHeight(true)) {
            field.markInvalid(this.heightExceededMsg)

        }
    },

    onMarginTopTextFocusleave: function(component, event, eOpts) {
        if (!this.validateLayoutHeight(true)) {
            component.markInvalid(this.heightExceededMsg)

        }
    },

    onMarginBottomTextChange: function(field, newValue, oldValue, eOpts) {
        this.updateModelLayoutView()

        if (!this.validateLayoutHeight(true)) {
            field.markInvalid(this.heightExceededMsg)

        }
    },

    onMarginBottomTextFocusleave: function(component, event, eOpts) {
        if (!this.validateLayoutHeight(true)) {
            component.markInvalid(this.heightExceededMsg)

        }
    },

    onMarginLeftTextChange: function(field, newValue, oldValue, eOpts) {
        this.updateModelLayoutView()

        if (!this.validateLayoutWidth(true)) {
            field.markInvalid(this.widthExceededMsg)

        }
    },

    onMarginLeftTextFocusleave: function(component, event, eOpts) {
        if (!this.validateLayoutWidth(true)) {
            component.markInvalid(this.widthExceededMsg)

        }
    },

    onMarginRightTextChange: function(field, newValue, oldValue, eOpts) {
        this.updateModelLayoutView()

        if (!this.validateLayoutWidth(true)) {
            field.markInvalid(this.widthExceededMsg)

        }
    },

    onMarginRightTextFocusleave: function(component, event, eOpts) {
        if (!this.validateLayoutWidth(true)) {
            component.markInvalid(this.widthExceededMsg)

        }
    },

    onNumRowsTextChange: function(field, newValue, oldValue, eOpts) {
        this.updateModelLayoutView()

        if (!this.validateLayoutHeight(true)) {
            field.markInvalid(this.heightExceededMsg)

        }
    },

    onNumRowsFocusleave: function(component, event, eOpts) {
        if (!this.validateLayoutHeight(true)) {
            component.markInvalid(this.heightExceededMsg)

        }
    },

    onNumColumnsTextChange: function(field, newValue, oldValue, eOpts) {
        this.updateModelLayoutView()

        if (!this.validateLayoutWidth(true)) {
            field.markInvalid(this.widthExceededMsg)

        }
    },

    onNumColumnsFocusleave: function(component, event, eOpts) {
        if (!this.validateLayoutWidth(true)) {
            component.markInvalid(this.widthExceededMsg)

        }
    },

    onSpacingVertTextChange: function(field, newValue, oldValue, eOpts) {
        this.updateModelLayoutView()

        if (!this.validateLayoutHeight(true)) {
            field.markInvalid(this.heightExceededMsg)

        }
    },

    onSpacingVertFocusleave: function(component, event, eOpts) {
        if (!this.validateLayoutHeight(true)) {
            component.markInvalid(this.heightExceededMsg)

        }
    },

    onSpacingHorzTextChange: function(field, newValue, oldValue, eOpts) {
        this.updateModelLayoutView()

        if (!this.validateLayoutWidth(true)) {
            field.markInvalid(this.widthExceededMsg)

        }
    },

    onSpacingHorzFocusleave: function(component, event, eOpts) {
        if (!this.validateLayoutWidth(true)) {
            component.markInvalid(this.widthExceededMsg)

        }
    },

    onCancelButtonClick: function(button, e, eOpts) {
        this.redirectTo('#template/main', true)

    },

    onNextButtonClick: function(button, e, eOpts) {
        var layoutData = this.getViewModel().getData()

        if (layoutData.editable) {
            // Validate the user input.
            if (!this.validateUserInput()) {
                return

            }
            this.updateModelLayoutData()


            // Validate the layout max size constraints.
            var isValidWidth = this.validateLayoutWidth()

            var isValidHeight = this.validateLayoutHeight()

            if (!isValidWidth || !isValidHeight) {
                return

            }
        }

        var layoutTemplateData = {
            version: RolandKioskPrint.app.version,
            source: layoutData.source,
            layoutWidth: layoutData.layoutWidthMM,
            layoutHeight: layoutData.layoutHeightMM,
            slots: layoutData.slots,
            rotationAngle: layoutData.rotationAngle,
            printType: layoutData.printType
        }


        // Add the editable data.
        if (layoutData.editable) {
            layoutTemplateData.unitsCreated = layoutData.units

            layoutTemplateData.slotWidth = layoutData.slotWidthMM

            layoutTemplateData.slotHeight = layoutData.slotHeightMM

            layoutTemplateData.leftMargin = layoutData.leftMarginMM

            layoutTemplateData.rightMargin = layoutData.rightMarginMM

            layoutTemplateData.topMargin = layoutData.topMarginMM

            layoutTemplateData.bottomMargin = layoutData.bottomMarginMM

            layoutTemplateData.horzPrintOffset = layoutData.xPrintOffsetMM

            layoutTemplateData.vertPrintOffset = layoutData.yPrintOffsetMM

            layoutTemplateData.numRows = layoutData.rowCount

            layoutTemplateData.numCols = layoutData.columnCount

            layoutTemplateData.horzSpacing = layoutData.horzSpacingMM

            layoutTemplateData.vertSpacing = layoutData.vertSpacingMM


            var sizeRestriction = layoutData.sizeRestriction && !layoutData.fixedSize

            layoutTemplateData.sizeRestriction = sizeRestriction


            if (sizeRestriction) {
                layoutTemplateData.maxLayoutWidth = layoutData.maxLayoutWidthMM

                layoutTemplateData.maxLayoutHeight = layoutData.maxLayoutHeightMM

            }

            // Update the units preference.
            RolandKioskPrint.app.setPrefUnits(layoutData.units)

        }

        var me = this

        var view = this.getView()

        view.getEl().mask(RolandKioskPrint.app.getString('message.pmd_mld.creatingMLData'))


        setTimeout(function() {
            var thumb = me.getModelLayoutThumb()

            var modelLayoutData = {
                layoutName: layoutData.layoutName, // Updated on the model layout save screen
                layoutTemplate: layoutTemplateData,
                layoutThumb: thumb
            }

            var widget = Ext.widget('modellayoutdesignersave')

            widget.getViewModel().setData(modelLayoutData)


            RolandKioskPrint.app.showModalView(widget)

            view.getEl().unmask()

        }, 10)

    },

    onCloseButtonClick: function(button, e, eOpts) {
        this.redirectTo('#template/main', true)

    },

    onMainViewBeforeShow: function(component, eOpts) {
        // Get features.
        var features = RolandKioskPrint.AppData.getFeatures()

        var printTypeHidden = !features.allowFoilPrint && !features.allowMetalPrint


        // Initialize as per the mode.
        var mode = RolandKioskPrint.AppData.modelLayoutDesignerMode

        var modelLayoutData = RolandKioskPrint.AppData.modelLayoutData

        var viewData


        var printType = RolandKioskPrint.app.constants.PRINT_TYPE_COLOR
 // the default
        if (modelLayoutData && modelLayoutData.printType) {
            printType = modelLayoutData.printType

        }

        // Suppress textfield change events from firing.
        // This avoids unnecessary drawing of the model layout.
        // It gets drawn in the view's afterlayout handler.
        this.suppressChangeEvents(true)


        var fixedSize = (printType == RolandKioskPrint.app.constants.PRINT_TYPE_FOIL ||
        printType == RolandKioskPrint.app.constants.PRINT_TYPE_METAL)


        if ((mode == RolandKioskPrint.app.constants.MODEL_LAYOUT_EDIT ||
        mode == RolandKioskPrint.app.constants.MODEL_LAYOUT_PREVIEW) &&
        modelLayoutData.source == 'Designer') {

            // Check for existing horzMargin and vertMargin and update it to top, bottom, left and right margin.
            var leftMargin, rightMargin, topMargin, bottomMargin

            leftMargin = (modelLayoutData.horzMargin !== undefined) ? modelLayoutData.horzMargin
            : modelLayoutData.leftMargin

            rightMargin = (modelLayoutData.horzMargin !== undefined) ? modelLayoutData.horzMargin
            : modelLayoutData.rightMargin

            topMargin = (modelLayoutData.vertMargin !== undefined) ? modelLayoutData.vertMargin
            : modelLayoutData.topMargin

            bottomMargin = (modelLayoutData.vertMargin !== undefined) ? modelLayoutData.vertMargin
            : modelLayoutData.bottomMargin


            viewData = {
                designerMode: mode,
                source: modelLayoutData.source,
                sizeRestriction: modelLayoutData.sizeRestriction || false,
                layoutWidthMM: modelLayoutData.layoutWidth,
                layoutHeightMM: modelLayoutData.layoutHeight,
                slots: modelLayoutData.slots,
                maxLayoutWidthMM: modelLayoutData.maxLayoutWidth || null,
                maxLayoutHeightMM: modelLayoutData.maxLayoutHeight || null,
                units: modelLayoutData.unitsCreated,
                slotWidthMM:  modelLayoutData.slotWidth,
                slotHeightMM: modelLayoutData.slotHeight,
                leftMarginMM: leftMargin,
                rightMarginMM: rightMargin,
                topMarginMM: topMargin,
                bottomMarginMM: bottomMargin,
                xPrintOffsetMM: modelLayoutData.horzPrintOffset,
                yPrintOffsetMM: modelLayoutData.vertPrintOffset,
                columnCount: modelLayoutData.numCols,
                rowCount: modelLayoutData.numRows,
                horzSpacingMM: modelLayoutData.horzSpacing,
                vertSpacingMM: modelLayoutData.vertSpacing,
                editable: (mode == RolandKioskPrint.app.constants.MODEL_LAYOUT_EDIT) ? true : false,
                rotationAngle: modelLayoutData.rotationAngle || 0,
                layoutName: modelLayoutData.layoutName,
                printType: printType,
                fixedSize: fixedSize,
                printTypeHidden: printTypeHidden,
                // Disable for edit mode. For preview, readOnly takes care that Foil Print can't be changed.
                printTypeEditable: (mode == RolandKioskPrint.app.constants.MODEL_LAYOUT_EDIT) ? false : true,
            }


            this.getViewModel().setData(viewData)
 // Set the view model data.

        } else if (mode == RolandKioskPrint.app.constants.MODEL_LAYOUT_IMPORT ||
        mode == RolandKioskPrint.app.constants.MODEL_LAYOUT_EDIT ||
        mode == RolandKioskPrint.app.constants.MODEL_LAYOUT_PREVIEW) {
            viewData = {
                designerMode: mode,
                source: 'SVG',
                layoutWidthMM: modelLayoutData.layoutWidth,
                layoutHeightMM: modelLayoutData.layoutHeight,
                slots: modelLayoutData.slots,
                units: null,
                sizeRestriction: false,
                maxLayoutWidthMM: null,
                maxLayoutHeightMM: null,
                slotWidthMM: null,
                slotHeightMM: null,
                leftMarginMM: null,
                rightMarginMM: null,
                topMarginMM: null,
                bottomMarginMM: null,
                xPrintOffsetMM: null,
                yPrintOffsetMM: null,
                columnCount: null,
                rowCount: null,
                horzSpacingMM: null,
                vertSpacingMM: null,
                editable: false,
                rotationAngle: modelLayoutData.rotationAngle || 0,
                layoutName: modelLayoutData.layoutName,
                printType: printType,
                fixedSize: fixedSize,
                printTypeHidden: printTypeHidden,
                printTypeEditable: false
            }


            this.getViewModel().setData(viewData)
 // Set the view model data.
        } else {
            // mode == RolandKioskPrint.app.constants.MODEL_LAYOUT_NEW
            // Set default values.
            var layoutSizeDefault = this.getLayoutSizeDefault()

            viewData = {
                designerMode: mode,
                source: 'Designer',
                layoutWidthMM: null,
                layoutHeightMM: null,
                slots: null,
                units: RolandKioskPrint.app.getPrefUnits(),
                sizeRestriction: false,
                maxLayoutWidthMM: layoutSizeDefault.w,
                maxLayoutHeightMM: layoutSizeDefault.h,
                slotWidthMM: RolandKioskPrint.app.constants.SLOT_WIDTH_DEFAULT,
                slotHeightMM: RolandKioskPrint.app.constants.SLOT_HEIGHT_DEFAULT,
                leftMarginMM: RolandKioskPrint.app.constants.ORIGIN_POSITION_DEFAULT,
                rightMarginMM: RolandKioskPrint.app.constants.ORIGIN_POSITION_DEFAULT,
                topMarginMM: RolandKioskPrint.app.constants.ORIGIN_POSITION_DEFAULT,
                bottomMarginMM: RolandKioskPrint.app.constants.ORIGIN_POSITION_DEFAULT,
                xPrintOffsetMM: RolandKioskPrint.app.constants.PRINTING_POSITION_DEFAULT,
                yPrintOffsetMM: RolandKioskPrint.app.constants.PRINTING_POSITION_DEFAULT,
                columnCount: RolandKioskPrint.app.constants.NUM_COLUMNS_DEFAULT,
                rowCount: RolandKioskPrint.app.constants.NUM_ROWS_DEFAULT,
                horzSpacingMM: RolandKioskPrint.app.constants.SPACING_DEFAULT,
                vertSpacingMM: RolandKioskPrint.app.constants.SPACING_DEFAULT,
                editable: true,
                rotationAngle: 0,
                layoutName: '',
                printType: RolandKioskPrint.app.constants.PRINT_TYPE_COLOR,
                fixedSize: false,
                printTypeHidden: printTypeHidden,
                printTypeEditable: true
            }


            this.getViewModel().setData(viewData)
 // Set the view model data.
        }

        this.initInputs()


        this.numRowsMax = RolandKioskPrint.app.constants.MAX_SLOT_COUNT

        this.numColsMax = RolandKioskPrint.app.constants.MAX_SLOT_COUNT


        // Set the minimum and maximum limits for the various fields.
        var txtNumRows = this.getView().down('#txtNumRows')

        txtNumRows.minValue = RolandKioskPrint.app.constants.NUM_ROWS_MIN

        txtNumRows.maxValue = this.numRowsMax


        var txtNumColumns = this.getView().down('#txtNumColumns')

        txtNumColumns.minValue = RolandKioskPrint.app.constants.NUM_COLUMNS_MIN

        txtNumColumns.maxValue = this.numColsMax


        this.setSizeLimits(viewData.units)


        this.updatingLayoutView = false


        // Resume textfield change events.
        this.suppressChangeEvents(false)

    },

    onMainViewShow: function(component, eOpts) {
        var layoutData = this.getViewModel().getData()

        if (layoutData.editable) {
            var txtSlotHeight = this.getView().down('#txtSlotHeight')

            txtSlotHeight.focus()

            txtSlotHeight.selectText()

        }

        this.widthExceededMsg = RolandKioskPrint.app.getString('message.pmd_mld.maxLayoutWidthExceededWarning')

        this.heightExceededMsg = RolandKioskPrint.app.getString('message.pmd_mld.maxLayoutLengthExceededWarning')

    },

    onMainViewHide: function(component, eOpts) {
        RolandKioskPrint.view.window.HelpWindowViewController.closeHelp()

    },

    onPanelAfterRender: function(component, eOpts) {
        // Show/hide the print type options as per the functions allowed.
        var features = RolandKioskPrint.AppData.getFeatures()


        if (features.allowFoilPrint) {
            var optFoilPrint = this.getView().down('#optFoilPrint')

            optFoilPrint.show()

        }

        if (features.allowMetalPrint) {
            var optMetalPrint = this.getView().down('#optMetalPrint')

            optMetalPrint.show()

        }

        if (features.allowCutPrint) {
            var optCutPrint = this.getView().down('#optCutPrint')

            optCutPrint.show()

        }
    }

})

