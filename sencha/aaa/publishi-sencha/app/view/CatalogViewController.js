/*
 * File: app/view/CatalogViewController.js
 *
 * This file was generated by Sencha Architect version 4.2.4.
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 6.6.x Classic library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 6.6.x Classic. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('RolandKioskPrint.view.CatalogViewController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.catalog',

    openProductModel: function(record) {
        // Get product model data from server.
        var mainView = this.getView()

        mainView.getEl().mask(RolandKioskPrint.app.getString('message.pd.openingProductModel'))


        var productModel = record.data


        Ext.Ajax.request({
            scope: this,
            url: productModel.itemTemplatePath,
            success: function(response, opts) {
                mainView.getEl().unmask()


                var productModelData = Ext.decode(response.responseText)

                if (!productModelData) {
                    Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                                  RolandKioskPrint.app.getString('message.pd.openingProductModelFailed'))

                    return

                }

                productModelData.modelName = productModel.itemFullName

                productModelData.modelDisplayName = productModel.itemFullDisplayName

                productModelData.modelDesignPath = productModel.itemDesignPath

                productModelData.modelThumbPath = productModel.itemThumbPath

                productModelData.modelDescription = productModel.itemDescription

                productModelData.printType = productModel.printType


                // OTHER foil color changed to COPPER.
                if (RolandKioskPrint.app.isFoilPrintModel(productModelData) &&
                    productModelData.foilColorName == "OTHER" &&
                    Number(productModelData.version) < 2.7) {
                    productModelData.foilColorName = "COPPER"

                }

                RolandKioskPrint.AppData.productModelData =
                    new RolandKioskPrint.app.ProductModel(productModelData)


                // For metal print, validate if an existing material is specified.
                if (RolandKioskPrint.app.isMetalPrintModel(productModelData)) {
                    var materialsStore = Ext.StoreManager.lookup('MarkingMaterials')

                    var material = RolandKioskPrint.app.getIgnoreCase(materialsStore, 'materialName', productModelData.material)

                    if (!material) {
                        Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                                      RolandKioskPrint.app.getString('message.pd.openingProductModelFailed') + ' ' +
                                      RolandKioskPrint.app.getString('message.generic.contactStaff'))

                        return

                    }
                }

                // For cut print, validate if an existing cutting material is specified.
                if (RolandKioskPrint.app.isCutPrintModel(productModelData)) {
                    var cutMaterialsStore = Ext.StoreManager.lookup('CuttingMaterials')

                    var cutMaterial = RolandKioskPrint.app.getIgnoreCase(cutMaterialsStore, 'materialName', productModelData.cutMaterial)

                    if (!cutMaterial) {
                        Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                                      RolandKioskPrint.app.getString('message.pd.openingProductModelFailed') + ' ' +
                                      RolandKioskPrint.app.getString('message.generic.contactStaff'))

                        return

                    }
                }

                var validateDongle = false,
                    redirectUrl = '#client/check'


                // Check if custom size product model is selected.
                if (productModel.isCustomSize) {
                    // Have the user specify the product model size.
                    validateDongle = true

                    redirectUrl = '#client/custom'

                } else {
                    var uiSettings = RolandKioskPrint.AppData.getUiSettingsData()

                    if (uiSettings.skipCheckScreen) {
                        // Move to edit directly, in case the check screen has been skipped.
                        validateDongle = true

                        redirectUrl = '#client/editcontent'

                    }
                }

                if (validateDongle) {
                    // Check for USB dongle.
                    var me = this

                    var promise = RolandKioskPrint.AppData.isDongleValid()


                    promise.then(function() {
                        me.redirectTo(redirectUrl, true)

                    }, function(connectionError) {
                        var message

                        if (connectionError) {
                            message = RolandKioskPrint.app.getString('message.pd.openingProductModelFailed')

                        } else {
                            message = RolandKioskPrint.app.getString('message.generic.clientNotWorking') +
                                ' ' +
                                Ext.String.format(RolandKioskPrint.app.getString('message.generic.contactStaff'), '0x000001')

                        }
                        Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'), message)

                    })

                } else {
                    this.redirectTo(redirectUrl, true)

                }
            },
            failure: function() {
                mainView.getEl().unmask()

                Ext.Msg.alert(RolandKioskPrint.app.getString('message.generic.failed'),
                              RolandKioskPrint.app.getString('message.pd.openingProductModelFailed'))

            }
        })

    },

    categorizeProductModels: function(productModels) {
        this.rootCategories = {}

        this.categoryTreeHeight = 0


        var me = this

        productModels.forEach(function(productModel) {
            // If the product model is not associated to any model layout, do
            // not add it to the catalog.
            var connectedLayouts = productModel.connectedLayouts

            if (!connectedLayouts || connectedLayouts.length === 0) {
                return

            }

            me.addProductModel(productModel)

        })

    },

    addProductModel: function(productModel) {
        // Split the model name into category/sub-category part names.
        var partNames = productModel.modelName.split('.')


        var categories = this.rootCategories

        var length = partNames.length


        if (length > this.categoryTreeHeight) {
            this.categoryTreeHeight = length

        }

        var curPrefLang = RolandKioskPrint.app.getPrefClientLanguage()

        var categoryKeys = [
            'category_1',
            'category_2',
            'category_3',
            'category_4'
        ]


        var fullDisplayName = []

        for (var i = 0
 i < length - 1; i++) {
            var keyName = partNames[i].toLowerCase()


            // Check if we have seen this category before.
            // If not, create a new category object.
            if (!categories.hasOwnProperty(keyName)) {
                // Get the category display image.
                var displayImagePath = this.getDisplayImagePath(productModel, categoryKeys[i])


                // Get the category display name.
                var displayName = this.getDisplayName(productModel, curPrefLang, categoryKeys[i])


                // Get the category display description.
                var displayDescription = this.getDisplayDescription(productModel, curPrefLang, categoryKeys[i])

                categories[keyName] = {
                    _categoryData: {
                        categoryKey: keyName,
                        categoryName: displayName || partNames[i],
                        categoryThumbPath: displayImagePath || '',
                        categoryDescription: displayDescription || ''
                    }
                }

            }
            categories = categories[keyName]


            var categoryData = categories._categoryData

            fullDisplayName.push(categoryData.categoryName)

        }

        i = length - 1

        var keyName = partNames[i]


        // Get the product display image.
        var displayImagePath = this.getDisplayImagePath(productModel, categoryKeys[i])


        // Get the product display name.
        var displayName = this.getDisplayName(productModel, curPrefLang, categoryKeys[i])

        var productName = displayName || partNames[i]


        fullDisplayName.push(productName)


        // Get the product display description.
        var displayDescription = this.getDisplayDescription(productModel, curPrefLang, categoryKeys[i])


        if (!productModel.customSize) {
            categories[keyName] = {
                modelKey: keyName,
                modelName: productName,
                modelFullName: productModel.modelName,
                modelFullDisplayName: fullDisplayName.join('.'),
                modelTemplatePath: productModel.modelTemplatePath,
                modelDesignPath: productModel.modelDesignPath,
                modelThumbPath: displayImagePath || productModel.modelThumbPath,
                modelDescription: displayDescription || '',
                currency: productModel.currency,
                pricePerUnit: productModel.pricePerUnit,
                customSize: false,
                printType: productModel.printType
            }

        } else {
            // Custom size product.
            var printType = productModel.printType


            if (!printType) {
                printType = RolandKioskPrint.app.constants.PRINT_TYPE_COLOR

            }

            categories[keyName] = {
                modelKey: keyName,
                modelName: productName,
                modelFullName: productModel.modelName,
                modelFullDisplayName: fullDisplayName.join(''),
                modelTemplatePath: productModel.modelTemplatePath, // Specifies the spot color and cut options
                modelDesignPath: '', // Ignore
                modelThumbPath: displayImagePath || this.getCustomProductSizeImageUrl(),
                modelDescription: displayDescription || '',
                customSize: true,
                printType: printType
            }

        }
    },

    showCategories: function() {
        // Populate the grid view.
        var gridView = this.getView().down('#gridView')

        this.populateView(gridView, this.rootCategories)


        // Initialize the book-keeping stuff.
        this.currentCategories = this.rootCategories

        this.gridCategoryPath = ['Home']

        this.gridCurrentLevel = 0


        // Create all the buttons for bread crumb.
        var me = this

        var breadcrumb = this.getView().down('#breadCrumb')

        for (var i = 1
 i < this.categoryTreeHeight; i++) {
            var spacer = Ext.create('RolandKioskPrint.view.field.BreadCrumbSpacer', {hidden: true})

            var button = Ext.create('RolandKioskPrint.view.button.BreadCrumbButton', {scope: me, text: '', myLevel: i, hidden: true, handler: me.onBreadCrumbButtonClick})


            breadcrumb.items.add(spacer)

            breadcrumb.items.add(button)


            me.gridCategoryPath.push('')

        }

        breadcrumb.updateLayout()

    },

    populateView: function(view, categories) {
        // Create the items list.
        var items = []


        for (var key in categories) {
            if (categories.hasOwnProperty(key) && key != '_categoryData') {
                var data = categories[key]

                if (data._categoryData) {
                    var categoryData = data._categoryData

                    items.push([
                        categoryData.categoryKey,
                        true,
                        categoryData.categoryName,
                        categoryData.categoryName,
                        categoryData.categoryName,
                        categoryData.categoryDescription,
                        '',
                        '',
                        categoryData.categoryThumbPath,
                        '',
                        false,
                        ''
                    ])

                } else {
                    var pricePerUnit = (data.customSize ? '' : data.currency + ' ' + RolandKioskPrint.AppData.formatNumber(data.pricePerUnit)),
                        catalogUISettingsData = RolandKioskPrint.AppData.getCatalogUISettingsData() || {}


                    if (catalogUISettingsData.hidePriceOnCatalog) {
                        pricePerUnit = ''

                    }

                    items.push([
                        data.modelKey,
                        false,
                        data.modelName,
                        data.modelFullName,
                        data.modelFullDisplayName,
                        data.modelDescription,
                        data.modelTemplatePath,
                        data.modelDesignPath,
                        data.modelThumbPath,
                        pricePerUnit,
                        data.customSize,
                        data.printType
                    ])

                }
            }
        }

        var store = view.getStore()

        store.removeAll()

        store.setData(items)

    },

    forceFontsDownload: function() {
        // The need to force download fonts.
        // In order to show fabric text objects with the correct applied font, the font files are
        // required to be available before we get into the designer and load those text objects.
        // While some browsers, like IE, download the font files on encountering the @font-face
        // declarations in stylesheet and do not have this problem, others like Chrome and Safari
        // do not request the font file unless it is used in the html document.
        // Here we generate markup which is styled with these fonts, which in turn causes the browser
        // to request downloading of the font files.

        // First, get the list of fonts to force download.
        var fontsStore = Ext.StoreManager.lookup('Fonts')


        fontsStore.load({
            scope: this,
            callback: function(records, operation, success) {
                // Create dummy div elements styled with these fonts. This in turn forces
                // the browser to download these fonts.
                var parentElement = this.getView().getEl().dom


                var html = '<div style="font-family:\'{familyName}\'
 font-weight: normal; font-style: normal; height:0px;">&nbsp;</div>' +
                    '<div style="font-family:\'{familyName}\'
 font-weight: normal; font-style: italic; height:0px;">&nbsp;</div>' +
                    '<div style="font-family:\'{familyName}\'
 font-weight: bold; font-style: normal; height:0px;">&nbsp;</div>' +
                    '<div style="font-family:\'{familyName}\'
 font-weight: bold; font-style: italic; height:0px;">&nbsp;</div>';
                var tpl = Ext.DomHelper.createTemplate(html)

                tpl.compile()


                fontsStore.each(function(record) {
                    tpl.append(parentElement, {
                        familyName: record.data.familyName
                    })

                })


                // Add the fallback notdef font.
                tpl.append(parentElement, {
                    familyName: 'Notdef'
                })

            }
        })

    },

    getDisplayImagePath: function(productModel, categoryKey) {
        var modelLangData = productModel.modelLangData

        if (!modelLangData) {
            return
 // undefined
        }

        var imagesData = modelLangData.images

        if (!imagesData) {
            return
 // undefined
        }

        return imagesData[categoryKey]

    },

    getDisplayName: function(productModel, prefLang, categoryKey) {
        var modelLangData = productModel.modelLangData

        if (!modelLangData) {
            return
 // undefined
        }

        var namesData = modelLangData.names

        if (!namesData) {
            return
 // undefined
        }

        var langData = namesData[prefLang]

        if (!langData) {
            return
 // undefined
        }

        return langData[categoryKey]

    },

    onBreadCrumbButtonClick: function(button) {
        var level = button.myLevel


        if (level == this.gridCurrentLevel)
            return


        var categories = this.rootCategories


        for (var i = 1
 i <= level; i++) {
            categories = categories[this.gridCategoryPath[i]]

        }

        var gridView = this.getView().down('#gridView')

        this.populateView(gridView, categories)


        this.currentCategories = categories

        this.gridCurrentLevel = level


        var breadcrumb = this.getView().down('#breadCrumb')

        var index = level * 2


        for (i = breadcrumb.items.length - 1
 i > index; i--) {
            breadcrumb.items.items[i].hide()

        }
    },

    resetCatalogView: function() {
        this.resetGridView()

    },

    resetGridView: function() {
        // Clear bread crumb except the 'Home' button.
        var breadcrumb = this.getView().down('#breadCrumb')

        for(var i = breadcrumb.items.length - 1
 i > 0; i--) {
            breadcrumb.items.items[i].hide()

        }

        // Reset grid book-keeping stuff.
        this.currentCategories = this.rootCategories

        this.gridCurrentLevel = 0


        // Show root categories.
        var gridView = this.getView().down('#gridView')

        this.populateView(gridView, this.rootCategories)

    },

    getDisplayDescription: function(productModel, prefLang, categoryKey) {
        var modelLangData = productModel.modelLangData

        if (!modelLangData) {
            return
 // undefined
        }

        var descriptionData = modelLangData.descriptions

        if (!descriptionData) {
            return
 // undefined
        }

        var langData = descriptionData[prefLang]

        if (!langData) {
            return
 // undefined
        }

        return langData[categoryKey]

    },

    getCustomProductSizeImageUrl: function() {
        // The product size image is different for different locales.
        // Pick the right image based on the cotodesign UI locale.

        var curPrefLang = RolandKioskPrint.app.getPrefClientLanguage()


        if (!RolandKioskPrint.app.isSystemLanguage(curPrefLang)) {
            curPrefLang = 'en'

        }

        var imgUrl = 'resources/images/lang-specific/' + curPrefLang + '/ProductCustomSize.png'


        return imgUrl

    },

    onBreadCrumbHomeButtonClick: function(button, e, eOpts) {
        this.resetGridView()

    },

    onGridViewResize: function(component, width, height, oldWidth, oldHeight, eOpts) {
        // Resize the grid items based on the usable width and height.
        // Get the grid view border, padding and item margin.
        var gridViewPadding = Ext.util.CSS.getRule('.catalog-grid-view').style.getPropertyValue('padding-left')

        var boxMargin = Ext.util.CSS.getRule('div.catalog-grid-item-wrap').style.getPropertyValue('margin-right')


        gridViewPadding = parseInt(gridViewPadding)

        boxMargin = parseInt(boxMargin)


        if (isNaN(gridViewPadding)) {
            gridViewPadding = 0

        }

        if (isNaN(boxMargin)) {
            boxMargin = 0

        }

        // Compute the usable width and height.
        var usableWidth = width - gridViewPadding

        var usableHeight = height - gridViewPadding


        if (Ext.os.deviceType != 'Tablet' && Ext.os.deviceType != 'Phone') {
            // Space eaten by the scroll bar.
            usableWidth -= 17

        }

        // Apply constraints on item width and height.
        var widthMin = RolandKioskPrint.app.constants.CATALOG_GRID_ITEM_WIDTH_MIN

        var heightMin = RolandKioskPrint.app.constants.CATALOG_GRID_ITEM_HEIGHT_MIN

        var rowItemsMax = RolandKioskPrint.app.constants.CATALOG_GRID_ROW_ITEMS_MAX

        var aspectRatio = 1.61803398875
 // Golden ratio

        var itemBoxWidth = usableWidth / rowItemsMax

        var itemBoxHeight = usableHeight / 2


        while (itemBoxWidth < widthMin && rowItemsMax > 1) {
            itemBoxWidth = usableWidth / (--rowItemsMax)

        }

        if (itemBoxWidth < widthMin) {
            itemBoxWidth = widthMin

        }

        var itemWidth = Math.floor(itemBoxWidth - boxMargin)

        var itemHeight = Math.floor(itemBoxHeight - boxMargin)


        if (itemHeight > itemWidth) {
            itemHeight = itemWidth

        }

        if ((itemWidth / itemHeight) > aspectRatio) {
            itemHeight = Math.floor(itemWidth / aspectRatio)

        }

        Ext.util.CSS.updateRule('div.catalog-grid-item-wrap', 'width', itemWidth + 'px')

        Ext.util.CSS.updateRule('div.catalog-grid-item-wrap', 'height', itemHeight + 'px')


        var lineHeightFactor = 1.25
 // line-height to font-size ratio
        var lineHeight = (itemHeight * 0.2) / 2
 // 20% for item's text - product name and price

        Ext.util.CSS.updateRule('div.catalog-grid-item-wrap .catalog-grid-item-text', 'line-height', lineHeightFactor)


        var maxFontSize = Math.floor(lineHeight / lineHeightFactor)

        var currentFontSize = Ext.util.CSS.getRule('div.catalog-grid-item-wrap .catalog-grid-item-text').style.getPropertyValue('font-size')

        currentFontSize = parseInt(currentFontSize)


        if (!isNaN(currentFontSize) && (currentFontSize > maxFontSize)) {
            Ext.util.CSS.updateRule('div.catalog-grid-item-wrap .catalog-grid-item-text', 'font-size', maxFontSize + 'px')

        }
    },

    onGridViewItemClick: function(dataview, record, item, index, e, eOpts) {
        if (!record.data.isCategory) {
            this.openProductModel(record)

            return
 // Leaf selected
        }

        // Show the corresponding breadcrumb buttons.
        var breadcrumb = this.getView().down('#breadCrumb')


        var start = this.gridCurrentLevel * 2

        breadcrumb.items.items[start + 1].show()
 // Spacer
        breadcrumb.items.items[start + 2].setText(record.data.itemName)

        breadcrumb.items.items[start + 2].show()
 // Button

        // Populate the grid with the child categories/items.
        this.currentCategories = this.currentCategories[record.data.itemKey]

        this.populateView(dataview, this.currentCategories)

        dataview.getScrollable().scrollTo(0, 0)


        this.gridCurrentLevel += 1

        this.gridCategoryPath[this.gridCurrentLevel] = record.data.itemKey

    },

    onMainViewShow: function(component, eOpts) {
        if (!this.fontsDownloaded) {
            // Force font downloading by the browser.
            this.forceFontsDownload()

            this.fontsDownloaded = true

        }

        // Clear the active product model.
        RolandKioskPrint.AppData.productModelData = null


        // Start tracking user activity.
        RolandKioskPrint.app.startTrackingActivity()


        if (this.rootCategories) {
            return
 // Already populated.
        }

        this.rootCategories = {}


        var mainView = this.getView()

        mainView.getEl().mask(RolandKioskPrint.app.getString('message.pd.openingCatalog'))

        //var now = new Date()


        var features = RolandKioskPrint.AppData.getFeatures()

        var curPrefLang = RolandKioskPrint.app.getPrefClientLanguage()

        var serverUrl = Ext.String.format(
        RolandKioskPrint.app.constants.PRODUCT_MODEL_DETAILS_URL, curPrefLang)


        // Get the list of product models, and populate the view.
        Ext.Ajax.request({
            scope: this,
            url: serverUrl,
            timeout: RolandKioskPrint.app.constants.SERVER_REQUEST_TIMEOUT,
            success: function(response, opts) {
                mainView.getEl().unmask()

                //console.log('Time taken to load template list (for catalog) = ' + (new Date() - now))


                var productModelsData = Ext.decode(response.responseText)

                if (productModelsData && productModelsData.success) {
                    // Parse the product models list into categories.
                    var productModels = productModelsData.productModels

                    if (!features.allowFoilPrint) {
                        productModels = productModels.filter(function(productModel) {
                            return !RolandKioskPrint.app.isFoilPrintModel(productModel)

                        })

                    }

                    if (!features.allowMetalPrint) {
                        productModels = productModels.filter(function(productModel) {
                            return !RolandKioskPrint.app.isMetalPrintModel(productModel)

                        })

                    }
                    this.categorizeProductModels(productModels)

                }

                // Show these out.
                this.showCategories()

            },
            failure: function() {
                mainView.getEl().unmask()


                // Blank out the grid view.
                this.showCategories()

            }
        })

    },

    onMainViewAfterRender: function(component, eOpts) {
        // Create and set the data store for the grid view.
        var catalogGridItems = Ext.create('Ext.data.ArrayStore', {
            storeId: 'CatalogGridItems',
            model: 'RolandKioskPrint.model.CatalogItem'
        })


        this.getView().down('#gridView').setStore(catalogGridItems)


        var navPanel = this.getView().down('#navPanel')

        navPanel.getController().setCurrentStep(RolandKioskPrint.app.constants.ITEM_LIST_STEP)

    }

})

